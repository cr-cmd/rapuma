#!/usr/bin/python
# -*- coding: utf-8 -*-

# By Dennis Drescher (dennis_drescher at sil.org


###############################################################################
######################### Description/Documentation ###########################
###############################################################################

# One script to rule them all.  This is the main Rapuma engine script.
# This script will drive all processes and keep track of what happens in the
# project log in each respective project.


###############################################################################
################################ Initialize Rapuma ###############################
###############################################################################
# Firstly, import all the standard Python modules we need for this process and
# set the base path

import os, sys, timeit, datetime
from functools import partial

startTime = timeit.default_timer()

###########################################################################
########################## Location Discovery #############################
###########################################################################

# Set the Rapuma base program paths. It looks in /user/share first for an
# installed copy. If you give it a actual path to the development version
# it will run from there. (~/Projects/rapuma/scripts/rapuma)
# FIXME: Environment variables are set that may not be needed if this block
# of code was turned into a module and called from the dependent modules.
rapumaBase = os.path.dirname(os.path.dirname(sys.argv[0]))
rapumaHome = [d for d in [os.path.join(rapumaBase, 'share', 'rapuma'), 
                        os.path.join(rapumaBase)] if os.path.exists(d)]
rapumaHome = rapumaHome[0] if len(rapumaHome) else None
os.environ['RAPUMA_BASE'] = rapumaHome
# According to the base if found, insert the lib folder into the Python sys path
if rapumaHome :
    sys.path.insert(0, os.path.join(rapumaHome, 'lib'))
# Set the user environment path. This is always in the same place.
userHome = os.path.expanduser(os.path.join('~', '.config', 'rapuma'))
os.environ['RAPUMA_USER'] = userHome

# Set the (potential) project home by looking for the project config file.
def find_project_root(tag, path=os.path.curdir):
    path=os.path.splitdrive(os.path.realpath(os.path.expanduser(os.path.expandvars(path))))[1]
    while (not os.path.exists(os.path.join(path, tag))):
        path = os.path.dirname(path)
        if path == os.path.sep: return None
    return path

# Find the project home
# FIXME: Though we find the home here, it really doesn't mean anything.
# It is not used here in this main script. As noted above, this code
# block should be moved into a seperate module and called by others.
projHome = find_project_root(os.path.join('Config', 'project.conf'))
# If not found, assume that this is a new project situation
if not projHome :
    projHome = os.getcwd()

os.environ['RAPUMA_PROJ'] = projHome

###########################################################################
########################## Location Discovery #############################
###########################################################################

# Load standard Python modules
import codecs, argparse

# Load the local classes
from rapuma.core.proj_local             import ProjLocal
from rapuma.core.proj_log               import ProjLog
from rapuma.core.user_config            import UserConfig
from rapuma.core.proj_data              import ProjData, Template
from rapuma.core.proj_binding           import ProjBinding
from rapuma.core.proj_compare           import ProjCompare
from rapuma.core.proj_process           import ProjProcess
from rapuma.core.tools                  import Tools
from rapuma.project.proj_config         import Config
from rapuma.project.proj_setup          import ProjSetup, ProjDelete
from rapuma.project.proj_commander      import ProjCommander
from rapuma.project.proj_font           import ProjFont
from rapuma.project.proj_hyphenation    import ProjHyphenation
from rapuma.project.proj_maps           import ProjMaps
from rapuma.project.proj_toc            import ProjToc
from rapuma.project.proj_background     import ProjBackground
from rapuma.manager.project             import Project

# Instantiate User config class
uc              = UserConfig()
tools           = Tools()

# Set some global vars
systemName      = 'Rapuma (Rapid Publication Manager)'
systemAbout     = 'Rapuma is a publishing management system written by the friendly \
                    developers at Payap University\'s Linguistics Institute (Text Unit). \
                    Rapuma stands for Rapid Publication Manager. It is currently being \
                    deployed in MSEAG and is under heavy development. Anyone wanting to \
                    try this system should be warned that it may not work in their context. \
                    However, the underlying principals of the system should work in any long \
                    document publishing environment. Therefore the package should be evaluated \
                    with that in mind. We welcome input and participation in this project. It \
                    is our hope it will be able to serve more than just MSEAG. For questions \
                    or more information please write: dennis_drescher@sil.org.'
systemVersion   = '0.6.r820'
local           = None

# Give a welcome message
tools.terminal('\n\t\tWelcome to ' + systemName)
tools.terminal('\n\t\t\tVersion ' + systemVersion + '\n')

###########################################################################
########################### Rapuma Functions ##############################
###########################################################################

def checkCreatorVersion (pid, projectConfig, systemVersion) :
    '''Keep track of the version of Rapuma used in the current project.'''

    if not projectConfig['ProjectInfo'].has_key('projectCreatorVersion') :
        projectConfig['ProjectInfo']['projectCreatorVersion'] = systemVersion
        tools.writeConfFile(projectConfig)

    if projectConfig['ProjectInfo']['projectCreatorVersion'] != systemVersion :
        projectConfig['ProjectInfo']['projectCreatorVersion'] = systemVersion
        tools.writeConfFile(projectConfig)
        # Now update the scripts if that is needed
        ProjCommander(pid).updateScripts()


def trimLog () :
    '''Trim a log file.  This will take an existing log file and
    trim it to the amount specified in the system file.'''

    # Of course this isn't needed if there isn't even a log file
    if local and os.path.isfile(local.projLogFile) :

        limit = int(uc.userConfig['System']['projLogLineLimit'])

        # Read in the existing log file
        readObject = codecs.open(local.projLogFile, "r", encoding='utf_8')
        lines = readObject.readlines()
        readObject.close()

        # Process only if we have enough lines
        if len(lines) > limit :
            writeObject = codecs.open(local.projLogFile, "w", encoding='utf_8')
            lineCount = 0
            for line in lines :
                if limit > lineCount :
                    writeObject.write(line)
                    lineCount +=1

            writeObject.close()


###############################################################################
########################### Rapuma Command Center #############################
###############################################################################

# All command options must contain a project ID (-i). That is required. If one
# is not listed then the incoming command is either considered malformed or
# incomplete. If there is a way to figure out what the user might be needing
# the help system will be called. Otherwise, Rapuma will quite.

# The argument handler
def userArguments (args) :
    '''Process incoming command arguments.'''

#    import pdb; pdb.set_trace()

    # Common error handlers
    def cmdError (cmd, cmdType) :
        sys.exit('\nERROR: The ' + cmd + ' command is not valid to use with ' + cmdType + '. Process halting.\n')

    def cTypeError (cType) :
        sys.exit('\nERROR: The ' + cType + ' component type is not recognized. Process halting.\n')

    # Pre-command process: Extra help access
    if sys.argv[1].lower() == 'help' :
        if args.about :
            tools.terminal('\n' + systemName + ' version ' + systemVersion + '\n')
            tools.terminal('About: ' + systemAbout + '\n')
            return

    ##### SYSTEM
    # Pre-command process: System level commands
    # FIXME: I think this section can be simplified, not sure how yet
    if sys.argv[1].lower() == 'system' :
        cmdType     = args.command_type
        cmd         = args.command
        setting     = args.setting
        if cmdType == 'setup' :
            # Single call for folders
            if cmd == 'folders' :
                if uc.makeHomeFolders() :
                    tools.terminal('Updated Rapuma user folders.')
                    return
                else :
                    sys.exit('\nERROR: Could not update Rapuma user folders. Use force (-f) to override current settings. Process halting.\n')
            # Look for settings
            if not setting :
                sys.exit('\nERROR: No setting was given. Process halting.\n')
            # Path checking
            if cmd in ['cloud', 'project'] :
                if not os.path.exists(tools.resolvePath(setting)) :
                    sys.exit('\nERROR: Path given is not valid. Process halting.\n')
                else :
                    path = tools.resolvePath(setting)
            if cmd == 'name' :
                uc.setSystemSettings('System', 'userName', setting)
            elif cmd == 'uid' :
                uc.setSystemSettings('System', 'userID', setting)
            elif cmd == 'project' :
                uc.setSystemSettings('Resources', 'projects', path)
            elif cmd == 'cloud' :
                uc.setSystemSettings('Resources', 'cloud', path)
            else :
                sys.exit('\nERROR: Command not supported. Process halting.\n')

    ###### EXAMPLE
    # Run example scripts
    elif sys.argv[1].lower() == 'example' :
        if args.script :
            os.system(os.path.join(rapumaHome, 'resource/example/example-' + args.script.lower() + '.sh'))

    # Test for valid project ID if this is anything else than a project call
    elif sys.argv[1].lower() != 'project' :
        if not uc.userConfig.has_key('Projects') or not uc.userConfig['Projects'].has_key(args.project_id) :
            sys.exit('\nERROR: Project ID [' + args.project_id + '] not found in system configuration. Process halting.\n')
        # Update the creator version if necessary
        pid         = args.project_id
        local       = ProjLocal(pid)
        pc          = Config(pid)
        pc.getProjectConfig()
        checkCreatorVersion(pid, pc.projectConfig, systemVersion)

    # Command processing
    # Dummy place holder for 'system' which as actually processed above
    if sys.argv[1].lower() == 'system' :
        pass

    ##### PROJECT
    # Project level commands
    elif sys.argv[1].lower() == 'project' :
        pid         = args.project_id
        cmdType     = args.command_type
        cmd         = args.command
        sourcePath  = ''
        targetPath  = ''
        # Source path is optional but if given, resolve it
        if args.source_path :
            sourcePath = tools.resolvePath(args.source_path)
            if not os.path.exists(sourcePath) :
                sys.exit('\nERROR: Sourct path is not valid [' + sourcePath + ']. Process halting.\n')
        # Target path is optional also but if given, resolve it
        if args.target_path :
            targetPath = tools.resolvePath(args.target_path)
            if not os.path.exists(targetPath) :
                sys.exit('\nERROR: Target path is not valid [' + targetPath + ']. Process halting.\n')
        # Figure out what manage command this is and do it
        if cmd == 'add' :
            if cmdType == 'project' :
                if not args.media_type in ['book'] :
                    sys.exit('\nERROR: Media type given: [' + args.media_type + '] is not valid. Process halting.\n')
                if not args.name :
                    sys.exit('\nERROR: Must provide a descriptive name (-n) for this new project. Process halting.\n')
                nProjPath = os.path.join(targetPath, pid)
                ProjSetup(pid).newProject(nProjPath, args.media_type, args.name, systemVersion, '')
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'bind' :
            if cmdType == 'project' :
                ProjBinding(pid).bind()
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'remove' :
            if cmdType == 'project' :
                ProjDelete(pid).deleteProject()
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'restore' :
            if cmdType == 'archive' :
                ProjData(pid).restoreArchive(targetPath, sourcePath)
            elif cmdType == 'backup' :
                if not sourcePath and uc.userConfig['Projects'].has_key(pid) :
                    ProjData(pid).restoreLocalBackup(args.bak_num)
                else :
                    if sourcePath :
                        ProjData(pid).restoreExternalBackup(sourcePath, targetPath)
                    else :
                        sys.exit('\nERROR: To restore this backup, a path must be provided with -t. Process halting.\n')
            elif cmdType == 'cloud' :
                ProjData(pid).pullFromCloud(args.force, targetPath)
            elif cmdType == 'template' :
                Template(pid).templateToProject(targetPath, sourcePath)
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'save' :
            if cmdType == 'archive' :
                ProjData(pid).archiveProject()
            elif cmdType == 'backup' :
                ProjData(pid).backupProject(targetPath)
            elif cmdType == 'cloud' :
                ProjData(pid).pushToCloud(args.force)
            elif cmdType == 'template' :
                Template(pid).projectToTemplate(args.id)
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'update' :
            if cmdType == 'group' :
                ProjSetup(pid).updateAllGroups(args.force)
            elif cmdType == 'helper' :
                ProjCommander(pid).updateScripts()
            else :
                 cmdError(cmd, cmdType)

    ##### GROUP
    # Group level commands
    elif sys.argv[1].lower() == 'group' :
        cmdType     = args.command_type
        cmd         = args.command
        pid         = args.project_id
        gid         = args.group_id
        source_path = None
        cid_list    = None
        cType       = None
        if args.component_type :
            cType = args.component_type
        else :
            try :
                pc = Config(pid)
                pc.getProjectConfig()
                cType = pc.projectConfig['Groups'][gid]['cType']
            except :
                sys.exit('\nERROR: The group [' + gid + '] could not be found in the project. Please check your project setup. Process halted!\n')
        if args.cid_list :
            if type(args.cid_list) != list :
                cid_list = args.cid_list.split()
            else :
                cid_list = args.cid_list
        # Source path is optional but if given, resolve it
        if args.source_path :
            source_path = tools.resolvePath(args.source_path)
            if not os.path.exists(source_path) :
                sys.exit('\nERROR: Path is not valid. Process halting.\n')
        # Figure out what manage command this is and do it
        if cmd == 'add' :
#            import pdb; pdb.set_trace()
            if cmdType == 'group' :
                # To add a group (other than TOC) we need to do these checks first
                if gid != 'TOC' :
                    if not cid_list :
                        sys.exit('\nERROR: Must provide a list (-i) of one or more valid component IDs when adding a group. Process halted!\n')
                    elif not cType :
                        sys.exit('\nERROR: Must provide a component type (-c) ID when adding a group. Process halted!\n')
                    elif not source_path :
                        sys.exit('\nERROR: Must provide a valid path to the source (-s) ID when adding a group. Process halted!\n')
                    elif not args.source_id :
                        sys.exit('\nERROR: Must provide a source ID (-d) ID when adding a text group. Process halted!\n')
                # Having sorted through some of the potential problems, try adding the group according to type
                if cType == 'usfm' :
                    ProjSetup(pid).addGroup(cType, gid, cid_list, args.source_id, source_path, args.force)
                elif cType == 'map' :
                    ProjMaps(pid, gid).addGroup(cid_list, args.source_id, source_path, args.force)
                elif cType == 'toc' :
                    ProjToc(pid, gid).addGroup(args.force)
            elif cmdType == 'hyphenation' :
                ProjHyphenation(pid, gid).manageHyphenation(cmd)
            elif cmdType == 'illustration' :
                sys.exit('\nERROR: Add illustrations on not completed yet')
            elif cmdType == 'preprocess' :
                prc = ProjProcess(pid)
                prc.turnOnOffPreprocess(gid, True)
                prc.checkForPreprocessScript (gid)
            else :
                cmdError(cmd, cmdType)
        elif cmd in ['draft', 'final', 'proof'] :
            if cmdType == 'group' :
                if cType == 'usfm' :
                    Project(pid, gid).renderGroup(cmd, cid_list, args.force)
                elif cType == 'map' :
                    ProjMaps(pid, gid).renderMapGroup(cmd, cid_list, args.force)
                elif cType == 'toc' :
                    ProjToc(pid, gid).renderToc(cmd, args.force)
                else :
                    cTypeError(cType)
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'lock' :
            if cmdType == 'group' :
                ProjSetup(pid).lockUnlock(gid, True)
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'remove' :
            if cmdType == 'group' :
                if cType == 'usfm' :
                    ProjSetup(pid).removeGroup(gid, args.force)
                    if tools.str2bool(uc.userConfig['System']['autoHelperScripts']) :
                        ProjCommander(pid).removeScripts()
                elif cType == 'map' :
                    ProjMaps(pid, gid).removeGroup(args.force)
                elif cType == 'toc' :
                    ProjToc(pid, gid).removeGroup(args.force)
                else :
                    cTypeError(cType)
            elif cmdType == 'hyphenation' :
                ProjHyphenation(pid, gid).manageHyphenation(cmd)
            elif cmdType == 'illustration' :
                sys.exit('\nERROR: Add illustrations off not completed yet')
            elif cmdType == 'preprocess' :
                ProjSetup(pid).turnOnOffPreprocess(gid, False)
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'update' :
            if cmdType == 'group' :
                if cType == 'usfm' :
                    # This assumes that if a source path was given in this context
                    # the user only wants to update the source path.
                    if source_path :
                        ProjSetup(pid).addCompGroupSourcePath(gid, source_path)
                    else :
                        ProjSetup(pid).updateGroup(gid, cid_list, args.force)
                elif cType == 'map' :
                    ProjMaps(pid, gid).updateGroup(cid_list, args.force)
                elif cType == 'toc' :
                    ProjToc(pid, gid).updateToc(args.force)
                else :
                    cTypeError(cType)
            elif cmdType == 'hyphenation' :
                ProjHyphenation(pid, gid).manageHyphenation(cmd, args.force)
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'unlock' :
            if cmdType == 'group' :
                ProjSetup(pid).lockUnlock(gid, False)
            else :
                cmdError(cmd, cmdType)

    ##### COMPONENT
    # Component level commands
    elif sys.argv[1].lower() == 'component' :
        cmd         = args.command
        pid         = args.project_id
        gid         = args.group_id
        cid         = args.component_id
        if args.compare_type :
            compareType = args.compare_type
        if cmd == 'add' :
            ProjComponent(pid, gid).addComponent(cid)
        elif cmd == 'compare' :
            ProjCompare(pid).compareComponent(gid, cid.lower(), compareType)
        elif cmd == 'edit' :
            ProjComponent(pid, gid).editComponent(cid)
        elif cmd == 'remove' :
            ProjComponent(pid, gid).removeComponent(cid)
        elif cmd == 'update' :
            ProjComponent(pid, gid).updateComponent(cid)

    ##### PACKAGES
    # Package management commands
    elif sys.argv[1].lower() == 'package' :
        cmdType     = args.package_type
        cmd         = args.command
        pid         = args.project_id
        gid         = args.group_id
        pkid        = args.package_id
        force       = args.force
        if cmd == 'add' :
            if cmdType == 'font' :
                ProjFont(pid, gid).installFont(pkid, force)
            elif cmdType == 'macro' :
                Config(pid, gid).addMacPack(pkid, force)
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'primary' :
            if cmdType == 'font' :
                ProjFont(pid, gid).setPrimaryFont(pkid, force)
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'remove' :
            if cmdType == 'font' :
                ProjFont(pid, gid).removeFontPack(pkid, force)
            elif cmdType == 'macro' :
                Config(pid, gid).removeMacPack(pkid, force)
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'update' :
            if cmdType == 'font' :
                ProjFont(pid, gid).updateFontPack(pkid)
            elif cmdType == 'macro' :
                Config(pid, gid).updateMacPack(pkid)
            else :
                cmdError(cmd, cmdType)

    ##### PROCESS
    # Processing commands
    elif sys.argv[1].lower() == 'process' :

# FIXME:
        sys.exit('\nERROR: Sorry process handling is quite broken right now. Process halted!\n')

        cmdType     = args.package_type
        cmd         = args.command
        pid         = args.project_id
        gid         = args.group_id
        force       = args.force
        script      = args.script
        path        = ''
        if args.path and tools.resolvePath(args.path) :
            path = tools.resolvePath(args.path)
        if cmd == 'add' :
            if cmdType in ['export', 'preprocess', 'postprocess'] :
                ProjProcess(pid).addProcess(script, path, force)
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'remove' :
            pass
        elif cmd == 'update' :
            pass

    ##### SETTINGS
    # Setting manipulation commands
    elif sys.argv[1].lower() == 'settings' :
        pid         = args.project_id
#        gid         = args.group_id
        config      = args.configuration
        section     = args.section
        key         = args.key
        value       = args.value
        if args.configuration :
            if (section or key or value) :
                ProjSetup(pid).changeConfigSetting(config, section, key, value)
            else :
                sys.exit('\nERROR: Must provide a section, key and value. Process halted!\n')
        else :
            sys.exit('\nERROR: Configuration name is missing from command argument. Process halted!\n')

    ##### BACKGROUND
    # Commands for setting the page background
    elif sys.argv[1].lower() == 'background' :
        cmdType     = args.output_type
        cmd         = args.command
        pid         = args.project_id
        bgrd        = args.background
        if cmd == 'add' :
            ProjBackground(pid).addBackground(cmdType, bgrd)
        elif cmd == 'remove' :
            ProjBackground(pid).removeBackground(cmdType, bgrd)
        elif cmd == 'update' :
            ProjBackground(pid).updateBackground(cmdType, bgrd)

    # Totally lost
    else:
        sys.exit('\nERROR: Command not recognized: [' + sys.argv[1] + ']\n')

    # Look for an error log file and notify the user if one is found that there
    # were errors in the process. This might have failed because we loose our 
    # project object some times. For now, we'll put a 'try' around it.
    if sys.argv[1].lower() == 'project' :
        try :
            if os.path.isfile(local.projErrorLogFile) :
                tools.terminal('\n\t*** ERRORS OCCURRED. PLEASE CHECK ERROR LOG ***\n')
        except :
            pass

    # Do some project log maintenance
    trimLog()

###############################################################################
############################### Argparser Setup ###############################
###############################################################################

# The following is applied to certain inputs to garentee input to be Unicode
# and not ascii or whatever the default file system encoding is.
# (Note: See the settings section for an example.)
fsunicode = partial(unicode, encoding=sys.getfilesystemencoding())

# We will try to maintain a common syntax in all the subparsers Some common
# argument options are:
#   -a = add something
#   -r = remove something
#   -e = execute something
#   -f = force the execution of something
#   -p = path (and file name) of something

# Setup the arg parser
parser = argparse.ArgumentParser(description=systemName)
subparsers = parser.add_subparsers(help='sub-command help')

# Add help subprocess arguments
helpCommand = subparsers.add_parser('help', help='General system help')

# Available choices
# System
syCommandTypes          = ['setup']
syCommands              = ['name', 'uid', 'projects', 'cloud', 'folders']
# Project
prCommandTypes          = ['archive', 'backup', 'cloud', 'group', 'helper', 'project', 'template']
prCommands              = ['add', 'bind', 'remove', 'restore', 'save', 'update']
mediaTypes              = ['book']
# Group
grCommandTypes          = ['export', 'group', 'hyphenation', 'illustration', 'postprocess', 'preprocess']
grCommands              = ['add', 'draft', 'final', 'lock', 'proof', 'remove', 'run', 'update', 'unlock']
componentTypes          = ['usfm', 'map', 'toc']
# Component
cpCommands              = ['add', 'compare', 'edit', 'remove', 'update']
compareTests            = ['source', 'source-working', 'working']
# Packages
pkCommandType           = ['font', 'macro']
pkCommands              = ['add', 'primary', 'remove', 'update']
# Processes
pcCommandType           = ['export', 'preprocess', 'postprocess']
pcCommands              = ['add', 'remove', 'update']
# Background
bgCommandType           = ['bind', 'draft', 'final', 'proof']
bgCommands              = ['add', 'remove', 'update']
backgrounds             = ['box', 'cropmarks', 'draft', 'final', 'lines', 'proof']
# Example
examples                = ['jas', 'jas-b', 'jas-t']

# Add main arguments (first postion options)
parser.add_argument('-a', '--about', action='store_true', help = 'Information about Rapuma')
parser.add_argument('-b', '--basic', action='store_true', help = 'Basic Rapuma help (in HTML)')

# Add project subprocess arguments
sysCommand = subparsers.add_parser('system', help='General system management commands help')
sysCommand.add_argument('command_type', choices=syCommandTypes, help='Specify the command type to be executed on the project. This is required for all project processing functions.')
sysCommand.add_argument('command', choices=syCommands, help='The setting command for managing user and system settings.')
sysCommand.add_argument('-s', '--setting', help='Proved a setting that will be applied to the user or system settings.')
sysCommand.add_argument('-f', '--force', action='store_true', help='Force an action.')

# FIXME: Restore from template will not work. The pid is the new project name but we
# currently do not have any means to specify the template. The same will be true for
# backups, we may need to add a "resource_id" arg to be able to ID them.

# Add Project subprocess arguments
projCommand = subparsers.add_parser('project', help='General project management commands help')
projCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
projCommand.add_argument('command_type', choices=prCommandTypes, help='Specify the command type to be executed on the project. This is required for all project processing functions.')
projCommand.add_argument('command', choices=prCommands, help='The general commands that can be used for managing a project.')
projCommand.add_argument('-s', '--source_path', help='An alternate path to a resouce to be used to start a new project such as an archive, template or backup. This is needed if the resource is not found in the normal specified Rapuma user resources.')
projCommand.add_argument('-t', '--target_path', help='Path to the project home folder or where you want a backup, templates or archive placed. Do not provide the name of the item you are working with, just the path to where you want it to be.')
projCommand.add_argument('-e', '--media_type', choices=mediaTypes, help='If creating a new project, give a valid project media type code.')
projCommand.add_argument('-n', '--name', help='If creating a new project, give a human readable name to describe this project.')
projCommand.add_argument('-f', '--force', action='store_true', help='Force an action.')
projCommand.add_argument('-b', '--bak_num', help='Specify the number (version) of backup you want to restore.')
projCommand.add_argument('-i', '--id', help='Specify an ID for an opperation.')

# Add Group subprocess arguments
groupCommand = subparsers.add_parser('group', help='General project group management commands help')
groupCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
groupCommand.add_argument('group_id', help='A unique ID for this group.')
groupCommand.add_argument('command_type', choices=grCommandTypes, help='Specify the command type to be executed on the group. This is required for all group processing functions.')
groupCommand.add_argument('command', choices=grCommands, help='The general commands that can be used for managing groups.')
groupCommand.add_argument('-c', '--component_type', choices=componentTypes, help='The group component type is needed for creating a new group.')
groupCommand.add_argument('-s', '--source_path', help='Provide a valid path to where the component source files are found for this group. (Used for adding/updating components, one source path per component group allowed.)')
groupCommand.add_argument('-d', '--source_id', help='Specify an ID to associate with the source (required).')
groupCommand.add_argument('-i', '--cid_list', help='Specify components used in this group by their recognized ID. A group can have one or more components. The list must be enclosed by quotes and have only a space between ID codes, e.g. \"aaa bbb ccc\". If the CID is for a map component, use the file name (please do not use any spaces in the file name).')
groupCommand.add_argument('-f', '--force', action='store_true', help='Force an action to override a group lock.')

# Add Component subprocess arguments
compCommand = subparsers.add_parser('component', help='General project component management commands help')
compCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
compCommand.add_argument('group_id', help='The group ID this component is a part of.')
compCommand.add_argument('component_id', help='The component ID, required any actions to be done to it.')
compCommand.add_argument('command', choices=cpCommands, help='The general commands that can be used for managing components.')
compCommand.add_argument('-c', '--compare_type', choices=compareTests, help='Compare a component with another version. This parameter must be followed by the type of test to use. Use either "working" or "source". No other test types will be accepted.')

# Add Package management subprocess arguments
packCommand = subparsers.add_parser('package', help='General package handling commands help')
packCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
packCommand.add_argument('group_id', help='The group ID this package is a part of.')
packCommand.add_argument('package_id', help='The package name ID. The ID given has to be a valid system package.')
packCommand.add_argument('package_type', choices=pkCommandType, help='The package type. The type given has to be a valid system package type.')
packCommand.add_argument('command', choices=pkCommands, help='The general commands that can be used for managing groups.')
packCommand.add_argument('-f', '--force', action='store_true', help='Force the addition, update or removal of a package from the system even if it is used by other components.')

# Add Processing subprocess arguments
processCommand = subparsers.add_parser('process', help='General settings for managing processes. Actual execution of the processes is done through the group commands')
processCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
processCommand.add_argument('group_id', help='A unique ID for this group.')
processCommand.add_argument('process_type', choices=pcCommandType, help='The type of process being managed. The type given has to be a valid system package type.')
processCommand.add_argument('command', choices=pcCommands, help='The general commands that can be used for managing groups.')
processCommand.add_argument('-p', '--path', help='A valid path and file name of a specific post process script to be installed.')
processCommand.add_argument('-s', '--script', help='Specify a script for executing. This is required for postprocesses.')
processCommand.add_argument('-f', '--force', action='store_true', help='Force the addition, update or removal of a package from the system even if it is used by other components.')

# Add Settings subprocess arguments
settingsCommand = subparsers.add_parser('settings', help='General settings handling commands help')
settingsCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
#settingsCommand.add_argument('group_id', help='A unique ID for this group.')
settingsCommand.add_argument('configuration', help='The configuration set that the target setting is from.')
settingsCommand.add_argument('section', help='The section path to the key/value pare to be changed. Multiple sections are separated by \'/\'.')
settingsCommand.add_argument('key', help='The key which has the value to be changed.')
settingsCommand.add_argument('value', type=fsunicode, help='A new value to add or change to the specified key.')

# Add page background subprocess arguments
backgroundCommand = subparsers.add_parser('background', help='Commands for managing page backgrounds such as watermarks, lines, etc.')
backgroundCommand.add_argument('project_id', help='A project ID for the project you wish to archive, backup or make template from. If a project is being made from a template, the project ID must not conflict with any others on the system.')
backgroundCommand.add_argument('output_type', choices=bgCommandType, help='The type of (rendered) output a background will be applied to or removed from.')
backgroundCommand.add_argument('background', choices=backgrounds, default='none', help='The type of background to be applied or removed from the output.')
backgroundCommand.add_argument('command', choices=bgCommands, help='The general commands that can be used for managing backgound.')

# Add example subprocess arguments
exampleCommand = subparsers.add_parser('example', help='Commands for running example scripts.')
exampleCommand.add_argument('-s', '--script', choices=examples, help='Specify an example script for executing.')

# Send the collected arguments to the handler
userArguments(parser.parse_args())


###############################################################################
########################### Close out the session #############################
###############################################################################

# In case there are any Canadians using this, politely say good bye
timeTotal = round(timeit.default_timer() - startTime, 2)
tools.terminal('\n\t\tTotal process time: ' + str(datetime.timedelta(seconds = timeTotal)).split('.')[0] + '\n')
tools.terminal('\t\tThank you, please come again!\n')













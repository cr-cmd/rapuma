#!/usr/bin/python
# -*- coding: utf-8 -*-

# By Dennis Drescher (dennis_drescher at sil.org


###############################################################################
######################### Description/Documentation ###########################
###############################################################################

# One script to rule them all.  This is the main Rapuma engine script.
# This script will drive all processes and keep track of what happens in the
# project log in each respective project.


###############################################################################
################################ Initialize Rapuma ###############################
###############################################################################
# Firstly, import all the standard Python modules we need for this process and
# set the base path

import os, sys, timeit, datetime
from functools          import partial

startTime = timeit.default_timer()

# Set the Rapuma base program paths
rapumaHome = os.environ.get('RAPUMA_BASE')
sysHome = os.environ.get('HOME')
if not rapumaHome :
    for t in (os.path.join(sysHome, '.local'), '/usr/local', '/usr') :
        rapumaHome = os.path.join(t, 'share', 'rapuma')
        if os.path.exists(os.path.join(rapumaHome, 'resources')) :
            os.environ['RAPUMA_BASE'] = rapumaHome
            break

# Set the user environment path
userHome = os.environ.get('RAPUMA_USER')
if not userHome :
    userHome = os.path.join(sysHome, '.config', 'rapuma')
    os.environ['RAPUMA_USER'] = userHome

# Set the (potential) project home
projHome = os.getcwd()

# Load standard Python modules
import codecs, argparse
#from datetime import *
#from configobj import ConfigObj

# Load the local classes
from rapuma.core.proj_local         import ProjLocal
from rapuma.core.proj_log           import ProjLog
from rapuma.core.user_config        import UserConfig
from rapuma.core.proj_config        import ProjConfig
from rapuma.core.proj_setup         import ProjSetup
from rapuma.core.proj_backup        import ProjBackup
from rapuma.core.proj_binding       import Binding
from rapuma.core.proj_compare       import Compare
from rapuma.core.page_background    import PageBackground
from rapuma.project.project         import Project
from rapuma.project.proj_commander  import Commander
from rapuma.project.proj_maps       import Maps
from rapuma.core.tools              import Tools, ToolsGroup

# Instantiate User config class
uc              = UserConfig()
tools           = Tools()

# Set some global vars
systemName      = 'Rapuma (Rapid Publication Manager)'
systemAbout     = 'Rapuma is a publishing management system written by the friendly developers at Payap University\'s Linguistics Institute (Text Unit). Rapuma stands for Rapid Publication Manager. It is currently being deployed in MSEAG and is under heavy development. Anyone wanting to try this system should be warned that it may not work in their context. However, the underlying principals of the system should work in any long document publishing environment. Therefore the package should be evaluated with that in mind. We welcome input and participation in this project. It is our hope it will be able to serve more than just MSEAG. For questions or more information please write: dennis_drescher@sil.org.'
systemVersion   = '0.1.20130516a'
local           = None

# Give a welcome message
tools.terminal('\n\t\tWelcome to ' + systemName)
tools.terminal('\n\t\t\tVersion ' + systemVersion + '\n')

###########################################################################
########################### Rapuma Functions ##############################
###########################################################################

def checkCreatorVersion (pid, projConfig, systemVersion) :
    '''Keep track of the version of Rapuma used in the current project.'''

    if not tools.testForSetting(projConfig, 'ProjectInfo', 'projectCreatorVersion') :
        projConfig['ProjectInfo']['projectCreatorVersion'] = systemVersion
        tools.writeConfFile(projConfig)

    if projConfig['ProjectInfo']['projectCreatorVersion'] != systemVersion :
        projConfig['ProjectInfo']['projectCreatorVersion'] = systemVersion
        tools.writeConfFile(projConfig)
        # Now update the scripts if that is needed
        Commander(pid).updateScripts()


def hasValidSourcePath (pid, gid, csid) :
    '''Check if there is one, see if it is valid.'''

#    import pdb; pdb.set_trace()

    try :
        path = uc.userConfig['Projects'][pid][csid + '_sourcePath']
        return os.path.isdir(tools.resolvePath(path))
    except :
        return False


def isTemplate (tid) :
    '''Check to see if a template exsists in the user's template store area.'''

    try :
        templates = uc.userConfig['Resources']['templates']
        if tid + '.zip' in os.listdir(templates) :
            return True
    except :
        return False


def initProject (pid, gid) :
    '''Initialize an existing project according to the project ID given.'''

    global local
    local       = ProjLocal(pid)
    pc          = ProjConfig(local)
    log         = ProjLog(pid)
    aProject    = Project(pid, gid)
    return aProject


def trimLog () :
    '''Trim a log file.  This will take an existing log file and
    trim it to the amount specified in the system file.'''

    # Of course this isn't needed if there isn't even a log file
    if local and os.path.isfile(local.projLogFile) :

        limit = int(uc.userConfig['System']['projLogLineLimit'])

        # Read in the existing log file
        readObject = codecs.open(local.projLogFile, "r", encoding='utf_8')
        lines = readObject.readlines()
        readObject.close()

        # Process only if we have enough lines
        if len(lines) > limit :
            writeObject = codecs.open(local.projLogFile, "w", encoding='utf_8')
            lineCount = 0
            for line in lines :
                if limit > lineCount :
                    writeObject.write(line)
                    lineCount +=1

            writeObject.close()


###############################################################################
########################### Rapuma Command Center #############################
###############################################################################

# All command options must contain a project ID (-i). That is required. If one
# is not listed then the incoming command is either considered malformed or
# incomplete. If there is a way to figure out what the user might be needing
# the help system will be called. Otherwise, Rapuma will quite.

# The argument handler
def userArguments (args) :
    '''Process incoming command arguments.'''

    # Common error handlers
    def cmdError (cmd, cmdType) :
        sys.exit('\nERROR: The ' + cmd + ' command is not valid to use with ' + cmdType + '. Process halting.\n')

    def cTypeError (cType) :
        sys.exit('\nERROR: The ' + cType + ' component type is not recognized. Process halting.\n')

    # Pre-command process: Extra help access
    if sys.argv[1].lower() == 'help' :
        if args.about :
            tools.terminal('\n' + systemName + ' version ' + systemVersion + '\n')
            tools.terminal('About: ' + systemAbout + '\n')
            return

    # Pre-command process: System level commands
    if sys.argv[1].lower() == 'system' :
        if args.user_name :
            uc.setSystemSettings('userName', args.user_name)
        elif args.resources :
            uc.setSystemSettings('resources', args.resources)
    # Test for valid project ID if this is anything else than a project call
    elif sys.argv[1].lower() != 'project' :
        if not tools.isConfSection(uc.userConfig['Projects'], args.project_id) :
            sys.exit('\nERROR: Project ID is not valid. Process halting.\n')
        # Update the creator version if necessary
        pid         = args.project_id
        local       = ProjLocal(pid)
        pc          = ProjConfig(local)
        checkCreatorVersion(pid, pc.projConfig, systemVersion)


    # Command processing
    # Dummy place holder for 'system' which as actually processed above
    if sys.argv[1].lower() == 'system' :
        pass

    # Project level commands
    elif sys.argv[1].lower() == 'project' :
        pid         = args.project_id
        cmdType     = args.command_type
        cmd         = args.command
        # Source path is optional but if given, resolve it
        if args.source_path :
            sourcePath = tools.resolvePath(args.source_path)
            if not os.path.exists(sourcePath) :
                sys.exit('\nERROR: Path is not valid. Process halting.\n')
        # Target path is optional also but if given, resolve it
        if args.target_path :
            targetPath = tools.resolvePath(args.target_path)
            if not os.path.exists(targetPath) :
                sys.exit('\nERROR: Path is not valid. Process halting.\n')
        # Figure out what manage command this is and do it
        if cmd == 'add' :
            if cmdType == 'project' :
                if not args.media_type in ['book'] :
                    sys.exit('\nERROR: Media type given: [' + args.media_type + '] is not valid. Process halting.\n')
                if not args.name :
                    sys.exit('\nERROR: Must provide a descriptive name (-n) for this new project. Process halting.\n')
                nProjPath = os.path.join(targetPath, pid)
                ProjSetup(pid).newProject(nProjPath, args.media_type, args.name, systemVersion, '')
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'bind' :
            if cmdType == 'project' :
                Binding(pid).bind()
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'remove' :
            if cmdType == 'project' :
                ProjSetup(pid).deleteProject()
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'restore' :
            if cmdType == 'archive' :
                ProjBackup(pid).restoreArchive(targetPath, sourcePath)
            elif cmdType == 'backup' :
                if tools.isConfSection(uc.userConfig['Projects'], pid) :
                    ProjBackup(pid).restoreBackup()
                else :
                    if args.target_path :
                        ProjBackup(pid).restoreBackup(os.path.join(targetPath))
                    else :
                        sys.exit('\nERROR: To restore this backup, a path must be provided with -t. Process halting.\n')
            elif cmdType == 'cloud' :
                if tools.isConfSection(uc.userConfig['Projects'], pid) :
                    ProjBackup(pid).pullFromCloud()
                else :
                    if args.target_path :
                        if os.path.exists(tools.resolvePath(args.target_path)) :
                            ProjBackup(pid).pullFromCloud(os.path.join(tools.resolvePath(args.target_path), pid))
                        else :
                            sys.exit('\nERROR: Path is not valid. Process halting.\n')
                    else :
                        sys.exit('\nERROR: To get rain from this cloud, a target path must be provided with -t. Process halting.\n')
            elif cmdType == 'template' :
                ProjBackup(pid).templateToProject(args.name)
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'save' :
            if cmdType == 'archive' :
                ProjBackup(pid).archiveProject()
            elif cmdType == 'backup' :
                ProjBackup(pid).backupProject()
            elif cmdType == 'cloud' :
                ProjBackup(pid).pushToCloud()
            elif cmdType == 'template' :
                if isTemplate(args.template) :
                    sys.exit('\nError: This template [' + args.template + '] already exsists. Process halted.\n')
                ProjBackup(pid).projectToTemplate(args.template)
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'update' :
            if cmdType == 'helper' :
                Commander(pid).updateScripts()
            else :
                 cmdError(cmd, cmdType)

    # Group level commands
    elif sys.argv[1].lower() == 'group' :
        cmdType     = args.command_type
        cmd         = args.command
        pid         = args.project_id
        gid         = args.group_id
        cid_list    = None
        cType       = None
        if args.component_type :
            cType = args.component_type
        else :
            cType = initProject(pid, gid).projConfig['Groups'][gid]['cType']
        if args.cid_list :
            if type(args.cid_list) != list :
                cid_list = args.cid_list.split()
            else :
                cid_list = args.cid_list
        # Figure out what manage command this is and do it
        if cmd == 'add' :
#            import pdb; pdb.set_trace()
            if cmdType == 'group' :
                # To add a group we need to do these checks first
                if not cid_list :
                    sys.exit('\nERROR: Must provide a list (-i) of one or more valid component IDs when adding a group. Process halted!\n')
                elif not cType :
                    sys.exit('\nERROR: Must provide a component type (-c) ID when adding a group. Process halted!\n')
                elif args.source_path :
                    if not tools.resolvePath(args.source_path) :
                        sys.exit('\nERROR: Must provide a valid path to the source (-s) ID when adding a group. Process halted!\n')
                elif not args.source_id :
                    sys.exit('\nERROR: Must provide a source ID (-d) ID when adding a text group. Process halted!\n')
                # Having sorted through some of the potential problems, try adding the group according to type
                if cType == 'usfm' :
                    ProjSetup(pid).addGroup(cType, gid, cid_list, args.source_id, tools.resolvePath(args.source_path), args.force)
                elif cType == 'map' :
                    Maps(pid).addGroup(gid, cid_list, args.source_id, tools.resolvePath(args.source_path), args.force)
            elif cmdType == 'hyphenation' :
                initProject(pid, gid).manageHyphenation(cmd)
            elif cmdType == 'illustration' :
                sys.exit('\nERROR: Add illustrations on not completed yet')
            elif cmdType == 'preprocess' :
                ps = ProjSetup(pid)
                ps.turnOnOffPreprocess(gid, True)
                ps.checkForPreprocessScript (gid)
            else :
                cmdError(cmd, cmdType)
        elif cmd in ['draft', 'final', 'proof'] :
            if cmdType == 'group' :
                if cType == 'usfm' :
                    initProject(pid, gid).renderGroup(cmd, cid_list, args.force)
                elif cType == 'map' :
                    Maps(pid).renderMapGroup(gid, cmd, cid_list, args.force)
                else :
                    cTypeError(cType)
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'lock' :
            if cmdType == 'group' :
                if cType == 'usfm' :
                    ProjSetup(pid).lockUnlock(gid, True)
                elif cType == 'map' :
                    Maps(pid).lockUnlock(gid, True)
                else :
                    cTypeError(cType)
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'remove' :
            if cmdType == 'group' :
                if cType == 'usfm' :
                    ProjSetup(pid).removeGroup(gid, args.force)
                    if tools.str2bool(uc.userConfig['System']['autoHelperScripts']) :
                        Commander(pid).removeScripts()
                elif cType == 'map' :
                    Maps(pid).removeGroup(gid, args.force)
                else :
                    cTypeError(cType)
            elif cmdType == 'hyphenation' :
                initProject(pid, gid).manageHyphenation(cmd)
            elif cmdType == 'illustration' :
                sys.exit('\nERROR: Add illustrations off not completed yet')
            elif cmdType == 'preprocess' :
                ProjSetup(pid).turnOnOffPreprocess(gid, False)
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'update' :
            if cmdType == 'group' :
                if cType == 'usfm' :
                    if args.source_id :
                        if not hasValidSourcePath(pid, gid, args.source_id) :
                            sys.exit('\nERROR: Not valid: [' + args.source_path + ']. Must provide a valid path to the source (-s) ID when adding a group. Process halted!\n')
                    ProjSetup(pid).updateGroup(gid, cid_list, args.source_path, args.force)
                elif cType == 'map' :
                    Maps(pid).updateGroup(gid, cid_list, args.source_path, args.force)
                else :
                    cTypeError(cType)
            elif cmdType == 'hyphenation' :
                initProject(pid, gid).manageHyphenation(cmd, args.force)
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'unlock' :
            if cmdType == 'group' :
                ProjSetup(pid).lockUnlock(gid, False)
            else :
                cmdError(cmd, cmdType)

    # Component level commands
    elif sys.argv[1].lower() == 'component' :
        aProject = initProject(args.project_id, args.group_id)
        # Render vs. view command is just a matter of forcing the component
        # to be rendered if render is selected by the user. Otherwise, if
        # only view is requested, if force is set to False and the component
        # will not be rerendered if it already exsists.
        if args.compare :
            Compare(args.project_id).compareComponent(args.group_id, args.component_id.lower(), args.compare)
        # Commands for editing project files
        elif args.edit :
                aProject.edit(args.component_id)

    # Font level commands
    elif sys.argv[1].lower() == 'font' :
        aProject = initProject(args.project_id, args.group_id)
        aProject.createManager('font')
        font = aProject.managers[args.component_type + '_Font'].checkForSubFont(args.font_id)
        manager = args.component_type + '_Font'
        if not args.component_type :
            sys.exit('\nERROR: Component type ID is missing from command argument. Process halted!\n')
        if args.manage == 'add' :
            # Physically install the font files
            aProject.managers[manager].installFont(font, args.force)
        elif args.manage == 'remove' :
            aProject.managers[manager].removeFont(args.component_type, font, args.force)
        elif args.manage == 'primary' :
            aProject.managers[manager].setPrimaryFont(args.component_type.capitalize(), font, args.force)

    # Post processing commands
    elif sys.argv[1].lower() == 'postprocess' :
        # Run a post process command on a component or component type
        # Because we can lock at all levels, there is no need for (-f --force)
        # to be used here. If a component name is given it will only run on that
        # component which includes all listed sub-components. Otherwise, all 
        # components of the specified type will be acted on by the postprocess.
        if args.manage == 'execute' :
            if not args.script :
                sys.exit('\nERROR: No script was specified, Please use -s to specify a script to execute.\n')
            elif not args.component_name.lower() :
                sys.exit('\nERROR: No component ID was specified, Please use -c to specify a valid component (group) ID to run this post process script on.\n')
            else :
                ProjSetup(args.project_id).runProcessScript(args.component_name.lower(), args.script)
        # Install a custom or a default post process script, force to overwrite what is there
        elif args.manage == 'add' :
            filePath = ''
            if args.path :
                filePath = tools.resolvePath(args.path)
                if not os.path.isfile(filePath) :
                    sys.exit('\nERROR: The following path does not appear to be valid: ' + filePath + '\n')
            ProjSetup(args.project_id).installPostProcess(args.component_type, filePath, args.force)
        # Disconnect a post process script from the component type (This does not
        # physically remove it unless -f is used.)
        elif args.manage == 'remove' :
            ProjSetup(args.project_id).removePostProcess(args.component_type, force)

    # Setting manipulation commands
    elif sys.argv[1].lower() == 'settings' :
        if args.configuration :
            if (args.section or args.key or args.value) :
                ProjSetup(args.project_id).changeConfigSetting(args.configuration, args.section, args.key, args.value)
            else :
                sys.exit('\nERROR: Must provide a section, key and value. Process halted!\n')
        else :
            sys.exit('\nERROR: Configuration name is missing from command argument. Process halted!\n')

    # Commands for setting the page background
    elif sys.argv[1].lower() == 'background' :
        if args.manage == 'add' :
            PageBackground(args.project_id).checkForBackground(args.background_type + 'Watermark', args.background_type, args.force)
        elif args.manage == 'remove' :
            PageBackground(args.project_id).removeBackground(args.background_type)
        elif args.background_type == 'none' :
            PageBackground(args.project_id).backgroundOff()

    # Totally lost
    else:
        sys.exit('\nERROR: Command not recognized: [' + sys.argv[1] + ']\n')

    # Look for an error log file and notify the user if one is found that there
    # were errors in the process. This might have failed because we loose our 
    # project object some times. For now, we'll put a 'try' around it.
    if not sys.argv[1].lower() == 'project' :
        if local and os.path.isfile(local.projErrorLogFile) :
            tools.terminal('\n\t*** ERRORS OCCURRED. PLEASE CHECK ERROR LOG ***\n')

    # Do some project log maintenance
    trimLog()

###############################################################################
############################### Argparser Setup ###############################
###############################################################################

# The following is applied to certain inputs to garentee input to be Unicode
# and not ascii or whatever the default file system encoding is.
# (Note: See the settings section for an example.)
fsunicode = partial(unicode, encoding=sys.getfilesystemencoding())

# We will try to maintain a common syntax in all the subparsers Some common
# argument options are:
#   -a = add something
#   -r = remove something
#   -e = execute something
#   -f = force the execution of something
#   -p = path (and file name) of something

# Setup the arg parser
parser = argparse.ArgumentParser(description=systemName)
subparsers = parser.add_subparsers(help='sub-command help')

# Add help subprocess arguments
helpCommand = subparsers.add_parser('help', help='General system help')

# Available choices
# Project
pCommandTypes           = ['archive', 'backup', 'cloud', 'helper', 'project', 'template']
pCommands               = ['add', 'bind', 'remove', 'restore', 'save', 'update']
mediaTypes              = ['book']
# Group
gCommandTypes           = ['group', 'hyphenation', 'illustration', 'preprocess']
gCommands               = ['add', 'draft', 'proof', 'final', 'lock', 'remove', 'update', 'unlock']
componentTypes          = ['usfm', 'map']
# Other
backgrounds             = ['draft', 'proof', 'final', 'lines', 'box']
backgroundCommands      = ['add', 'remove']
compareTests            = ['source', 'source-working', 'working']
postprocessCommands     = ['add', 'remove', 'process']
fontCommands            = ['add', 'remove', 'primary']

# Add main arguments (first postion options)
parser.add_argument('-a', '--about', action='store_true', help = 'Information about Rapuma')
parser.add_argument('-b', '--basic', action='store_true', help = 'Basic Rapuma help (in HTML)')

# Add project subprocess arguments
sysCommand = subparsers.add_parser('system', help='General system management commands help')
sysCommand.add_argument('-n', '--user_name', help='Proved a name of the user who will be using this system.')
sysCommand.add_argument('-r', '--resources', help='Proved a valid path to where the user resources, such as backups, archives, etc., will be located.')

# FIXME: Restore from template will not work. The pid is the new project name but we
# currently do not have any means to specify the template. The same will be true for
# backups, we may need to add a "resource_id" arg to be able to ID them.

# Add Project subprocess arguments
projCommand = subparsers.add_parser('project', help='General project management commands help')
projCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
projCommand.add_argument('command_type', choices=pCommandTypes, help='Specify the command type to be executed on the project. This is required for all project processing functions.')
projCommand.add_argument('command', choices=pCommands, help='The general commands that can be used for managing a project.')
projCommand.add_argument('-s', '--source_path', help='An alternate path to a resouce to be used to start a new project such as an archive, template or backup. This is needed if the resource is not found in the normal specified Rapuma user resources.')
projCommand.add_argument('-t', '--target_path', help='Path to the project home folder. This can be used for specifying the location of new projects based on templates, archives or just a standard new project. Do not provide the name of the project folder, just the path to where you want it to be.')
projCommand.add_argument('-e', '--media_type', choices=mediaTypes, help='If creating a new project, give a valid project media type code.')
projCommand.add_argument('-n', '--name', help='If creating a new project, give a human readable name to describe this project.')

# Add Group subprocess arguments
groupCommand = subparsers.add_parser('group', help='General project group management commands help')
groupCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
groupCommand.add_argument('group_id', help='A unique ID for this group.')
groupCommand.add_argument('command_type', choices=gCommandTypes, help='Specify the command type to be executed on the group. This is required for all group processing functions.')
groupCommand.add_argument('command', choices=gCommands, help='The general commands that can be used for managing groups.')
groupCommand.add_argument('-f', '--force', action='store_true', help='Force an action to override a group lock.')
groupCommand.add_argument('-c', '--component_type', choices=componentTypes, help='The group component type is needed for creating a new group.')
groupCommand.add_argument('-s', '--source_path', help='Provide a valid path to where the component source files are found for this group. (Used for adding/updating components, one source path per component group allowed.)')
groupCommand.add_argument('-d', '--source_id', help='Specify an ID to associate with the source (required).')
groupCommand.add_argument('-i', '--cid_list', help='Specify components used in this group by their recognized ID. A group can have one or more components. The list must be enclosed by quotes and have only a space between ID codes, e.g. \"aaa bbb ccc\". If the CID is for a map component, use the file name (please do not use any spaces in the file name).')

# Add Component subprocess arguments
compCommand = subparsers.add_parser('component', help='General project component management commands help')
compCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
compCommand.add_argument('group_id', help='The group ID this component is a part of.')
compCommand.add_argument('component_id', help='The component ID, required any actions to be done to it.')
compCommand.add_argument('-c', '--compare', choices=compareTests, help='Compare a component with another version. This parameter must be followed by the type of test to use. Use either "working" or "source". No other test types will be accepted.')
compCommand.add_argument('-d', '--edit', action='store_true', help='Edit a specific component from a specified group.')

# Add Font subprocess arguments
fontCommand = subparsers.add_parser('font', help='General font handling commands help')
fontCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
fontCommand.add_argument('group_id', help='The group ID this font is a part of.')
fontCommand.add_argument('component_type', help='Specify the component type. This is required for all font functions.')
fontCommand.add_argument('font_id', help='The font family name ID. The ID given has to be a valid system font.')
fontCommand.add_argument('-m', '--manage', choices=fontCommands, help='The general commands that can be used for managing fonts.')
fontCommand.add_argument('-f', '--force', action='store_true', help='Force the addition or removal of a font from the system even if it is used by other components.')

# Add text Postprocessing subprocess arguments
postprocessCommand = subparsers.add_parser('postprocess', help='General settings for handling component post processing commands.')
postprocessCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
postprocessCommand.add_argument('group_id', help='A unique ID for this group.')
postprocessCommand.add_argument('-m', '--manage', choices=postprocessCommands, help='The general commands that can be used for managing postprocesses.')
postprocessCommand.add_argument('-f', '--force', action='store_true', help='Force a post process script to be updated, replaced or brought back to default condition for this component type.')
postprocessCommand.add_argument('-i', '--cid_list', help='If desired, list components to have a post process run on them. The list must be enclosed by quotes and have only a space between ID codes, e.g. \"aaa bbb ccc\".')
postprocessCommand.add_argument('-p', '--path', help='A valid path and file name of a specific post process script to be installed.')
postprocessCommand.add_argument('-s', '--script', help='Specify a script for executing. This is required for the -e command.')

# Add Settings subprocess arguments
settingsCommand = subparsers.add_parser('settings', help='General settings handling commands help')
settingsCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
settingsCommand.add_argument('configuration', help='The configuration set that the target setting is from.')
settingsCommand.add_argument('section', help='The section path to the key/value pare to be changed. Multiple sections are separated by \'/\'.')
settingsCommand.add_argument('key', help='The key which has the value to be changed.')
settingsCommand.add_argument('value', type=fsunicode, help='A new value to add or change to the specified key.')

# FIXME: Need to add Export management

# FIXME: Need to add Macro management

# Add page background subprocess arguments
backgroundCommand = subparsers.add_parser('background', help='Commands for managing page backgrounds such as watermarks, lines, etc.')
backgroundCommand.add_argument('project_id', help='A project ID for the project you wish to archive, backup or make template from. If a project is being made from a template, the project ID must not conflict with any others on the system.')
backgroundCommand.add_argument('background_type', choices=backgrounds, default='none', help='The type of background to be applied or removed from the output.')
backgroundCommand.add_argument('-m', '--manage', choices=backgroundCommands, help='The general commands that can be used for managing backgound.')
backgroundCommand.add_argument('-f', '--force', action='store_true', help='Force overwrite on exsisting background file.')

# Send the collected arguments to the handler
userArguments(parser.parse_args())


###############################################################################
########################### Close out the session #############################
###############################################################################

# In case there are any Canadians using this, politely say good bye
timeTotal = round(timeit.default_timer() - startTime, 2)
tools.terminal('\n\t\tTotal process time: ' + str(datetime.timedelta(seconds = timeTotal)).split('.')[0] + '\n')
tools.terminal('\t\tThank you, please come again!\n')













#!/usr/bin/python
# -*- coding: utf-8 -*-
#
#    By Dennis Drescher (sparkycbr at gmail dot com)

#    Copyright 2016, SIL International
#    All rights reserved.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#  
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#  
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#    MA 02110-1301, USA or see <http://www.gnu.org/licenses/>.


###############################################################################
######################### Description/Documentation ###########################
###############################################################################

# This is the main Command Line Interface (CLI) script. All Rapuma functionality
# should be accessable by this script.


###############################################################################
############################### Initialize Rapuma #############################
###############################################################################
# Firstly, import all the standard Python modules we need for this process and
# set the base path

import os, sys, timeit, datetime
from functools import partial

startTime = timeit.default_timer()

###############################################################################
############################ Location Discovery ###############################
###############################################################################

# Set the Rapuma base program paths. It looks in /usr/share first for an
# installed copy. If you give it a actual path to the development version
# it will run from there. (E.g. ~/Projects/rapuma/scripts/rapuma)

# FIXME: Environment variables are set that may not be needed if this block
# of code was turned into a module and called from the dependent modules.
# E.g., if rapuma is called from /usr/bin/rapuma then rapumaBase = /usr
# If from ~/Projects/rapuma/scripts/rapuma then rapumaBase = ~/Projects/rapuma

rapumaBase = os.path.dirname(os.path.dirname(os.path.abspath(sys.argv[0])))
rapumaHome = [d for d in [os.path.join(rapumaBase, 'share', 'rapuma'), 
                        os.path.join(rapumaBase)] if os.path.exists(d)]
rapumaHome = rapumaHome[0] if len(rapumaHome) else None
os.environ['RAPUMA_BASE'] = rapumaHome
# According to the base if found, insert the lib folder into the Python sys path
if rapumaHome :
    sys.path.insert(0, os.path.join(rapumaHome, 'lib'))

# Set the user environment path. This is always in the same place
# First figure out if this is a web or desktop installation
desktopConf     = os.path.expanduser(os.path.join('~', '.config', 'rapuma'))
desktopProj     = os.path.expanduser(os.path.join('~', 'Publishing'))
serverConf      = os.path.join('/var', 'www', 'rapuma', 'config')
serverProj      = os.path.join('/var', 'www', 'rapuma', 'publishing')
if os.path.isdir(desktopConf) :
    os.environ['RAPUMA_USER'] = desktopConf
    os.environ['RAPUMA_PROJECTS'] = desktopProj
    installType = 'desktop'
elif os.path.isdir(serverConf) :
    os.environ['RAPUMA_USER'] = serverConf
    os.environ['RAPUMA_PROJECTS'] = serverProj
    installType = 'server'
else :
    sys.exit('\nERROR: No user configuration folder found. Rapuma setup is not complete. Please see installation documentation for more information.\n')

# Set the (potential) project home by looking for the project config file.
def find_project_root(tag, path=os.path.curdir):
    path=os.path.splitdrive(os.path.realpath(os.path.expanduser(os.path.expandvars(path))))[1]
    while (not os.path.exists(os.path.join(path, tag))):
        path = os.path.dirname(path)
        if path == os.path.sep: return None
    return path

# Find the project home
# FIXME: Though we find the home here, it really doesn't mean anything.
# It is not used here in this main script. As noted above, this code
# block should be moved into a seperate module and called by others.
projHome = find_project_root(os.path.join('Config', 'project.conf'))
# If not found, assume that this is a new project situation
if not projHome :
    projHome = os.getcwd()

os.environ['RAPUMA_PROJ'] = projHome

###############################################################################
######################## Import Modules and Classes ###########################
###############################################################################

# Load standard Python modules
import codecs, argparse
from configobj                          import ConfigObj

# Load the local classes
from rapuma.core.proj_local             import ProjLocal
from rapuma.core.proj_log               import ProjLog
from rapuma.core.user_config            import UserConfig
from rapuma.core.proj_data              import ProjData, Template
from rapuma.core.proj_binding           import ProjBinding
from rapuma.core.proj_compare           import ProjCompare
from rapuma.core.tools                  import Tools
from rapuma.project.proj_config         import Config
from rapuma.project.proj_macro          import Macro
from rapuma.project.proj_setup          import ProjSetup, ProjDelete
from rapuma.project.proj_commander      import ProjCommander
from rapuma.project.proj_font           import ProjFont
from rapuma.project.proj_background     import ProjBackground
from rapuma.project.proj_hyphenation    import ProjHyphenation
from rapuma.project.proj_illustration   import ProjIllustration
from rapuma.project.proj_script         import ProjScript
from rapuma.project.proj_diagnose       import ProjDiagnose
from rapuma.manager.project             import Project
from rapuma.group.usfm_data             import UsfmData


#import pdb; pdb.set_trace()


# Grab some system info
sysConfig                               = ConfigObj(os.path.join(rapumaHome, 'config', 'system.ini'), encoding='utf-8')
# Instantiate User config class
uc                                      = UserConfig()
tools                                   = Tools()

# Adjust the project folder path. Here we look for an alternate
# path if one has been put into the user config.
# First set the path to the default
projDir = os.path.expanduser(os.environ['RAPUMA_PROJECTS'])
# Now look for an alternate path and set it if it is valid
altDir = os.path.expanduser(uc.userConfig['System']['projects'])
if altDir :
    if os.path.exists(altDir) :
        projDir = altDir
        os.environ['RAPUMA_PROJECTS'] = altDir
    else :
        sys.exit('\nERROR: An alternate project path was set but does not seem valid: ' + altDir + '\nPlease check the path set for [projects] in the Rapuma user config file. \nProcess halting.\n')

# Get a list of projects
if projDir and os.path.exists(projDir) :
    projList = tools.getProjIdList(projDir)
else :
    if not projDir :
        projDir = '<null>'
    sys.exit('\nERROR: The projects folder path is missing or not valid: ' + projDir + '\nIt maybe necessary to change the configuration and reinstall Rapuma. \nProcess halting.\n')

# Set some global vars
systemName                              = sysConfig['Rapuma']['systemName']
systemAbout                             = sysConfig['Rapuma']['systemAbout']
systemVersion                           = sysConfig['Rapuma']['systemVersion']
local                                   = None


###############################################################################
################################ Rapuma CLI ###################################
###############################################################################

# Give a welcome message
tools.terminal('\n\t\tWelcome to ' + systemName)
tools.terminal('\n\t\t\tVersion ' + systemVersion + ' - (' + installType + ')\n')

###############################################################################
########################### Rapuma CLI Functions ##############################
###############################################################################


def trimLog (local) :
    '''Trim a log file.  This will take an existing log file and
    trim it to the amount specified in the system file.'''

#    import pdb; pdb.set_trace()
    
    # Of course this isn't needed if there isn't even a log file
    if os.path.exists(local.projLogFile) :

        limit = int(uc.userConfig['System']['projLogLineLimit'])

        # Read in the existing log file
        readObject = codecs.open(local.projLogFile, "r", encoding='utf_8')
        lines = readObject.readlines()
        readObject.close()

        # Process only if we have enough lines
        if len(lines) > limit :
            writeObject = codecs.open(local.projLogFile, "w", encoding='utf_8')
            lineCount = 0
            for line in lines :
                if limit > lineCount :
                    writeObject.write(line)
                    lineCount +=1

            writeObject.close()


def crossCheckSourceList (pid, cType, cidList, sourceList) :
    '''Double check that all the files in a source list are valid.'''

#    import pdb; pdb.set_trace()

    checkList = list(cidList)
    for f in sourceList :
        if cType == 'usfm' :
            if not os.path.exists(f) :
                tools.terminal('\nERROR: Path/file is not valid. [' + f + ']\n')
            else :
                cid = tools.discoverCIDFromFile(f).lower()
                if cid in checkList :
                    checkList.remove(cid)
        else :
            # In this "other" case we assume the file name (less
            # extention) is the cid
            fileName = tools.fName(f)
            cid = fileName.split('.')[0]
            if not os.path.exists(f) :
                tools.terminal('\nERROR: Path/file is not valid. [' + f + ']\n')
            else :
                if cid in checkList :
                    checkList.remove(ProjSetup(sysConfig, pid).getCidFromPdfFileName(tools.fName(f)))
    # If anything is left in the check list, we failed
    if len(checkList) == 0 :
        return True
    else :
        tools.terminal('\nERROR: Unable to find the source for component ID(s): [' + str(checkList) + ']\n')


def makeSourceList (cType, cidList, path) :
    '''Create a source list for a given set of CIDs.'''

    usfmExt     = ['USFM', 'usfm', 'SFM', 'sfm']
    sourceList  = []

    # Create the source_list by type
    if cType == 'usfm' :
        for filename in os.listdir(path) :
            # Check only valid file types (by ext)
            if os.path.splitext(filename)[1][1:].lower() in usfmExt :
                cid = tools.discoverCIDFromFile(os.path.join(path, filename))
                if cid.lower() in cidList : 
                    sourceList.append(os.path.join(path, filename))
    elif cType == 'pdf' :
        for filename in cidList :
            sourceList.append(os.path.join(path, filename + '.pdf'))

    if not len(sourceList) > 0 :
        sys.exit('\nERROR: Failed to create the much needed source list for this process. Process halting.\n')
    else :
        return sourceList


def setupOutputBackgroundFeatures (pid, background, diagnostic, docInfo) :
    '''Set all the features the user wants for the background.'''

    if background and diagnostic :
        sys.exit('\nERROR: Cannot have background (--background/-b) and diagnostic (--diagnostic/-d) turned on at the same time. Process halting.\n')
    elif background and docInfo :
        # Turn on background and Doc info
        ProjBackground(pid).turnOnBackground()
        ProjBackground(pid).turnOnDocInfo()
    elif background :
        # Turn on background only
        ProjBackground(pid).turnOnBackground()
        ProjBackground(pid).turnOffDocInfo()
        ProjDiagnose(pid).turnOffDiagnostic()
    elif docInfo :
        # Turn on doc info on only
        ProjBackground(pid).turnOnDocInfo()
        ProjDiagnose(pid).turnOffDiagnostic()
        ProjBackground(pid).turnOffBackground()
    elif diagnostic :
        # Turn on diagnostic only
        ProjDiagnose(pid).turnOnDiagnostic()
        ProjBackground(pid).turnOffBackground()
        ProjBackground(pid).turnOffDocInfo()


def resetOutputBackgroundFeatures (pid) :
    '''Turn all the background features off (reset).'''

    ProjDiagnose(pid).turnOffDiagnostic()
    ProjBackground(pid).turnOffDocInfo()
    ProjBackground(pid).turnOffBackground()


def validateLocalPid (pid) :
    '''Validate the PID against the local project list, return it if it is good.'''
    if pid in projList :
        return pid


def validatePid (pid, path = None) :
    '''Do a validation/existance check on a PID. Return the PID if it is
    a local installed project or found in the given path. Kill the process
    if it is not.'''

    # When the user wants to update a system conf file a PID is not necessary.
    # This will allow the process to bypass the need for a PID. Instead the user
    # will need to use a key word, in this case, 'system'.
    if pid.lower() == 'system' :
        return pid.upper()

    results = ''
    # When a path is given we check that first
    if path :
        if os.path.isfile(os.path.join(validatePath(path), pid, 'Config', 'project.conf')) :
            results = pid
    else :
        if pid in projList :
            results = pid
    if results :
        return pid
    else :
        # Error message is a little long here but gives a clue as to
        # where the system is looking for the project config file
        sys.exit('\n Sorry, Project ID [' + pid + '] does not appear to be valid. Cannot find project configuration file at: ' + os.path.join(validatePath(path), pid, 'Config') + ' Process halting.\n')


def validatePath (path) :
    '''Return a resolved path if it is good, kill the process if not.'''

    realPath = tools.resolvePath(path)
    if os.path.exists(realPath) :
        return realPath
    else :
        sys.exit('\nERROR: Sorry but the path you provided does not seem to be valid: [' + path + ']. Process halting.\n')


###############################################################################
########################### Rapuma Command Center #############################
###############################################################################

# All command options must contain a project ID (-i). That is required. If one
# is not listed then the incoming command is either considered malformed or
# incomplete. If there is a way to figure out what the user might be needing
# the help system will be called. Otherwise, Rapuma will quit.

# The argument handler
def userArguments (args) :
    '''Process incoming command arguments.'''

#    import pdb; pdb.set_trace()

    # Set some vars
    local = None
    pid = ''
    
    # Common error handlers
    def cmdError (cmd, cmdType) :
        sys.exit('\nERROR: The ' + cmd + ' command is not valid to use with ' + cmdType + '. Process halting.\n')

    def cTypeError (cType) :
        sys.exit('\nERROR: The ' + cType + ' component type is not recognized. Process halting.\n')

    # Pre-command process: Extra help access
    if sys.argv[1].lower() == 'help' :
        if args.about :
            tools.terminal('\n' + systemName + ' version ' + systemVersion + '\n')
            tools.terminal('About: ' + systemAbout + '\n')
            return

    ##### PUBLICATION
    # Project level commands
    elif sys.argv[1].lower() == 'publication' :
        cmd         = args.command
        sub         = args.sub_command
        mediaType   = None
        if args.media_type :
            mediaType = args.media_type
        else :
            # The default is book
            mediaType = 'book'
        # Figure out what area this command relates to and do it
        if cmd == 'archive' :
            tools.terminal('\nCreat an archive of the current project. This will overwrite any previous achive made.\n')
            sys.exit('\n Unfortunately, the ' + cmd + ' command has not been implemented yet. Process halting.\n')
        elif cmd == 'backup' :
            tools.terminal('\nCreate a backup of the project. (Multiple backups can be stored.) \n')
            sys.exit('\n Unfortunately, the ' + cmd + ' command has not been implemented yet. Process halting.\n')
        # Create or remove a project
        elif cmd == 'project' :
            if sub == 'create' :
                ProjSetup(sysConfig, args.project_id).newProject(mediaType)
            elif sub == 'remove' :
                ProjDelete().deleteProject(args.project_id)
            else :
                sys.exit('\nERROR: Sorry, the ' + sub + ' command is not supported in the ' + cmd + ' context. Process halting.\n')
        # Push or pull a project to or from the cloud
        elif cmd == 'share' :
            # Sort out source and target depending on push or pull
            if sub == 'pull' :
                # Pull in a shared project from local cloud (Dropbox/Google Drive/etc)
                pid = validatePid(args.project_id, args.path)
                source = os.path.join(args.path, pid)
                target = os.path.join(projDir, pid)
            elif sub == 'push' :
                # Push a new shared project to your local cloud (Dropbox/Google Drive/etc)
                pid = validatePid(args.project_id)
                path = validatePath(args.path)
                source = os.path.join(projDir, pid)
                target = os.path.join(path, pid)
            else :
                sys.exit('\nERROR: Sorry, the ' + sub + ' command is not supported in the ' + cmd + ' context. Process halting.\n')
            # Now that we have sorted out source and target we can get on with the work
            if args.replace :
                ProjData(pid).replaceProject(source, target)
            else :
                ProjData(pid).mergeProjects(source, target)

    ##### CONTENT
    # Project level commands
    elif sys.argv[1].lower() == 'content' :
        usfmData    = UsfmData()
        pid         = validatePid(args.project_id)
        gid         = args.group_id
        cmd         = args.command
        sub         = args.sub_command
        cType       = args.comp_type
        fType       = args.file_type
        cid_list    = []            # A list of one or more cids
        source_list = []            # Gen: A list of files w/paths
        path        = ''
        # Test the GID for use in component or group level commands
        if cmd == 'component' or cmd == 'group' :
            if not ProjSetup(sysConfig, pid, gid).isGroup(gid) :
                if not sub == 'add' :
                    sys.exit('\nERROR: Group ID [' + path + '] is not valid. Process halting.\n')
        # For some processes we need to have the cType
        if not cType :
            cType = ProjSetup(sysConfig, pid, gid).returnConfigValue('project', 'Groups/' + gid, 'cType')
        # Check source path if there is one
        if args.path :
            path = os.path.abspath(args.path)
            if not os.path.isdir(path) :
                sys.exit('\nERROR: Path is not valid. [' + path + '] Process halting.\n')
        # These are recognized CID groups names for generating CID list
        # if no CIDs are provided. To expand this list there must be
        # a corresponding function in UsfmData that will retrieve the
        # correct CIDs in the correct order.
        canonGroups = ['OT', 'NT', 'BIBLE']
        # If the user provided any CIDs, we preprocess them here
        if args.cid_list :
            # Load this now because we'll need it
            cids        = []
            if type(args.cid_list) != list :
                cids    = args.cid_list.split()
            else :
                cids    = args.cid_list
            cid_list = cids
        else :
            # Otherwise we will see if we are adding using a shortcut
            if sub == 'add' or sub == 'update' :
                if gid in canonGroups :
                    getCidList = getattr(usfmData, gid.lower() + 'CidList')
                    cid_list = getCidList()
        # The cType is required for a number of operations, check for it here
        if cmd == 'group' or cmd == 'component' :
            if not cType :
                sys.exit('\nERROR: A component type (--comp_type/-c) was not given for this opperation. Due to poor programing, this is needed to complete this operation. Rapuma apologizes for this inconvenience. Process halting. Please try again by adding this parameter and it should work fine.\n')                
            
        # The source_list will be auto-generated and is required at
        # the engine level for processing. We need both a source_path
        # and a CID list to make it. This will take them as it finds
        # them but the completed list needs to be varified
        if cmd == 'component' and (sub == 'add' or sub == 'update') :
            if not path or not cid_list :
                sys.exit('\nERROR: Missing a parameter (CIDs or path) for this process. Process halting.\n')
            source_list = makeSourceList(cType, cid_list, path)
        elif cmd == 'component' and sub == 'remove' :
            source_list = cid_list

        # Before we go on, quickly varify existance of all files in the
        # list and cross-check with the CID list
        if source_list and (sub == 'add' or sub == 'update') :
            if not crossCheckSourceList(pid, cType, cid_list, source_list) :
                sys.exit('\nERROR: Source list cross-check failed. Process halting.\n')

        # Figure out what area this command relates to and do it
        if cmd == 'group' :
            if sub == 'add' :
                # Add a group (no components)
                ProjSetup(sysConfig, pid, gid).addGroup(cType, gid)
            elif sub == 'remove' :
                # Remove a group (all of it)
                ProjSetup(sysConfig, pid, gid).removeGroup(gid)
                # Clean up the helper scripts too
                if tools.str2bool(uc.userConfig['System']['autoHelperScripts']) :
                    ProjCommander(pid).removeScripts()
            else :
                sys.exit('\nERROR: Sorry, the ' + sub + ' command is not supported in the ' + cmd + ' context. Process halting.\n')
        # Work with components
        elif cmd == 'component' :
            if sub == 'add' :
                # Add one or more components in a group (will not overwrite)
                ProjSetup(sysConfig, pid, gid).addComponent(gid, source_list)
            elif sub == 'compare' :
                # Compare a single component, its current version with a previous one.
                if not cid_list :
                    sys.exit('\nERROR: Must provide a Component ID for this process. Process halting.\n')
                # In case there are multiple components to be compared
                for cid in cid_list :
                    if fType :
                        # The default is to compare current with backup, this can override and
                        # compare it with the source.
                        ProjCompare(pid).compareComponent(gid, cid, fType)
                    else :
                        ProjCompare(pid).compareComponent(gid, cid)
            elif sub == 'remove' :
                # Remove one or more components from a group
                ProjSetup(sysConfig, pid, gid).removeComponents(gid, source_list)
            elif sub == 'update' :
                # Update one or more components in a group
                ProjSetup(sysConfig, pid, gid).updateComponents(gid, source_list)
            else :
                sys.exit('\nERROR: Sorry, the ' + sub + ' command is not supported in the ' + cmd + ' context. Process halting.\n')


    ##### ASSET
    # Commands for managing assets
    elif sys.argv[1].lower() == 'asset' :
        pid         = validatePid(args.project_id)
        gid         = args.group_id
        cmd         = args.command
        sub         = args.sub_command
        packageId   = args.package_id
        preprocess  = args.preprocess
        postprocess = args.postprocess
        path        = ''
        source      = ''
        cType       = ''
        # Check GID
        if cmd != 'font' and cmd != 'macro' and cmd != 'hyphenation' :
            if not ProjSetup(sysConfig, pid).isGroup(gid) :
                sys.exit('\nERROR: Group ID is not valid: [' + gid + '] Process halting.\n')
        # Path set and test for existance of file or folder
        if args.path :
            path = args.path
            if not os.path.exists(path) :
                sys.exit('\nERROR: Path is not valid: [' + path + '] Process halting.\n')
        # Check for valid cType if one was given
        if args.component_type :
            cType = args.component_type
            if not ProjSetup(sysConfig, pid).isCompType(cType) :
                sys.exit('\nERROR: Component type given is not valid: [' + cType + '] Process halting.\n')

        # Begin processing commands here
        if cmd == 'background' :
            # Update (remake) a background file
            if sub == 'update' :
                ProjBackground(pid, gid).createBackground()
        elif cmd == 'font' :
            # Test path/file if there is one
            if path and not os.path.isfile(path) :
                sys.exit('\nERROR: File name [' + tools.fName(path) + '] does not appear to be valid. Process halting.\n')
            # Add a font package to the project
            if sub == 'add' :
                ProjFont(pid).addFont(path, cType)
            # Remove a font from the project (font ID is the file name less .zip extension)
            elif sub == 'remove' :
                if ProjFont(pid).isFont(packageId) :
                    ProjFont(pid).removeFontPack(packageId)
                else :
                    sys.exit('\n Sorry to say, but the font package ID you provided ' + packageId + ' does not match any fonts in the project. I have to stop now but please come back and try again.\n')
            # Update a font in the project
            elif sub == 'update' :
                ProjFont(pid).updateFontPack(path, cType)
        elif cmd == 'hyphenation' :
            if sub == 'add' :
                ProjHyphenation(pid).addHyphenationFiles(path)
            elif sub == 'remove' :
                ProjHyphenation(pid).removeHyphenationFiles()
            elif sub == 'update' :
                ProjHyphenation(pid).updateHyphenationFiles(path)
        elif cmd == 'illustration' :
            if sub == 'add' :
                ProjIllustration(pid, gid).addIllustrationFiles(path)
            elif sub == 'remove' :
                ProjIllustration(pid, gid).removeIllustrationFiles()
            elif sub == 'update' :
                ProjIllustration(pid, gid).updateIllustrationFiles(path)
        elif cmd == 'macro' :
            # Add a macro package asset to a project component type.
            if sub == 'add' :
                Macro(pid, cType).addMacPack(path)
            # Remove a macro package asset from a component type in the project.
            elif sub == 'remove' :
                Macro(pid, cType).removeMacPack()
            # Update a macro package asset in the project.
            elif sub == 'update' :
                Macro(pid, cType).updateMacPack(path)
        # Work with processing scripts
        elif cmd == 'script' :
            # Set designator or die
            if not preprocess or postprocess :
                sys.exit('\n ERROR: Must provide script type designator (--preprocess or --postprocess). Process halting.\n')
            elif preprocess :
                scriptType = 'preprocess'
            elif postprocess :
                scriptType = 'postprocess'
            # Test path/file if there is one
            if path :
                if not os.path.isfile(path) :
                    sys.exit('\nERROR: File name [' + tools.fName(path) + '] does not appear to be valid. Process halting.\n')
            # Add a script to the project
            if sub == 'add' :
                ProjScript(pid, gid).addScriptFiles(path, scriptType)
            # Remove a script from the project
            elif sub == 'remove' :
                ProjScript(pid, gid).removeScriptFiles(scriptType)
            # Update a script in the project
            elif sub == 'update' :
                # Because we can only have one pre/post-process script in place
                # at a time, an update is actually just a remove -> add sequence
                ProjScript(pid, gid).removeScriptFiles(scriptType)
                ProjScript(pid, gid).addScriptFiles(path, scriptType)


    ##### PROCESS
    # Commands for processes performed on the project
    elif sys.argv[1].lower() == 'process' :
        pid         = validateLocalPid(args.project_id)
        gid         = args.group_id
        cmd         = args.command
        sub         = args.sub_command
        cidList     = args.cid_list
        path        = args.path
        background  = args.background
        diagnostic  = args.diagnostic
        docInfo     = args.doc_info
        save        = args.save
        pages       = args.pages
        override    = args.override
        canonGroups = ['OT', 'NT', 'BIBLE']
        cType       = ''
        # For some processes we need to have the cType
        if not cmd == 'project' :
            if not gid :
                sys.exit('\nERROR: Must provide a Group ID for this process. Process halting.\n')
            cType = ProjSetup(sysConfig, pid).returnConfigValue('project', 'Groups/' + gid, 'cType')
        # Clean up the CID list
        if cidList :
            if type(cidList) != list :
                cidList = cidList.split()
        # Test the GID for use in component or group level commands
        if cmd == 'component' or cmd == 'group' :
            if not ProjSetup(sysConfig, pid).isGroup(gid) :
                sys.exit('\nERROR: Group ID [' + path + '] is not valid. Process halting.\n')
        # Check source path if there is one
        if args.path :
            path = os.path.abspath(args.path)
            if not os.path.isdir(path) :
                sys.exit('\nERROR: Path is not valid. [' + path + '] Process halting.\n')
        # Check/Set optional override
        if args.override :
            override = args.override
            ovrdPath = os.path.split(os.path.abspath(override))[0]
            flName = os.path.split(override)[1]
            override = os.path.join(ovrdPath, flName)
            if not os.path.isdir(ovrdPath) :
                sys.exit('\nERROR: The path given [' + ovrdPath + '] given is not valid. Process halted!\n')

        # Begin processing commands here
        # Component Level Commands
        if cmd == 'component' :
            if sub == 'export' :
                tools.terminal('\nExport component(s) from the project in their current state. \n')
                sys.exit('\n Unfortunately, the ' + sub + ' command for ' + cmd + ' has not been implemented yet. Process halting.\n')
            elif sub == 'preprocess' :
                tools.terminal('\nApplies a preprocess script to a component(s) for export. \n')
                sys.exit('\n Unfortunately, the ' + sub + ' command for ' + cmd + ' has not been implemented yet. Process halting.\n')
            elif sub == 'postprocess' :
                tools.terminal('\nApplies a postprocess script to a component(s) for export. \n')
                sys.exit('\n Unfortunately, the ' + sub + ' command for ' + cmd + ' has not been implemented yet. Process halting.\n')
            elif sub == 'render' :
                # Render one or more components in a group
                if cType == 'usfm' :
                    # First we will set whatever peripheral features to what
                    # they need to be. After we will turn them off.
                    # Set the background features
                    setupOutputBackgroundFeatures(pid, background, diagnostic, docInfo)
                    # Now we will render
                    Project(pid, gid).renderGroup(cidList, pages, override, save)
                    # Just to be safe we will just turn everything off
                    resetOutputBackgroundFeatures(pid)
                elif cType == 'pdf' :
                    # Set the background features
                    setupOutputBackgroundFeatures(pid, background, None, docInfo)
                    # PDFs are already rendered so this really amounts to "glueing" them together
                    Project(pid, gid).renderGroup(cidList, pages, override, save)
                    # Just to be safe we will just turn everything off
                    resetOutputBackgroundFeatures(pid)
                else :
                    sys.exit('\nERROR: Sorry, the ' + cType + ' component type is not currently supported. Process halting.\n')
            else :
                sys.exit('\nERROR: Sorry, the ' + sub + ' command is not supported in the ' + cmd + ' context. Process halting.\n')
        # Group Level Commands
        elif cmd == 'group' :
            if sub == 'export' :
                tools.terminal('\nExport an entire group of components from the project in its current state. \n')
                sys.exit('\n Unfortunately, the ' + sub + ' command for ' + cmd + ' has not been implemented yet. Process halting.\n')
            elif sub == 'preprocess' :
                tools.terminal('\nApplies a preprocess script to an entire group of components for export. \n')
                sys.exit('\n Unfortunately, the ' + sub + ' command for ' + cmd + ' has not been implemented yet. Process halting.\n')
            elif sub == 'postprocess' :
                tools.terminal('\nApplies a postprocess script to an entire group of components for export. \n')
                sys.exit('\n Unfortunately, the ' + sub + ' command for ' + cmd + ' has not been implemented yet. Process halting.\n')
            elif sub == 'render' :
                # Render the entire group
                if cType == 'usfm' :
                    # First we will set whatever peripheral features to what
                    # they need to be. After we will turn them off.
                    # Set the background features
                    setupOutputBackgroundFeatures(pid, background, diagnostic, docInfo)
                    # Now we will render
                    Project(pid, gid).renderGroup(None, pages, override, save)
                    # Just to be safe we will just turn everything off
                    resetOutputBackgroundFeatures(pid)
                elif cType == 'pdf' :
                    # Set the background features
                    setupOutputBackgroundFeatures(pid, background, None, docInfo)
                    # Now we will render
                    Project(pid, gid).renderGroup(None, pages, override, save)
                    # Just to be safe we will just turn everything off
                    resetOutputBackgroundFeatures(pid)
                else :
                    sys.exit('\nERROR: Sorry, the ' + cType + ' component type is not currently supported. Process halting.\n')
            else :
                sys.exit('\nERROR: Sorry, the ' + sub + ' command is not supported in the ' + cmd + ' context. Process halting.\n')
        # Project Level Commands
        elif cmd == 'project' :
            if sub == 'bind' :
                # A background and doc info can be added in a bind
                # operation, but not a diagnostic layer
                if args.background and args.doc_info :
                    # Turn on background and Doc info
                    ProjBackground(pid).turnOnBackground()
                    ProjBackground(pid).turnOnDocInfo()
                    # Make sure diagnostic is off
                    ProjDiagnose(pid).turnOffDiagnostic()
                    # Bind the groups, save here is used to save the file
                    # in the Deliverables folder
                    ProjBinding(pid).bind(save)
                    # Last one out turn off the lights :-)
                    ProjBackground(pid).turnOffBackground()
                    ProjBackground(pid).turnOffDocInfo()
                elif args.background :
                    # Turn on background
                    ProjBackground(pid).turnOnBackground()
                    # Make sure doc info and diagnostic is off
                    ProjBackground(pid).turnOffDocInfo()
                    ProjDiagnose(pid).turnOffDiagnostic()
                    # Bind the groups, save here is used to save the file
                    # in the Deliverables folder
                    ProjBinding(pid).bind(save)
                    # Last one out turn off the lights :-)
                    ProjBackground(pid).turnOffBackground()
                elif args.doc_info :
                    # Turn on background
                    ProjBackground(pid).turnOnDocInfo()
                    # Make sure background and diagnostic is off
                    ProjBackground(pid).turnOffBackground
                    ProjDiagnose(pid).turnOffDiagnostic()
                    # Bind the groups, save here is used to save the file
                    # in the Deliverables folder
                    ProjBinding(pid).bind(save)
                    # Last one out turn off the lights :-)
                    ProjBackground(pid).turnOffDocInfo()
                else :
                    # Bind the groups, save here is used to save the file
                    # in the Deliverables folder
                    ProjBinding(pid).bind(save)
            else :
                sys.exit('\nERROR: Sorry, the ' + sub + ' command is not supported in the ' + cmd + ' context. Process halting.\n')


    ##### SETTING
    # Setting manipulation commands
    elif sys.argv[1].lower() == 'setting' :
        pid         = validatePid(args.project_id)
        config      = args.configuration
        section     = args.section
        key         = args.key
        value       = args.value
        if (section or key or value) :
            ProjSetup(sysConfig, pid).changeConfigSetting(config, section, key, value)
        else :
            sys.exit('\nERROR: Must provide a section, key and value. Process halted!\n')

    # Totally lost
    else:
        sys.exit('\nERROR: Command not recognized: [' + sys.argv[1] + ']\n')

    # Look for an error log file and notify the user if one is found that there
    # were errors in the process. This might have failed because we loose our 
    # project object some times. For now, we'll put a 'try' around it.
    if sys.argv[1].lower() == 'project' :
        try :
            if os.path.isfile(local.projErrorLogFile) :
                tools.terminal('\n\t*** ERRORS OCCURRED. PLEASE CHECK ERROR LOG ***\n')
        except :
            pass

    # Do some project log maintenance
    if local :
        trimLog(local)



###############################################################################
############################## Rapuma Starts Here #############################
###############################################################################

if __name__ == '__main__' :

    # The following is applied to certain inputs to garentee input to be Unicode
    # and not ascii or whatever the default file system encoding is.
    # (Note: See the settings section for an example.)
    fsunicode = partial(unicode, encoding=sys.getfilesystemencoding())

    # We will try to maintain a common syntax in all the subparsers Some common
    # argument options are:
    #   -a = add something
    #   -r = remove something
    #   -e = execute something
    #   -f = force the execution of something
    #   -p = path (and file name) of something

    # Setup the arg parser
    parser = argparse.ArgumentParser(description=systemName)
    subparsers = parser.add_subparsers(help='sub-command help')

    # Add help subprocess arguments
    helpCommand = subparsers.add_parser('help', help='General system help')

    # Available choices

    # Publication
    puCmd              = ['archive', 'backup', 'project', 'share']
    puSubCmd           = ['create', 'pull', 'push', 'remove', 'restore', 'save', 'update']
    puMediaType        = ['book']
    # Content
    ctCmd              = ['component', 'group']
    ctSubCmd           = ['add', 'compare', 'remove', 'update']
    ctCompType         = ['usfm', 'pdf']
    flType             = ['backup', 'source']
    # Asset
    asCmd              = ['background', 'font', 'hyphenation', 'illustration', 'macro', 'script']
    asSubCmd           = ['add', 'remove', 'update']
    # Processes
    pcCmd              = ['component', 'group', 'project']
    pcSubCmd           = ['bind', 'export', 'preprocess', 'postprocess', 'render']
    # Setting
    stConf             = ['adjustment', 'font', 'illustration', 'layout', 'macro', 'project', 'rapuma']

    # Add main arguments (first postion options)
    parser.add_argument('-a', '--about', action='store_true', help = 'Information about Rapuma')
    parser.add_argument('-b', '--basic', action='store_true', help = 'Basic Rapuma help (in HTML)')
    parser.add_argument('-V', '--version', action='version', version=systemVersion, help = 'Show the program version and exit, doing nothing else')

    # Add Publication subprocess arguments
    projCommand = subparsers.add_parser('publication', help='General publication management commands')
    projCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
    projCommand.add_argument('command', choices=puCmd, help='The general commands that can be used for managing a project.')
    projCommand.add_argument('sub_command', choices=puSubCmd, help='Specify the command action to be executed on the project. This is required for all project processing functions.')
    projCommand.add_argument('-m', '--media_type', choices=puMediaType, help='If creating a new project, give a valid project media type code. The default is "book".')
    projCommand.add_argument('-p', '--path', help='A local path needed for certain operations.')
    projCommand.add_argument('-r', '--replace', action='store_true', help='Force a full replacement of project data.')

    # Add Content subprocess arguments
    contentCommand = subparsers.add_parser('content', help='General project content management commands')
    contentCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
    contentCommand.add_argument('command', choices=ctCmd, help='Specify either group or component which will be acted on.')
    contentCommand.add_argument('sub_command', choices=ctSubCmd, help='Commands that can be used for managing groups and components.')
    contentCommand.add_argument('-g', '--group_id', help='A unique group ID for this command.')
    contentCommand.add_argument('-i', '--cid_list', help='Using the proper ID, specify components to be added to this group. A group can have one or more components. The list must be enclosed by quotes and have only a space between ID codes, e.g. \"aaa bbb ccc\".')
    contentCommand.add_argument('-c', '--comp_type', choices=ctCompType, help='The group component type is needed for creating a new group.')
    contentCommand.add_argument('-f', '--file_type', choices=flType, help='The file (parent) type is needed for comparing the current working component file with its parent. You can compare the current file with the last backup (default) or its source.')
    contentCommand.add_argument('-p', '--path', help='A path to were component files may be found.')

    # Add project Asset management subprocess arguments
    assetCommand = subparsers.add_parser('asset', help='General project asset handling commands')
    assetCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
    assetCommand.add_argument('command', choices=asCmd, help='The general commands that can be used for managing assets.')
    assetCommand.add_argument('sub_command', choices=asSubCmd, help='Sub commands that can be used for managing project assets.')
    assetCommand.add_argument('-g', '--group_id', help='A unique group ID for this command.')
    assetCommand.add_argument('-c', '--component_type', help='Indicate a component type for this command.')
    assetCommand.add_argument('-p', '--path', help='A path to were asset files may be found.')
    assetCommand.add_argument('-r', '--preprocess', action='store_true', help='Type designator for a preprocessing script. Required parameter for handling preprocess scripts.')
    assetCommand.add_argument('-o', '--postprocess', action='store_true', help='Type designator for a postprocessing script. Required parameter for handling preprocess scripts.')
    assetCommand.add_argument('-k', '--package_id', help='A package ID is required for managing some assets like fonts and macros')

    # Add Processing subprocess arguments
    processCommand = subparsers.add_parser('process', help='General project process commands')
    processCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
    processCommand.add_argument('command', choices=pcCmd, help='The general commands that can be used for managing project processes.')
    processCommand.add_argument('sub_command', choices=pcSubCmd, help='Sub commands that can be used for managing project processes.')
    processCommand.add_argument('-g', '--group_id', help='A unique group ID for this command.')
    processCommand.add_argument('-p', '--path', help='A path to be used in a process.')
    processCommand.add_argument('-b', '--background', action='store_true', help='Used only with the render command, this will add a background to the rendered group.')
    processCommand.add_argument('-n', '--doc_info', action='store_true', help='Used only with background when the render command is run, this will add a document information to the background layer for the rendered group.')
    processCommand.add_argument('-d', '--diagnostic', action='store_true', help='Used only with the render command, this will add a diagnostic layer to the rendered group.')
    processCommand.add_argument('-i', '--cid_list', help='Using the proper ID, specify components to be added to this group. A group can have one or more components. The list must be enclosed by quotes and have only a space between ID codes, e.g. \"aaa bbb ccc\".')
    processCommand.add_argument('-s', '--save', action='store_true', help='Save a rendered file to the Deliverable folder with a unique name.')
    processCommand.add_argument('-a', '--pages', help='Specify a page number or range of pages to render.')
    processCommand.add_argument('-o', '--override', help='A specific file name used to override normal automated output file name creation.')

    # Add Settings subprocess arguments
    settingsCommand = subparsers.add_parser('setting', help='General settings handling commands')
    settingsCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
    settingsCommand.add_argument('configuration', choices=stConf, help='The configuration set that the target setting is from.')
    settingsCommand.add_argument('-s', '--section', help='The section path to the key/value pare to be changed. Multiple sections are separated by \'/\'.')
    settingsCommand.add_argument('-k', '--key', help='The key which has the value to be changed.')
    settingsCommand.add_argument('-v', '--value', type=fsunicode, help='A new value to add or change to the specified key.')

    # Send the collected arguments to the handler
    userArguments(parser.parse_args())


    ###############################################################################
    ########################### Close out the session #############################
    ###############################################################################

    # In case there are any Canadians using this, politely say good bye
    timeTotal = round(timeit.default_timer() - startTime, 2)
    tools.terminal('\n\t\tTotal process time: ' + str(datetime.timedelta(seconds = timeTotal)).split('.')[0] + '\n')
    tools.terminal('\t\tThank you, please come again!\n')




#!/usr/bin/python
# -*- coding: utf-8 -*-
# version: 20110823
# By Dennis Drescher (dennis_drescher at sil.org


###############################################################################
######################### Description/Documentation ###########################
###############################################################################

# One script to rule them all.  This is the mother script of the whole system.
# This script will drive all processes and keep track of what happens in the
# project log in each respective project.

# History:
# 20111202 - djd - Start over with manager-centric model


###############################################################################
################################ Initialize RPM ###############################
###############################################################################
# Firstly, import all the standard Python modules we need for this process and
# set the base path

import os, sys

# Set the RPM base program path
rpmHome = os.environ.get('RPM_BASE')
if not rpmHome :
    rpmHome = os.path.join('usr', 'share', 'rpm')
    os.environ['RPM_BASE'] = rpmHome

# Set the user environment path
userHome = os.environ.get('RPM_USER')
if not userHome :
    sysHome = os.environ.get('HOME')
    userHome = os.path.join(sysHome, '.config', 'rpm')
    os.environ['RPM_USER'] = userHome

# Set the (potential) project home
projHome = os.getcwd()

# Set our paths to application resources
sys.path.insert(0, os.path.join(rpmHome, 'python_lib', 'rpm', 'core'))
sys.path.insert(0, os.path.join(rpmHome, 'python_lib', 'rpm', 'manager'))
sys.path.insert(0, os.path.join(rpmHome, 'python_lib', 'rpm', 'project'))
sys.path.insert(0, os.path.join(rpmHome, 'python_lib', 'rpm', 'component'))

# Load standard Python modules
import codecs, shutil, operator, argparse, subprocess, tarfile
from datetime import *
from configobj import ConfigObj


# Load the local classes
from proj_local import ProjLocal
from proj_log import ProjLog
from tools import *
from user_config import UserConfig
from proj_config import ProjConfig
from project import Project

# Instantiate User classes
local           = ProjLocal(rpmHome, userHome, projHome)
uc              = UserConfig(local)
log             = ProjLog(local, uc)

# Pull some info from the user config
systemName      = uc.userConfig['System']['systemName']
systemVersion   = uc.userConfig['System']['systemVersion']
systemAbout     = uc.userConfig['System']['systemAbout']

# Give a welcome message
terminal('\n\t\tWelcome to ' + systemName + '  ' + systemVersion + '\n')

###########################################################################
############################## RPM Functions ##############################
###########################################################################

def newProject (uc, pc, pid, ptype = None, pname = None) :
    '''Create a new publishing project.'''

    # Because the location of where a project is to be created could be
    # different than the cwd, we will count on pc.local to have all the
    # correct information. 
    
    # Check the ptype
    if not ptype :
        ptype = 'book'

    # Check the pname, make one up if there isn't any
    if not pname :
        pname = 'The ' + pid + ' project'

    # Run some basic tests to see if this project can be created
    # Look for project in current folder
    if not os.path.isfile(pc.local.projConfFile) :
        # Look for locked project in current folder
        if os.path.isfile(pc.local.projConfFile + pc.local.lockExt) :
            terminal('ERR: Halt! Locked project already defined in target folder')
            return
        # Look for project in parent folder (don't want project in project)
        elif os.path.isfile(os.path.join(os.path.dirname(pc.local.projHome), pc.local.projConfFileName)) :
            terminal('ERR: Halt! Live project already defined in parent folder')
            return
        # Look for locked project in parent folder (prevent project in project)
        elif os.path.isfile(os.path.join(os.path.dirname(pc.local.projHome), pc.local.projConfFileName + pc.local.lockExt)) :
            terminal('ERR: Halt! Locked project already defined in parent folder')
            return
        # Check if path to parent is valid
        elif not os.path.isdir(os.path.dirname(pc.local.projHome)) :
            terminal('ERR: Halt! Not a valid (parent) path: ' + os.path.dirname(pc.local.projHome))
            return
        # Test if this project already exists in the user's config file.
        elif uc.isRegisteredProject(pid) :
            terminal('ERR: Halt! ID [' + pid + '] already defined for another project')
            return
    else :
        terminal('ERR: Halt! A project already exsits in this location. Please remove it before continuing.')
        return

    # If we made it to this point, we need to make a new project folder
    if not os.path.exists(pc.local.projConfFolder) :
        os.makedirs(pc.local.projConfFolder)

    # Create a new version of the project config file
    pc.makeNewProjConf(pc.local, pid, ptype, pname)

    # Add project to local RPM project registry
    uc.registerProject(pid, pname, ptype, pc.local.projHome)

    # Report what we did
    terminal('Created new project [' + pid + ']')
    return True


def deleteProject (uc, pid = None) :
    '''Delete a project fromthe RPM system registry and from the hard drive.'''

    global local

    # If no pid was given this fails
    if not pid :
        terminal('Error: Project ID code not given or found. delete operation failed.')
        return

    # Check if project is registered with RPM and get real path and reinit local paths
    if not testForSetting(uc.userConfig, 'Projects', pid) :
        terminal('Error: [' + pid + '] not a valid registered project, cannot continue with delete operation.')
        return
    else :
        local = ProjLocal(rpmHome, userHome, uc.userConfig['Projects'][pid]['projectPath'])

    # Remove references from user rpm.conf
    if uc.unregisterProject(pid) :
        terminal('Removed [' + pid + '] from user configuration.')
    else :
        terminal('Failed to remove [' + pid + '] from user configuration.')

    # Delete everything in the project path
    if os.path.isdir(local.projHome) :
        shutil.rmtree(local.projHome)
        terminal('Removed project files for [' + pid + '] from hard drive.')
    else :
        terminal('Warning: [' + pid + '] project could not be found, unable to delete project files.')
        return

    # Report the process is done
    terminal('Removal process for [' + pid + '] is completed.')
    return True


def isProject (pid) :
    '''Look up in the user config to see if a project is registered.'''

    if pid in uc.userConfig['Projects'] :
        return True


def initProject (pid) :
    '''Initialize an existing project according to the project ID given.'''

    local   = ProjLocal(rpmHome, userHome, uc.userConfig['Projects'][pid]['projectPath'])
    pc      = ProjConfig(local)
    log     = ProjLog(local, uc)
    if testForSetting(pc.projConfig, 'ProjectInfo', 'projectIDCode') :
        aProject = Project(uc.userConfig, pc.projConfig, local, log)
        return aProject


def accessHtmlHelp () :
    '''Call on the RPM basic HTML help system.'''

    # Build the viewer command
    cmds = uc.userConfig['System']['htmlHelpViewerCommand']
    cmds.append(local.rpmHelpIndexFile)
    # Run the viewer command
    rCode = subprocess.call(cmds)


###############################################################################
############################# RPM Command Center ##############################
###############################################################################

# All command options must contain a project ID (-i). That is required. If one
# is not listed then the incoming command is either considered malformed or
# incomplete. If there is a way to figure out what the user might be needing
# the help system will be called. Otherwise, RPM will quite.

# The argument handler
def userArguments (args) :
    '''Process incoming command arguments.'''

    # Extra help access
    if sys.argv[1].lower() == 'help' :
        if args['about'] :
            terminal('\n' + systemName + ' version ' + systemVersion + '\n')
            terminal('About: ' + systemAbout + '\n')
            return
        if args['basic'] :
            accessHtmlHelp()
            return

    # Test project ID
    if sys.argv[1].lower() != 'project' :
        if not isProject(args['project_id']) :
            sys.exit('Error: Project ID given is not valid! Process halted.\n')
        else :
            # Now setup the project and look for and test the component type if needed
            aProject = initProject(args['project_id'])
            if sys.argv[1].lower() != 'settings' and sys.argv[1].lower() != 'locking' :
                if not aProject.isComponentType(args['component_type']) :
                    if not aProject.addComponentType(args['component_type']) :
                        sys.exit()

    # Project level commands
    if sys.argv[1].lower() == 'project' :
        # Creating a new project
        if args['add'] :
            if not args['type'] :
                sys.exit('Project type is missing from command argument. Process halted!')
            if args['path'] :
                # If a project folder is given (other than CWD) We need to
                # resolve it and pass it on to proj config settings (internal)
                customLocal = resolvePath(args['path'])
                if not os.path.isdir(customLocal) :
                    sys.exit('Cannot resolve the given path. Process halting.')
                else :
                    projFolder = os.path.join(customLocal, args['project_id'])
            else :
                # With no different project location given we will make sure
                # we use the default projHome set when the script started.
                projFolder = os.path.join(projHome, args['project_id'])
            # Create the project
            local   = ProjLocal(rpmHome, userHome, projFolder)
            pc      = ProjConfig(local)
            newProject(uc, pc, args['project_id'], args['type'].lower(), args['name'])

        # Remove an exsisting project
        elif args['remove'] :
            deleteProject(uc, args['project_id'])

    # Group level commands
    elif sys.argv[1].lower() == 'group' :
        # Add a new component group
        if args['add'] :
            if not args['list'] :
                sys.exit('Must use -l (--list) when adding a component group. Process halted!')
            else :
                aProject.addComponentGroup(args['component_type'], args['group_id'], args['list'], args['force'])
        # Delete a group component
        elif args['remove'] :
            # If -f is used, it will be passed to removeComponent() to delete 
            # every file in the group
            aProject.removeGroupComponent(args['group_id'], args['force'])
        # Render vs. view command is just a matter of forcing the component
        # to be rendered if render is selected by the user. Otherwise, if
        # only view is requested, force is set to False and the component
        # will not be rerendered if it already exsists.
        elif args['execute'] :
            aProject.renderGroup(args['group_id'], args['force'])

    # Component level commands
    elif sys.argv[1].lower() == 'component' :
        # Add a new component
        if args['add'] :
            aProject.addComponent(args['component_id'], args['component_type'], args['force'])
        # Delete a component
        elif args['remove'] :
            # If -f is used, we delete all the files with this cid
            aProject.removeComponent(args['component_id'], args['force'])
        # Render vs. view command is just a matter of forcing the component
        # to be rendered if render is selected by the user. Otherwise, if
        # only view is requested, if force is set to False and the component
        # will not be rerendered if it already exsists.
        elif args['execute'] :
            aProject.renderComponent(args['component_id'], args['force'])

    # Font level commands
    elif sys.argv[1].lower() == 'font' :
        aProject.createManager(args['component_type'], 'font')
        font = aProject.managers[args['component_type'] + '_Font'].checkForSubFont(args['font_id'])
        if args['add'] :
            # Physically install the font files
            aProject.managers[args['component_type'] + '_Font'].installFont(font, args['force'])
            # Record in the project the font meta data 
            aProject.managers[args['component_type'] + '_Font'].recordFont(args['component_type'], font, args['force'])
        elif args['remove'] :
            aProject.managers[args['component_type'] + '_Font'].removeFont(args['component_type'], font, args['force'])
        elif args['main'] :
            aProject.managers[args['component_type'] + '_Font'].setPrimaryFont(args['component_type'].capitalize(), font, args['force'])

    # Style level commands
    elif sys.argv[1].lower() == 'style' :
        aProject.createManager(args['component_type'], 'style')
        if args['add'] :
            aProject.managers[args['component_type'] + '_Style'].addStyleFile(args['path'], args['force'])
        elif args['remove'] :
            aProject.managers[args['component_type'] + '_Style'].removeStyleFile(args['force'])
        elif args['validate'] :
            aProject.managers[args['component_type'] + '_Style'].validateStyleFile(args['path'])

    # Preprocessing commands
    elif sys.argv[1].lower() == 'preprocess' :
        # Run a preprocess command on a component or component type
        # Because we can lock at all levels, there is no need for (-f --force)
        # to be used here. If a component ID is given it will only run on that
        # component. Otherwise, all components of the specified type.
        if args['execute'] :
            aProject.runPreprocess(args['component_type'], args['component_id'])
        # Install a custom or a default preprocess script, force to overwrite what is there
        elif args['add'] :
            filePath = None
            if args['path'] :
                filePath = resolvePath(args['path'])
                if not os.path.isfile(filePath) :
                    terminal('The following path does not appear to be valid: ' + filePath)
                    sys.exit()
            aProject.installPreprocess(args['component_type'], filePath, args['force'])
        # Disconnect a preprocessing script from the component type (this does not physically remove it)
        elif args['remove'] :
            aProject.removePreprocess(args['component_type'])

    # Post processing commands
    elif sys.argv[1].lower() == 'postprocess' :
        # Run a post process command on a component or component type
        # Because we can lock at all levels, there is no need for (-f --force)
        # to be used here. If a component ID is given it will only run on that
        # component. Otherwise, all components of the specified type.
        if args['execute'] :
            aProject.runPostProcess(args['component_type'], args['component_id'])
        # Install a custom or a default post process script, force to overwrite what is there
        elif args['add'] :
            filePath = None
            if args['path'] :
                filePath = resolvePath(args['path'])
                if not os.path.isfile(filePath) :
                    terminal('The following path does not appear to be valid: ' + filePath)
                    sys.exit()
            aProject.installPostProcess(args['component_type'], filePath, args['force'])
        # Disconnect a post process script from the component type (this does not physically remove it)
        elif args['remove'] :
            aProject.removePostProcess(args['component_type'])

    # Setting manipulation commands
    elif sys.argv[1].lower() == 'settings' :
        aProject = initProject(args['project_id'])
        if args['configuration'] :
            if (args['section'] or args['key'] or args['value']) :
                aProject.changeConfigSetting(args['configuration'], args['section'], args['key'], args['value'])
            else :
                sys.exit('Must provide a section, key and value. Process halted!')
        else :
            sys.exit('Configuration name is missing from command argument. Process halted!')

    # Locking commands
    elif sys.argv[1].lower() == 'locking' :
        # Lock proj/cType/cid
        if args['lock'] :
            aProject.lockUnlock(args['lock_target'], True)
        # Unlock proj/cType/cid
        elif args['unlock'] :
            aProject.lockUnlock(args['lock_target'], False)

    # Exporting commands
    elif sys.argv[1].lower() == 'export' :
        # Check further for required args
        if not args['component_id'] :
            sys.exit('Component ID is missing from command argument. Process halted!')
        # Execute an export
        if args['execute'] :
            aProject.export(args['component_type'], args['component_id'], args['path'], args['script'], args['bundle'], args['force'])

    # Totally lost
    else:
        sys.exit('Error: Command not recognized! ')

    # During a process, a number of log entries will be made and written out.
    # Over time the log file could get very large. To control the size, there
    # is a setting in the user config file that limits the number of lines in
    # the log file. The default is 1000 but it can be adjusted if needed. The
    # following call here will trim the log file to its specified limit. This
    # is done here as there should be no further operations done at this point.
    
    # Note: This will not work with "project" commands (aProject is not declaired)
    if not sys.argv[1].lower() == 'project' :
        if os.path.isfile(aProject.local.projLogFile) :
            trimLog(aProject.local.projLogFile, uc.userConfig['System']['projLogLineLimit'])


###############################################################################
############################### Argparser Setup ###############################
###############################################################################

# We will try to maintain a common syntax in all the subparsers Some common
# argument options are:
#   -a = add something
#   -r = remove something
#   -e = execute something
#   -f = force the execution of something
#   -p = path (and file name) of something

# Setup the arg parser
parser = argparse.ArgumentParser(description=systemName)
subparsers = parser.add_subparsers(help='sub-command help')

# Add help subprocess arguments
helpCommand = subparsers.add_parser('help', help='General system help')

# Add main arguments (first postion options)
parser.add_argument('-a', '--about', action='store_true', help = 'Information about RPM')
parser.add_argument('-b', '--basic', action='store_true', help = 'Basic RPM help (in HTML)')

# Add project subprocess arguments
projCommand = subparsers.add_parser('project', help='General project management commands help')
projCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
projCommand.add_argument('-a', '--add', action='store_true', help='Add a new publishing project on this system.')
projCommand.add_argument('-r', '--remove', action='store_true', help='Remove a project permanently from the system. This will do just what is says. Be careful!')
projCommand.add_argument('-p', '--path', help='Path to the project home folder if the current working directory is not the actual target. This can be used when adding a project.')
projCommand.add_argument('-t', '--type', help='If creating a new project, give a valid project type code.')
projCommand.add_argument('-n', '--name', help='If creating a new project, give a human readable name to describe this project.')
projCommand.add_argument('-b', '--bundle', help='[NOT IMPLEMENTED] Create a bundle (archive) of the entire project.')

# Add group subprocess arguments
groupCommand = subparsers.add_parser('group', help='General project component group management commands help')
groupCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
groupCommand.add_argument('component_type', help='The component type is needed for creating a new component group.')
groupCommand.add_argument('group_id', help='A specific group ID required for creating a new component group.')
groupCommand.add_argument('-a', '--add', action='store_true', help='Add a new component to this project.')
groupCommand.add_argument('-r', '--remove', action='store_true', help='Remove an existing component from this project.')
groupCommand.add_argument('-l', '--list', help='A list of components to be in this group. This must be used if adding a group. It is not needed for removal. The list must be enclosed by quotes and have only a space between ID codes, e.g. \"aaa bbb ccc\".')
groupCommand.add_argument('-f', '--force', action='store_true', help='Force an action if overriding a default non-action is needed.')
groupCommand.add_argument('-e', '--execute', action='store_true', help='Execute the render process for a component group in this project.')

# Add component subprocess arguments
compCommand = subparsers.add_parser('component', help='General project component management commands help')
compCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
compCommand.add_argument('component_type', help='The component type is needed for creating a new component.')
compCommand.add_argument('component_id', help='A specific component ID required for creating a new component.')
compCommand.add_argument('-a', '--add', action='store_true', help='Add a new component to this project.')
compCommand.add_argument('-r', '--remove', action='store_true', help='remove an existing component from this project.')
compCommand.add_argument('-f', '--force', action='store_true', help='Force an action if overriding a default non-action is needed.')
compCommand.add_argument('-e', '--execute', action='store_true', help='Execute the render process for a specific component in this project.')

# Add font subprocess arguments
fontCommand = subparsers.add_parser('font', help='General font handling commands help')
fontCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
fontCommand.add_argument('component_type', help='Specify the component type. This is required for all font functions.')
fontCommand.add_argument('font_id', help='The font family name ID. The ID given has to be a valid system font.')
fontCommand.add_argument('-a', '--add', action='store_true', help='Add a new font for a specific comonent type.')
fontCommand.add_argument('-r', '--remove', action='store_true', help='Remove the font of a specified ID from this project.')
fontCommand.add_argument('-f', '--force', action='store_true', help='Force the addition or removal of a font from the system even if it is used by other components.')
fontCommand.add_argument('-m', '--main', action='store_true', help='Set, the specified (valid system) font to be the main (primary) font for this component type.')

# Add style subprocess arguments
styleCommand = subparsers.add_parser('style', help='General style handling commands help')
styleCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
styleCommand.add_argument('component_type', help='The component type is needed when adding a style for this type of component.')
styleCommand.add_argument('-a', '--add', action='store_true', help='Add a new style for a specific comonent type.')
styleCommand.add_argument('-r', '--remove', action='store_true', help='Remove a style file for this component type.')
styleCommand.add_argument('-p', '--path', help='Provide a valid path and file name if a specific style file is required or to be auto-generated. Otherwise, a default will be used.')
styleCommand.add_argument('-f', '--force', action='store_true', help='Force the addition or removal of a style from this component.')
styleCommand.add_argument('-v', '--validate', action='store_true', help='[NOT IMPLEMENTED] Validate a style file. Must use -p to provide a path and file name.')

# Add text preprocessing subprocess arguments
preprocessCommand = subparsers.add_parser('preprocess', help='General settings for handling component preprocessing commands.')
preprocessCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
preprocessCommand.add_argument('component_type', help='Specify the component type. This is required for all font functions.')
preprocessCommand.add_argument('-a', '--add', action='store_true', help='Install a preprocess into the project process folder. If you do not specify a process a default process script.')
preprocessCommand.add_argument('-r', '--remove', action='store_true', help='Disconnect a preprocess from the component type. This does not remove the actual script from the project. That needs to be done manually.')
preprocessCommand.add_argument('-f', '--force', action='store_true', help='Force a preprocess script to be updated, replaced or brought back to default condition for this component type.')
preprocessCommand.add_argument('-c', '--component_id', help='When a valid component ID is given, a preprocess script for a specific component type will be run only on that component.')
preprocessCommand.add_argument('-p', '--path', help='A valid path and file name of a specific preprocess script to be installed.')
preprocessCommand.add_argument('-e', '--execute', action='store_true', help='Execute a preprocess script. If a valid component ID is not specified, it will run on all components of the type it is a part of.')

# Add text post processing subprocess arguments
postprocessCommand = subparsers.add_parser('postprocess', help='General settings for handling component post processing commands.')
postprocessCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
postprocessCommand.add_argument('component_type', help='Specify the component type. This is required for all font functions.')
postprocessCommand.add_argument('-a', '--add', action='store_true', help='Install a post process into the project process folder. If you do not specify a process a default process script.')
postprocessCommand.add_argument('-r', '--remove', action='store_true', help='Disconnect a post process from the component type. This does not remove the actual script from the project. That needs to be done manually.')
postprocessCommand.add_argument('-f', '--force', action='store_true', help='Force a post process script to be updated, replaced or brought back to default condition for this component type.')
postprocessCommand.add_argument('-c', '--component_id', help='When a valid component ID is given, a post process script for a specific component type will be run only on that component.')
postprocessCommand.add_argument('-p', '--path', help='A valid path and file name of a specific post process script to be installed.')
postprocessCommand.add_argument('-e', '--execute', action='store_true', help='Execute a post process script. If a valid component ID is not specified, it will run on all components of the type it is a part of.')

# Add settings subprocess arguments
settingsCommand = subparsers.add_parser('settings', help='General settings handling commands help')
settingsCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
settingsCommand.add_argument('-c', '--configuration', help='The configuration set that the target setting is from.')
settingsCommand.add_argument('-s', '--section', help='The section path to the key/value pare to be changed. Multiple sections are separated by \'/\'.')
settingsCommand.add_argument('-k', '--key', help='The key which has the value to be changed.')
settingsCommand.add_argument('-v', '--value', help='A new value to add or change to the specified key.')

# Add Project Locking subprocess arguments
lockCommand = subparsers.add_parser('locking', help='Commands for locking down projects or parts of a project. This will prevent accidental processing.')
lockCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
lockCommand.add_argument('-t', '--lock_target', help='Specify either a valid component or component type to be locked/unlocked. If nothing is specified the project will be locked/unlocked.')
lockCommand.add_argument('-l', '--lock', action='store_true', help='Lock a project or component. If a component or component type are not specified, the entire project will be locked and not available to any processes.')
lockCommand.add_argument('-u', '--unlock', action='store_true', help='Unlock a project or component. This is hyarchical. If the entire project is locked, unlocking component types or components cannot take place until the entire project is unlocked.')
lockCommand.add_argument('-f', '--force', action='store_true', help='Force all components under a component type or group to have their [islocked] switch set to True or False, depending on the operation. Without Force, the [islocked] switch is set for only the target. All components under that target will remain untouched.')

# Add Project exporting subprocess arguments
exportCommand = subparsers.add_parser('export', help='Commands for exporting data from a project for a variety of purposes.')
exportCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
exportCommand.add_argument('component_type', help='Component ID (a positional argument required for all actions with this subprocess)')
exportCommand.add_argument('component_id', help='Specify a valid component ID to be exported. Exporting works only with components or component groups.')
exportCommand.add_argument('-p', '--path', help='Optional - This will specify a path/folder where the exported data is output to. Default is to create an export folder in the source folder and output to that.')
exportCommand.add_argument('-s', '--script', help='Optional - The name of an installed post process script to be used in the export process. Default will just blind copy the working text to the export folder.')
exportCommand.add_argument('-e', '--execute', action='store_true', help='Execute an export operation.')
exportCommand.add_argument('-b', '--bundle', action='store_true', help='Bundle the exported file(s) into a single compressed file.')
exportCommand.add_argument('-f', '--force', action='store_true', help='Force overwrite on exsisting file(s) of the same name.')


# Send the collected arguments to the handler
userArguments(vars(parser.parse_args()))


###############################################################################
########################### Close out the session #############################
###############################################################################


# In case there are any Canadians using this, politely say good bye
terminal('\n\t\tThank you, please come again!\n')



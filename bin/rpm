#!/usr/bin/python
# -*- coding: utf-8 -*-
# version: 20110823
# By Dennis Drescher (dennis_drescher at sil.org


###############################################################################
######################### Description/Documentation ###########################
###############################################################################

# One script to rule them all.  This is the mother script of the whole system.
# This script will drive all processes and keep track of what happens in the
# project log in each respective project.

# History:
# 20111202 - djd - Start over with manager-centric model


###############################################################################
################################ Initialize RPM ###############################
###############################################################################
# Firstly, import all the standard Python modules we need for this process and
# set the base path

import os, sys

# Set basic system vars
systemName = "Rapid Publication Manager (RPM)"
systemVersion = "0.0.1"
systemAbout = "RPM is a publishing management system written by the friendly developers at Payap University\'s Linguistics Institute (Text Unit). RPM stands for Rapid Publication Manager. It is currently being deployed in MSEAG and is under heavy development. Anyone wanting to try this system should be warned that it may not work in their context. However, the underlying principals of the system should work in any long document publishing environment. Therefore the package should be evaluated with that in mind. We welcome input and participation in this project. It is our hope it will be able to serve more than just MSEAG. For questions or more information please write: dennis_drescher@sil.org."

# Set the RPM base program path
rpmHome = os.environ.get('RPM_BASE')
if not rpmHome :
    rpmHome = os.path.join('usr', 'share', 'rpm')
    os.environ['RPM_BASE'] = rpmHome

# Set the user environment path
userHome = os.environ.get('RPM_USER')
if not userHome :
    sysHome = os.environ.get('HOME')
    userHome = os.path.join(sysHome, '.config', 'rpm')
    os.environ['RPM_USER'] = userHome

# Set the (potential) project home
projHome = os.getcwd()

# Set our paths to application resources
sys.path.insert(0, os.path.join(rpmHome, 'python_lib', 'rpm', 'core'))
sys.path.insert(0, os.path.join(rpmHome, 'python_lib', 'rpm', 'manager'))
sys.path.insert(0, os.path.join(rpmHome, 'python_lib', 'rpm', 'project'))
sys.path.insert(0, os.path.join(rpmHome, 'python_lib', 'rpm', 'component'))

# Load standard Python modules
import codecs, shutil, operator, argparse, zipfile, subprocess
from datetime import *
from configobj import ConfigObj


# Load the local classes
from proj_local import ProjLocal
from proj_log import ProjLog
from tools import *
from user_config import UserConfig
from proj_config import ProjConfig
from project import Project

# Instantiate User classes
local           = ProjLocal(rpmHome, userHome, projHome)
uc              = UserConfig(local)
log             = ProjLog(local, uc)

# Give a welcome message
terminal('\n\t\tWelcome to ' + systemName + '  ' + systemVersion + '\n')


###########################################################################
############################## RPM Functions ##############################
###########################################################################

#def newProject (uc, pc, pid, pdir = None, ptype = None, pname = None) :
def newProject (uc, pc, pid, ptype = None, pname = None) :
    '''Create a new publishing project.'''

    # Because the location of where a project is to be created could be
    # different than the cwd, we will count on pc.local to have all the
    # correct information. 
    
    # FIXME: Move the ptype and pname vars up to the arg processor which
    # calls this function.

    # Check the ptype
    if not ptype :
        ptype = 'book'

    # Check the pname, make one up if there isn't any
    if not pname :
        pname = 'The ' + pid + ' project'

    # Run some basic tests to see if this project can be created
    # Look for project in current folder
    if not os.path.isfile(pc.local.projConfFile) :
        # Look for locked project in current folder
        if os.path.isfile(pc.local.projConfFile + pc.local.lockExt) :
            terminal('ERR: Halt! Locked project already defined in target folder')
            return
        # Look for project in parent folder (don't want project in project)
        elif os.path.isfile(os.path.join(os.path.dirname(pc.local.projHome), pc.local.projConfFileName)) :
            terminal('ERR: Halt! Live project already defined in parent folder')
            return
        # Look for locked project in parent folder (prevent project in project)
        elif os.path.isfile(os.path.join(os.path.dirname(pc.local.projHome), pc.local.projConfFileName + pc.local.lockExt)) :
            terminal('ERR: Halt! Locked project already defined in parent folder')
            return
        # Check if path to parent is valid
        elif not os.path.isdir(os.path.dirname(pc.local.projHome)) :
            terminal('ERR: Halt! Not a valid (parent) path: ' + os.path.dirname(pc.local.projHome))
            return
        # Test if this project already exists in the user's config file.
        elif uc.isRegisteredProject(pid) :
            terminal('ERR: Halt! ID [' + pid + '] already defined for another project')
            return
    else :
        terminal('ERR: Halt! A project already exsits in this location. Please remove it before continuing.')
        return

    # If we made it to this point, we need to make a new project folder
    if not os.path.exists(pc.local.projConfFolder) :
        os.makedirs(pc.local.projConfFolder)

    # Create a new version of the project config file
    pc.makeNewProjConf(pc.local, pid, ptype, pname)

    # Add project to local RPM project registry
    uc.registerProject(pid, pname, ptype, pc.local.projHome)

    # Report what we did
    terminal('Created new project [' + pid + ']')
    return True


def lockProject (uc, pid = None) :
    '''Lock a project out of the RPM system.  This will not remove the
    project data but will 'disable' the project by taking its reference
    out of the user's config file and locking the project.conf file.'''

    global local

    # If no pid was given this fails
    if not pid :
        terminal('Error: Project ID code not given or found. lock operation failed.')
        return

    # Check if project is registered with RPM and get real path and reinit local paths
    if not uc.userConfig['Projects'][pid] :
        terminal('Error: Not a valid registered project, cannot continue with lock operation.')
        return
    else :
        local = ProjLocal(rpmHome, userHome, uc.userConfig['Projects'][pid]['projectPath'])

    # Wanting to be humane, we don't actually remove or delete anything, just lock it down
    if os.path.isfile(local.projConfFile) :
        os.rename(local.projConfFile, local.projConfFile + local.lockExt)
    else :
        terminal('Error: No project configuration file was found, lock operation failed.')
        return

    # If we made it this far, remove references from user rpm.conf
    uc.unregisterProject(pid)

    # Report the process is done
    terminal('Project [' + pid + '] is locked and removed from system configuration.')
    return True


def unlockProject (uc, pid = None) :
    '''Unlock a project by removing the lock extention from the project.conf file.
    Then add a reference back into the user config file. Because there is no real
    fixed path to the project given, this assumes that it is starting at the same
    level as the project folder. If not, it will fail.'''

    global local

    # If no pid was given this fails
    if not pid :
        terminal('Error: Project ID code not given or found. unlock operation failed.')
        return

    # Check if project is registered with RPM and get real path and reinit local paths
    if testForSetting(uc.userConfig, 'Projects', pid) :
        terminal('Error: Project is already registered, cannot continue with unlock operation.')
        return
    else :
        local = ProjLocal(rpmHome, userHome, os.path.join(projHome, pid))

    # Unlock the project conf file
    if os.path.isfile(local.projConfFile + local.lockExt) :
        os.rename(local.projConfFile + local.lockExt, local.projConfFile)
    else :
        terminal('Error: No locked configuration file was found, unlock operation failed.')
        return

    # If we made it this far, add references to the user rpm.conf file
    pc = ConfigObj(local.projConfFile)
    uc.registerProject(pid, pc['ProjectInfo']['projectName'], pc['ProjectInfo']['projectType'], local.projHome)

    # Report the process is done
    terminal('Project [' + pid + '] unlocked and added to the system configuration.')
    return True


def deleteProject (uc, pid = None) :
    '''Delete a project fromthe RPM system registry and from the hard drive.'''

    global local

    # If no pid was given this fails
    if not pid :
        terminal('Error: Project ID code not given or found. delete operation failed.')
        return

    # Check if project is registered with RPM and get real path and reinit local paths
    if not testForSetting(uc.userConfig, 'Projects', pid) :
        terminal('Error: [' + pid + '] not a valid registered project, cannot continue with delete operation.')
        return
    else :
        local = ProjLocal(rpmHome, userHome, uc.userConfig['Projects'][pid]['projectPath'])

    # Remove references from user rpm.conf
    if uc.unregisterProject(pid) :
        terminal('Removed [' + pid + '] from user configuration file.')

    # Delete everything in the project path
    if os.path.isdir(local.projHome) :
        shutil.rmtree(local.projHome)
    else :
        terminal('Warning: [' + pid + '] project could not be found, unable to delete project files.')
        return

    # Report the process is done
    terminal('Project [' + pid + '] has been removed from the system configuration and hard drive.')
    return True


def installPostProcess (pid, ctype, remove = False) :
    '''Install the default post_process.py script into the project
    processing folder for a specified component type. This script
    will be run on every file of that type that is imported into
    the project.'''

    # Build paths and names we need
    home = uc.userConfig['Projects'][pid]['projectPath']
    source = os.path.join(local.rpmCompTypeFolder, ctype, 'post_process.py')
    # Because we cannot always be sure that listed paths and local paths
    # match, we need to build our own project folder path at this point
    projProcessFolder = os.path.join(home, os.path.basename(local.projProcessFolder))
    target = os.path.join(projProcessFolder, ctype + '-post_process.py')
    if not os.path.isfile(target) :
        if shutil.copy(source, target) :
            terminal('Installed component post process file: [' + fName(target) + '] into process folder.')
    else :
        terminal('The file: [' + fName(target) + '] already exsists. Cannot copy over old file. Please manually remove it if you want a fresh copy installed.')


def isProject (pid) :
    '''Look up in the user config to see if a project is registered.'''

    try :
        if pid in uc.userConfig['Projects'] :
            return True
    except :
        return False


def initProject (pid) :
    '''Initialize an existing project according to the project ID given.'''

    local   = ProjLocal(rpmHome, userHome, uc.userConfig['Projects'][pid]['projectPath'])
    pc      = ProjConfig(local)
    log     = ProjLog(local, uc)
    if testForSetting(pc.projConfig, 'ProjectInfo', 'projectIDCode') :
        aProject = Project(uc.userConfig, pc.projConfig, local, log)
        return aProject


def accessHtmlHelp () :
    '''Call on the RPM basic HTML help system.'''

    # Build the viewer command
    cmds = uc.userConfig['System']['htmlHelpViewerCommand']
    cmds.append(local.rpmHelpIndexFile)
    # Run the viewer command
    rCode = subprocess.call(cmds)


###############################################################################
############################### Testing Functions #############################
###############################################################################


def getExampleSourceProject (exampID) :
    '''Create a test project from example projects located in the 
    example_lib folder in the RPM system. This is for system testing
    and nifty canned demos.'''

    exampleFile = os.path.join(local.rpmExamplesFolder, exampID + '.zip')
    demoFile = os.path.join(local.projHome, exampID, exampID + '.rpmDemo')
    thisZipFile = zipfile.ZipFile(exampleFile, 'r')
    if os.path.isfile(exampleFile) :
        thisZipFile.extractall()


def runExamplePubDemoProject (demoID) :
    '''Run an example demo file to test/demonstrate a project.'''

    # FIXME: Everywhere else we use subprocess.call() to do a process.  However,
    # in this case it takes too much fiddling to get a these more complex RPM
    # calls to run from within RPM.  To make it easy, we use os.system() to make
    # the call out.
    demoFile = os.path.join(local.projHome, demoID + '.rpmDemo')
    if os.path.isfile(demoFile) :
        demo = codecs.open(demoFile, "r", encoding='utf_8')
        for line in demo :
            if line[:1] != '#' and line[:1] != '' and line[:1] != '\n' :
                os.system(line)
        return True
    else :
        terminal('File not found: ' + fName(demoFile))


###############################################################################
############################# RPM Command Center ##############################
###############################################################################

# All command options must contain a project ID (-i). That is required. If one
# is not listed then the incoming command is either considered malformed or
# incomplete. If there is a way to figure out what the user might be needing
# the help system will be called. Otherwise, RPM will quite.

# The argument handler
def userArguments (args) :
    '''Process incoming command arguments.'''

    # Project level commands
    if sys.argv[1].lower() == 'project' :
        # Creating a new project
        if args['project_new'] :
        # FIXME: Add additional vars to this for project type and name and add them to the options
            if args['project_folder'] :
                # If a project folder is given (other than CWD) We need to
                # resolve it and pass it on to proj config settings (internal)
                customLocal = os.path.abspath(args['project_folder'])
                if not os.path.isdir(customLocal) :
                    terminal('Cannot resolve path. The path [' + customLocal + '] is not valid! Halting project creation process.')
                    sys.exit()

                projFolder = os.path.join(customLocal, args['project_id'])
                local   = ProjLocal(rpmHome, userHome, projFolder)
                pc      = ProjConfig(local)
                newProject(uc, pc, args['project_id'])
            else :
                # With no different project location given we will make sure
                # we use the default projHome set when the script started.
                projFolder = os.path.join(projHome, args['project_id'])
                local   = ProjLocal(rpmHome, userHome, projFolder)
                pc      = ProjConfig(local)
                newProject(uc, pc, args['project_id'])
        # Locking an exsisting project
        elif args['project_lock'] :
            lockProject(uc, args['project_id'])
        # Unlocking an exsisting project
        elif args['project_unlock'] :
            unlockProject(uc, args['project_id'])
        # Deleting an exsisting project
        elif args['project_delete'] :
            deleteProject(uc, args['project_id'])
        # Install post process script, cType is required
        elif args['post_process'] :
            installPostProcess(args['project_id'], args['post_process'])
        # Run the post process script on all the files of a component type, cType is required
        elif args['run_process'] :
            postProcessType(args['project_id'], args['run_process'])

    # Component level commands
    elif sys.argv[1].lower() == 'component' :
        if isProject(args['project_id']) :
            aProject = initProject(args['project_id'])
            if args['component_new'] :
                if args['component_type'] :
                    if args['meta_list'] :
                        aProject.addMetaComponent(args['component_id'], args['meta_list'], args['component_type'])
                    else :
                        aProject.addComponent(args['component_id'], args['component_type'])
                else :
                    terminal('Must supply a component type (-t xxxx) to create a component.')
            if args['component_delete'] :
                aProject.deleteComponent(args['component_id'])
#            if args['meta_id'] :
#                aProject.addMetaComponent(args['meta_id'], args['meta_list'], args['component_type'])
            # Render vs. view command is just a matter of forcing the component
            # to be rendered if render is selected by the user. Otherwise, if
            # only view is requested, force is set to False and the component
            # will not be rerendered if it already exsists.
            if args['component_render'] :
                force = True
                aProject.renderComponent(args['component_id'], force)
            if args['component_view'] :
                force = False
                aProject.renderComponent(args['component_id'], force)
            # Component and component type locking and unlocking
            if args['component_lock'] and args['component_type'] :
                aProject.lockComponent(args['component_id'], args['component_type'])
            elif args['component_lock'] :
                aProject.lockComponent(args['component_id'])
            elif args['component_unlock'] and args['component_type'] :
                aProject.unlockComponent(args['component_id'], args['component_type'])
            elif args['component_unlock'] :
                aProject.unlockComponent(args['component_id'])
            # Run post processes on a single component
            elif args['run_process'] :
                aProject.postProcessComponent(args['component_id'])
        else :
            terminal('Cannot find [' + args['project_id'] + '] project.')

    # Font level commands
    elif sys.argv[1].lower() == 'font' :
        if isProject(args['project_id']) :
            aProject = initProject(args['project_id'])
            if args['font_new'] :
                aProject.addComponentFont(args['font_name'], args['component_type'])
            if args['font_remove'] :
                aProject.removeComponentFont(args['font_name'], args['component_type'])
            if args['font_primary'] :
                aProject.setPrimaryFont(args['font_name'], args['component_type'])
        else :
            terminal('Cannot find [' + args['project_id'] + '] project.')

    # Style level commands
    elif sys.argv[1].lower() == 'style' :
        if isProject(args['project_id']) :
            aProject = initProject(args['project_id'])
            if args['style_override'] :
                aProject.createCustomStyleFile(args['component_type'])
            if args['style_component'] :
                aProject.createComponentStyleFile(args['component_id'])
        else :
            terminal('Cannot find [' + args['project_id'] + '] project.')

    # Setting manipulation commands
    elif sys.argv[1].lower() == 'settings' :
        if isProject(args['project_id']) :
            aProject = initProject(args['project_id'])
            if args['configuration'] :
                aProject.changeConfigSetting(args['configuration'], args['section'], args['key'], args['value'])
        else :
            terminal('Cannot find [' + args['project_id'] + '] project.')

    # Testing commands
    elif sys.argv[1].lower() == 'test' :
        if args['source_id'] :
            getExampleSourceProject(args['source_id'])
        if args['demo_id'] :
            runExamplePubDemoProject(args['demo_id'])

    # Extra help access
    elif sys.argv[2].lower() == 'help' :
        if args['about'] :
            terminal('\n' + systemName + ' version ' + systemVersion + '\n')
            terminal('About: ' + systemAbout + '\n')
        if args['basic'] :
            accessHtmlHelp()

    # Totally lost
    else:
        terminal('Error: Command not recognized! ')
        sys.exit()

    # During a process, a number of log entries will be made and written out.
    # Over time the log file could get very large. To control the size, there
    # is a setting in the user config file that limits the number of lines in
    # the log file. The default is 1000 but it can be adjusted if needed. The
    # following call here will trim the log file to its specified limit. This
    # is done here as there should be no further operations done at this point.
    
    # Note: This will not work with "project" commands (aProject is not declaired)
#    if not sys.argv[1].lower() == 'project' :
#        if os.path.isfile(aProject.local.projLogFile) :
#            trimLog(aProject.local.projLogFile, uc.userConfig['System']['projLogLineLimit'])


# Setup the arg parser
parser = argparse.ArgumentParser(description=systemName)
subparsers = parser.add_subparsers(help='sub-command help')

# Add main arguments (first postion options)
parser.add_argument('-a', '--about', action='store_true', help = 'About RPM')
parser.add_argument('-b', '--basic', action='store_true', help = 'Basic RPM help (in HTML)')

# Add project subprocess arguments
projCommand = subparsers.add_parser('project', help='General project management commands help')
projCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
projCommand.add_argument('-n', '--project_new', action='store_true', help='Create a new project on this computer.')
projCommand.add_argument('-l', '--project_lock', action='store_true', help='Lock a project out of the local RPM system so it cannot be acted on.')
projCommand.add_argument('-u', '--project_unlock', action='store_true', help='Unlock a project. There must be a locked project configuration file present.')
projCommand.add_argument('-d', '--project_delete', action='store_true', help='Delete a project permanently from the system. This will do just what is says. Be careful!')
projCommand.add_argument('-f', '--project_folder', help='Location of the project home folder if the current working directory is not the actual target.')
projCommand.add_argument('-p', '--post_process', help='Install the default post_process.py script for a component type into the project process folder. You must specify a component type.')
projCommand.add_argument('-r', '--run_process', help='Run the post_process.py script on all files of a specified component type in the project process folder. You must specify a component type.')

# Add component subprocess arguments
compCommand = subparsers.add_parser('component', help='General project component management commands help')
compCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
compCommand.add_argument('component_id', help='A specific component ID required for creating a new component.')
compCommand.add_argument('-t', '--component_type', help='The component type is needed for creating a new component.')
compCommand.add_argument('-n', '--component_new', action='store_true', help='Create a new component for this project.')
compCommand.add_argument('-d', '--component_delete', action='store_true', help='Delete an existing component from this project.')
#compCommand.add_argument('-m', '--meta_component', action='store_true', help='Indicate if this is a meta component.')
compCommand.add_argument('-e', '--meta_list', help='Create a list of components for this new meta component. They must be of the same type.')
compCommand.add_argument('-r', '--component_render', action='store_true', help='Render a single component in this project.')
compCommand.add_argument('-v', '--component_view', action='store_true', help='View the rendered output of a specific component, if it does not exsist it will render the component as well.')
compCommand.add_argument('-l', '--component_lock', action='store_true', help='Lock a component so the working text cannot be copied over if the source is updated. By adding they type code (-t), an entire set of components can be locked.')
compCommand.add_argument('-u', '--component_unlock', action='store_true', help='Unlock a component, or a set of components by adding the component type (-t), so working text can be updated with newer source.')
compCommand.add_argument('-p', '--run_process', action='store_true', help='Run the post_process.py script on a single component.')

# Add font subprocess arguments
fontCommand = subparsers.add_parser('font', help='General font handling commands help')
fontCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
fontCommand.add_argument('-t', '--component_type', help='The component type is needed when adding a font for this type of component.')
fontCommand.add_argument('-f', '--font_name', help='The font family name. The name given has to have an RPM font configuration file associated with it.')
fontCommand.add_argument('-n', '--font_new', action='store_true', help='Add a new font for this project.')
fontCommand.add_argument('-r', '--font_remove', action='store_true', help='Remove a font from this project.')
fontCommand.add_argument('-p', '--font_primary', action='store_true', help='Set, and install if necessary, the primary font for this project. The font family name given has to have an RPM font configuration file associated with it.')

# Add style subprocess arguments
styleCommand = subparsers.add_parser('style', help='General font handling commands help')
styleCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
styleCommand.add_argument('-t', '--component_type', help='The component type is needed when adding a style for this type of component.')
styleCommand.add_argument('-o', '--style_override', action='store_true', help='Create a custom style (override) file for this component type.')
styleCommand.add_argument('-c', '--style_component', action='store_true', help='Create a component level style override file.')

# Add settings subprocess arguments
settingsCommand = subparsers.add_parser('settings', help='General settings handling commands help')
settingsCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
settingsCommand.add_argument('-c', '--configuration', help='The configuration set that the target setting is from.')
settingsCommand.add_argument('-s', '--section', help='The section path to the key/value pare to be changed.')
settingsCommand.add_argument('-k', '--key', help='The key which has the value to be changed.')
settingsCommand.add_argument('-v', '--value', help='A new value to add or change to the specified key.')

# Add testing subprocess arguments
testCommand = subparsers.add_parser('test', help='General system testing commands help')
testCommand.add_argument('-s', '--source_id', help='Example source ID of the test project taken from the example library you want to setup. This should be a valid ZIP file name, without the .zip extention.')
testCommand.add_argument('-d', '--demo_id', help='Example demo ID of the publishing test project taken from the source example that was (or is to be) setup. The ID is combined with a \'.rpmDemo\' extention which should be a valid file name.')

# Add help subprocess arguments
helpCommand = subparsers.add_parser('help', help='General system help')

# Send the collected arguments to the handler
userArguments(vars(parser.parse_args()))


###############################################################################
########################### Close out the session #############################
###############################################################################


# In case there are any Canadians using this, politely say good bye
terminal('\n\t\tThank you, please come again!\n')



#!/usr/bin/python
# -*- coding: utf-8 -*-

#    Copyright 2014, SIL International
#    All rights reserved.
#
#    This library is free software; you can redistribute it and/or modify
#    it under the terms of the GNU Lesser General Public License as published
#    by the Free Software Foundation; either version 2.1 of License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    Lesser General Public License for more details.
#
#    You should also have received a copy of the GNU Lesser General Public
#    License along with this library in the file named "LICENSE".
#    If not, write to the Free Software Foundation, 51 Franklin Street,
#    suite 500, Boston, MA 02110-1335, USA or visit their web page on the 
#    internet at http://www.fsf.org/licenses/lgpl.html.


###############################################################################
######################### Description/Documentation ###########################
###############################################################################

# This is the main Command Line Interface (CLI) script. All Rapuma functionality
# should be accessable by this script.


###############################################################################
############################### Initialize Rapuma #############################
###############################################################################
# Firstly, import all the standard Python modules we need for this process and
# set the base path

import os, sys, timeit, datetime
from functools import partial

startTime = timeit.default_timer()

###############################################################################
############################ Location Discovery ###############################
###############################################################################

# Set the Rapuma base program paths. It looks in /usr/share first for an
# installed copy. If you give it a actual path to the development version
# it will run from there. (~/Projects/rapuma/scripts/rapuma)
# FIXME: Environment variables are set that may not be needed if this block
# of code was turned into a module and called from the dependent modules.
# E.g., if rapuma is called from /usr/bin/rapuma then rapumaBase = /usr
# If from ~/Projects/rapuma/scripts/rapuma then rapumaBase = ~/Projects/rapuma
rapumaBase = os.path.dirname(os.path.dirname(os.path.abspath(sys.argv[0])))
rapumaHome = [d for d in [os.path.join(rapumaBase, 'share', 'rapuma'), 
                        os.path.join(rapumaBase)] if os.path.exists(d)]
rapumaHome = rapumaHome[0] if len(rapumaHome) else None
os.environ['RAPUMA_BASE'] = rapumaHome
# According to the base if found, insert the lib folder into the Python sys path
if rapumaHome :
    sys.path.insert(0, os.path.join(rapumaHome, 'lib'))
# Set the user environment path. This is always in the same place.
os.environ['RAPUMA_USER'] = os.path.expanduser(os.path.join('~', '.config', 'rapuma'))

# Set the (potential) project home by looking for the project config file.
def find_project_root(tag, path=os.path.curdir):
    path=os.path.splitdrive(os.path.realpath(os.path.expanduser(os.path.expandvars(path))))[1]
    while (not os.path.exists(os.path.join(path, tag))):
        path = os.path.dirname(path)
        if path == os.path.sep: return None
    return path

# Find the project home
# FIXME: Though we find the home here, it really doesn't mean anything.
# It is not used here in this main script. As noted above, this code
# block should be moved into a seperate module and called by others.
projHome = find_project_root(os.path.join('Config', 'project.conf'))
# If not found, assume that this is a new project situation
if not projHome :
    projHome = os.getcwd()

os.environ['RAPUMA_PROJ'] = projHome

###############################################################################
############################ Location Discovery ###############################
###############################################################################

# Load standard Python modules
import codecs, argparse
from configobj                          import ConfigObj

# Load the local classes
from rapuma.core.proj_local             import ProjLocal
from rapuma.core.proj_log               import ProjLog
from rapuma.core.user_config            import UserConfig
from rapuma.core.proj_data              import ProjData, Template
from rapuma.core.proj_binding           import ProjBinding
from rapuma.core.proj_compare           import ProjCompare
from rapuma.core.proj_process           import ProjProcess
from rapuma.core.tools                  import Tools
from rapuma.project.proj_config         import Config
from rapuma.project.proj_setup          import ProjSetup, ProjDelete
from rapuma.project.proj_commander      import ProjCommander
from rapuma.project.proj_font           import ProjFont
from rapuma.project.proj_background     import ProjBackground
from rapuma.project.proj_diagnose       import ProjDiagnose
from rapuma.manager.project             import Project
from rapuma.group.usfm_data             import UsfmData


#import pdb; pdb.set_trace()


# Grab some system info
sysConfig                               = ConfigObj(os.path.join(rapumaHome, 'config', 'system.ini'), encoding='utf-8')
# Instantiate User config class
uc                                      = UserConfig()
tools                                   = Tools()

# Get a list of projects
projDir = os.path.expanduser(uc.userConfig['Resources']['projects'])
if os.path.exists(projDir) :
    projList = tools.getProjIdList(projDir)
else :
    sys.exit('\nERROR: The projects folder path is not valid: ' + projDir + '. Process halting.\n')

# Set some global vars
systemName                              = sysConfig['Rapuma']['systemName']
systemAbout                             = sysConfig['Rapuma']['systemAbout']
systemVersion                           = sysConfig['Rapuma']['systemVersion']
local                                   = None


###############################################################################
################################ Rapuma CLI ###################################
###############################################################################

# Give a welcome message
tools.terminal('\n\t\tWelcome to ' + systemName)
tools.terminal('\n\t\t\tVersion ' + systemVersion + '\n')

###############################################################################
########################### Rapuma CLI Functions ##############################
###############################################################################


def trimLog (local) :
    '''Trim a log file.  This will take an existing log file and
    trim it to the amount specified in the system file.'''

#    import pdb; pdb.set_trace()
    
    # Of course this isn't needed if there isn't even a log file
    if os.path.exists(local.projLogFile) :

        limit = int(uc.userConfig['System']['projLogLineLimit'])

        # Read in the existing log file
        readObject = codecs.open(local.projLogFile, "r", encoding='utf_8')
        lines = readObject.readlines()
        readObject.close()

        # Process only if we have enough lines
        if len(lines) > limit :
            writeObject = codecs.open(local.projLogFile, "w", encoding='utf_8')
            lineCount = 0
            for line in lines :
                if limit > lineCount :
                    writeObject.write(line)
                    lineCount +=1

            writeObject.close()


###############################################################################
########################### Rapuma Command Center #############################
###############################################################################

# All command options must contain a project ID (-i). That is required. If one
# is not listed then the incoming command is either considered malformed or
# incomplete. If there is a way to figure out what the user might be needing
# the help system will be called. Otherwise, Rapuma will quit.

# The argument handler
def userArguments (args) :
    '''Process incoming command arguments.'''

#    import pdb; pdb.set_trace()

    # Set some vars
    local = None
    pid = ''

    # Common error handlers
    def cmdError (cmd, cmdType) :
        sys.exit('\nERROR: The ' + cmd + ' command is not valid to use with ' + cmdType + '. Process halting.\n')

    def cTypeError (cType) :
        sys.exit('\nERROR: The ' + cType + ' component type is not recognized. Process halting.\n')

    # Pre-command process: Extra help access
    if sys.argv[1].lower() == 'help' :
        if args.about :
            tools.terminal('\n' + systemName + ' version ' + systemVersion + '\n')
            tools.terminal('About: ' + systemAbout + '\n')
            return

    ##### PROJECT
    # Project level commands
    elif sys.argv[1].lower() == 'publication' :
        pid         = args.project_id
        cmd         = args.command
        sub         = args.sub_command
        path        = ''
        mediaType   = None
        if args.media_type :
            mediaType = args.media_type
        else :
            # The default is book
            mediaType = 'book'
        # Source path is optional but if given, resolve it
        if args.path :
            path = tools.resolvePath(args.path)
            if not os.path.exists(path) :
                sys.exit('\nERROR: Sourct path is not valid [' + path + ']. Process halting.\n')
        # Figure out what area this command relates to and do it
        if cmd == 'archive' :
            sys.exit('\nERROR: The ' + cmd + ' is not working at this time. I really feel bad about this and I hope it does not cause you any distress.\n')
        elif cmd == 'backup' :
            sys.exit('\nERROR: The ' + cmd + ' is not working at this time. I really feel bad about this and I hope it does not cause you any distress.\n')
        elif cmd == 'project' :
            if sub == 'create' :
                ProjSetup(sysConfig, pid).newProject(mediaType)
            elif sub == 'remove' :
                ProjDelete().deleteProject(pid)
            else :
                sys.exit('\nERROR: The ' + sub + ' command is not supported. The developer didn\'t think it was a good idea. If you think otherwise, let him know what your thoughts are and he might just add it in for you.\n')
        elif cmd == 'share' :
            sys.exit('\nERROR: The ' + cmd + ' command is not working at this time. I really feel bad about this and I hope it does not cause you any distress.\n')

    ##### CONTENT
    # Project level commands
    elif sys.argv[1].lower() == 'content' :
        usfmData    = UsfmData()
        pid         = args.project_id
        gid         = args.group_id
        cmd         = args.command
        sub         = args.sub_command
        cType       = args.comp_type
        usfmExt     = ['USFM', 'usfm', 'SFM', 'sfm']
        cid_list    = []            # A list of one or more cids
        source_list = []            # Gen: A list of files w/paths
        path        = ''
        # Check source path if there is one
        if args.path :
            path = os.path.abspath(args.path)
            if not os.path.isdir(path) :
                sys.exit('\nERROR: Path is not valid. [' + path + '] Process halting.\n')
        # These are recognized CID groups names for generating CID list
        # if no CIDs are provided. To expand this list there must be
        # a corresponding function in UsfmData that will retrieve the
        # correct CIDs in the correct order.
        canonGroups = ['OT', 'NT', 'BIBLE']
        # If the user provided any CIDs, we preprocess them here
        if args.cid_list :
            # Load this now because we'll need it
            cids        = []
            if type(args.cid_list) != list :
                cids    = args.cid_list.split()
            else :
                cids    = args.cid_list
            cid_list = cids
        else :
            # Otherwise we will see if we are adding using a shortcut
            if sub == 'add' or sub == 'update' :
                if gid in canonGroups :
                    getCidList = getattr(usfmData, gid.lower() + 'CidList')
                    cid_list = getCidList()
        # The cType is required for a number of operations, check for it here
        if cmd == 'group' or cmd == 'component' :
            if not cType :
                sys.exit('\nERROR: A component type (--comp_type/-c) was not given for this opperation. Due to poor programing, this is needed to complete this operation. Rapuma apologizes for this inconvenience. Process halting. Please try again by adding this parameter and it should work fine.\n')                
            
        # The source_list will be auto-generated and is required at
        # the engine level for processing. We need both a source_path
        # and a CID list to make it. This will take them as it finds
        # them but the completed list needs to be varified


#        import pdb; pdb.set_trace()


        if cid_list :
            # Check for path
            if not path :
                sys.exit('\nERROR: Source path (--path/-p) not given. Process halting. Please add this parameter and retry.\n')
            # Create the source_list by type
            if cType == 'usfm' :
                for f in os.listdir(path) :
                    # Check only valid file types (by ext)
                    if os.path.splitext(f)[1][1:].lower() in usfmExt :
                        cid = tools.discoverCIDFromFile(os.path.join(path, f))
                        if cid.lower() in cid_list : 
                            source_list.append(os.path.join(path, f))
            elif cType == 'pdf' :
                for f in cid_list :
                    source_list.append(os.path.join(path, f + '.pdf'))
            else :
                sys.exit('\nERROR: Component type not supported. Rapuma apologizes for this inconvenience. Process halting.\n')

        # Before we go on, quickly varify existance of all files in the
        # list and cross-check with the CID list
        if source_list :
            checkList = list(cid_list)
            for f in source_list :
                if cType == 'usfm' :
                    if not os.path.exists(f) :
                        sys.exit('\nERROR: Path is not valid. [' + f + '] Process halting.\n')
                    else :
                        cid = tools.discoverCIDFromFile(f).lower()
                        if cid in checkList :
                            checkList.remove(cid)
                else :
                    # In this "other" case we assume the file name (less
                    # extention) is the cid
                    if os.path.isfile(f) :
                        # This will obviously fail if there is more than one '.' in
                        # the file name, but why would anyone want to do that? :-)
                        checkList.remove(ProjSetup(sysConfig, pid).getCidFromPdfFileName(tools.fName(f)))
            if len(checkList) != 0 :
                    sys.exit('\nERROR: Components not found: [' + ''.join(checkList) + '] Process halting.\n')
                    
        # Figure out what area this command relates to and do it
        if cmd == 'group' :
            # Add a group (no components)
            if sub == 'add' :
                ProjSetup(sysConfig, pid).addGroup(cType, gid)
            # Remove a group (all of it)
            elif sub == 'remove' :
                ProjSetup(sysConfig, pid).removeGroup(gid)
                # Clean up the helper scripts too
                if tools.str2bool(uc.userConfig['System']['autoHelperScripts']) :
                    ProjCommander(pid).removeScripts()
        # Work with components




        elif cmd == 'component' :
            # Add one or more components in a group (will not overwrite)
            if sub == 'add' :
                ProjSetup(sysConfig, pid).addComponent(gid, source_list)
            # Remove one or more components from a group




            elif sub == 'remove' :
                sys.exit('\nERROR: This is embarassing the ' + cmd + ' ' + sub + ' feature has not been implemented in the CLI yet. Process halting.\n')
            # Update one or more components in a group
            elif sub == 'update' :
                if source_list :
                    ProjSetup(sysConfig, pid).updateGroup(gid, source_list)
                else :
                    sys.exit('\nERROR: Must provide a source path or valid component IDs to update a group. Process halting.\n')




    ##### SETTINGS
    # Setting manipulation commands
    elif sys.argv[1].lower() == 'setting' :
        pid         = args.project_id
        config      = args.configuration
        section     = args.section
        key         = args.key
        value       = args.value
        if (section or key or value) :
            ProjSetup(sysConfig, pid).changeConfigSetting(config, section, key, value)
        else :
            sys.exit('\nERROR: Must provide a section, key and value. Process halted!\n')

    # Totally lost
    else:
        sys.exit('\nERROR: Command not recognized: [' + sys.argv[1] + ']\n')

    # Look for an error log file and notify the user if one is found that there
    # were errors in the process. This might have failed because we loose our 
    # project object some times. For now, we'll put a 'try' around it.
    if sys.argv[1].lower() == 'project' :
        try :
            if os.path.isfile(local.projErrorLogFile) :
                tools.terminal('\n\t*** ERRORS OCCURRED. PLEASE CHECK ERROR LOG ***\n')
        except :
            pass

    # Do some project log maintenance
    if local :
        trimLog(local)



###############################################################################
############################## Rapuma Starts Here #############################
###############################################################################

if __name__ == '__main__' :

    # The following is applied to certain inputs to garentee input to be Unicode
    # and not ascii or whatever the default file system encoding is.
    # (Note: See the settings section for an example.)
    fsunicode = partial(unicode, encoding=sys.getfilesystemencoding())

    # We will try to maintain a common syntax in all the subparsers Some common
    # argument options are:
    #   -a = add something
    #   -r = remove something
    #   -e = execute something
    #   -f = force the execution of something
    #   -p = path (and file name) of something

    # Setup the arg parser
    parser = argparse.ArgumentParser(description=systemName)
    subparsers = parser.add_subparsers(help='sub-command help')

    # Add help subprocess arguments
    helpCommand = subparsers.add_parser('help', help='General system help')

    # Available choices

    # Project
    prCmd              = ['archive', 'backup', 'project', 'share']
    prSubCmd           = ['create', 'remove', 'restore', 'save', 'update']
    prMediaType        = ['book']
    # Content
    ctCmd              = ['component', 'group']
    ctSubCmd           = ['add', 'remove', 'update']
    ctCompType         = ['usfm', 'pdf']
    # Asset
    asCmd              = ['font', 'illustration', 'macro', 'script']
    asSubCmd           = ['add', 'primary', 'remove', 'update']
    # Processes
    pcCmd              = ['component', 'group', 'project']
    pcSubCmd           = ['bind', 'export', 'preprocess', 'postprocess', 'render']
    # Setting
    stConf             = ['adjustment', 'illustration', 'layout', 'project', 'usfmTex']

    # Add main arguments (first postion options)
    parser.add_argument('-a', '--about', action='store_true', help = 'Information about Rapuma')
    parser.add_argument('-b', '--basic', action='store_true', help = 'Basic Rapuma help (in HTML)')
    parser.add_argument('-V', '--version', action='version', version=systemVersion, help = 'Show the program version and exit, doing nothing else')

    # Add Project subprocess arguments
    projCommand = subparsers.add_parser('publication', help='General publication management commands')
    projCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
    projCommand.add_argument('command', choices=prCmd, help='The general commands that can be used for managing a project.')
    projCommand.add_argument('sub_command', choices=prSubCmd, help='Specify the command action to be executed on the project. This is required for all project processing functions.')
    projCommand.add_argument('-m', '--media_type', choices=prMediaType, help='If creating a new project, give a valid project media type code. The default is "book".')
    projCommand.add_argument('-p', '--path', help='A local path needed for certain operations.')

    # Add Content subprocess arguments
    contentCommand = subparsers.add_parser('content', help='General project content management commands')
    contentCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
    contentCommand.add_argument('group_id', help='A unique ID for this group.')
    contentCommand.add_argument('command', choices=ctCmd, help='Specify either group or component which will be acted on.')
    contentCommand.add_argument('sub_command', choices=ctSubCmd, help='Commands that can be used for managing groups and components.')
    contentCommand.add_argument('-i', '--cid_list', help='Using the proper ID, specify components to be added to this group. A group can have one or more components. The list must be enclosed by quotes and have only a space between ID codes, e.g. \"aaa bbb ccc\".')
    contentCommand.add_argument('-c', '--comp_type', choices=ctCompType, help='The group component type is needed for creating a new group.')
    contentCommand.add_argument('-p', '--path', help='A path to were component files may be found.')

    # Add project Asset management subprocess arguments
    assetCommand = subparsers.add_parser('asset', help='General project asset handling commands')
    assetCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
    assetCommand.add_argument('command', choices=asCmd, help='The general commands that can be used for managing assets.')
    assetCommand.add_argument('sub_command', choices=asSubCmd, help='Sub commands that can be used for managing project assets.')
    assetCommand.add_argument('-f', '--file', help='An asset file name.')
    assetCommand.add_argument('-p', '--path', help='A path to were asset files may be found.')

    # Add Processing subprocess arguments
    processCommand = subparsers.add_parser('process', help='General project process commands')
    processCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
    processCommand.add_argument('command', choices=pcCmd, help='The general commands that can be used for managing project processes.')
    processCommand.add_argument('sub_command', choices=pcSubCmd, help='Sub commands that can be used for managing project processes.')
    processCommand.add_argument('group_id', help='A unique ID for this group.')
    processCommand.add_argument('-p', '--path', help='A path to be used in a process.')
    processCommand.add_argument('-b', '--background', action='store_true', help='Used only with the render command, this will add a background to the rendered group.')
    processCommand.add_argument('-d', '--diagnostic', action='store_true', help='Used only with the render command, this will add a diagnostic layer to the rendered group.')
    processCommand.add_argument('-n', '--doc_info', action='store_true', help='Used only with background when the render command is run, this will add a document information to the background layer for the rendered group.')
    processCommand.add_argument('-y', '--hyphenation', action='store_true', help='Use hyphenation for the group to be rendered.')
    processCommand.add_argument('-i', '--cid_list', help='Using the proper ID, specify components to be added to this group. A group can have one or more components. The list must be enclosed by quotes and have only a space between ID codes, e.g. \"aaa bbb ccc\".')
    processCommand.add_argument('-s', '--save', action='store_true', help='Save a rendered file to the Deliverable folder with a unique name.')
    processCommand.add_argument('-g', '--pages', help='Specify a page number or range of pages to render.')
    processCommand.add_argument('-o', '--override', help='A specific file name used to override normal automated output file name creation.')

    # Add Settings subprocess arguments
    settingsCommand = subparsers.add_parser('setting', help='General settings handling commands')
    settingsCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
    settingsCommand.add_argument('configuration', choices=stConf, help='The configuration set that the target setting is from.')
    settingsCommand.add_argument('-s', '--section', help='The section path to the key/value pare to be changed. Multiple sections are separated by \'/\'.')
    settingsCommand.add_argument('-k', '--key', help='The key which has the value to be changed.')
    settingsCommand.add_argument('-v', '--value', type=fsunicode, help='A new value to add or change to the specified key.')

    # Send the collected arguments to the handler
    userArguments(parser.parse_args())


    ###############################################################################
    ########################### Close out the session #############################
    ###############################################################################

    # In case there are any Canadians using this, politely say good bye
    timeTotal = round(timeit.default_timer() - startTime, 2)
    tools.terminal('\n\t\tTotal process time: ' + str(datetime.timedelta(seconds = timeTotal)).split('.')[0] + '\n')
    tools.terminal('\t\tThank you, please come again!\n')




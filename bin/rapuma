#!/usr/bin/python
# -*- coding: utf-8 -*-
# version: 20110823
# By Dennis Drescher (dennis_drescher at sil.org


###############################################################################
######################### Description/Documentation ###########################
###############################################################################

# One script to rule them all.  This is the mother script of the whole system.
# This script will drive all processes and keep track of what happens in the
# project log in each respective project.

# History:
# 20111202 - djd - Start over with manager-centric model


###############################################################################
################################ Initialize Rapuma ###############################
###############################################################################
# Firstly, import all the standard Python modules we need for this process and
# set the base path

import os, sys

# Set the Rapuma base program paths
rapumaHome = os.environ.get('RAPUMA_BASE')
sysHome = os.environ.get('HOME')
if not rapumaHome :
    for t in (os.path.join(sysHome, '.local'), '/usr/local', '/usr') :
        rapumaHome = os.path.join(t, 'share', 'rapuma')
        if os.path.exists(os.path.join(rapumaHome, 'resources')) :
            os.environ['RAPUMA_BASE'] = rapumaHome
            break

# Set the Rapuma program resources path
#rapumaResources = os.environ.get('RAPUMA_RESOURCES')
#if not rapumaResources :
#    rapumaResources = os.path.join(rapumaHome, 'resources')
#    os.environ['RAPUMA_RESOURCES'] = rapumaResources

# Set the user environment path
userHome = os.environ.get('RAPUMA_USER')
if not userHome :
    userHome = os.path.join(sysHome, '.config', 'rapuma')
    os.environ['RAPUMA_USER'] = userHome

# Set the (potential) project home
projHome = os.getcwd()

# Load standard Python modules
import codecs, shutil, operator, argparse, subprocess, zipfile
from datetime import *
from configobj import ConfigObj

# Load the local classes
from rapuma.core.proj_local import ProjLocal
from rapuma.core.proj_log import ProjLog
from rapuma.core.tools import *
from rapuma.core.user_config import UserConfig
from rapuma.core.proj_config import ProjConfig
from rapuma.project.project import Project

# Instantiate User classes
local           = ProjLocal(rapumaHome, userHome, projHome)
uc              = UserConfig(local)
log             = ProjLog(local, uc)

# Pull some info from the user config
systemName      = uc.userConfig['System']['systemName']
systemVersion   = uc.userConfig['System']['systemVersion']
systemAbout     = uc.userConfig['System']['systemAbout']

# Give a welcome message
terminal('\n\t\tWelcome to ' + systemName + '  ' + systemVersion + '\n')

###########################################################################
############################## Rapuma Functions ##############################
###########################################################################

def newProject (uc, pc, pid, pname = None, tid = None, pmid = None) :
    '''Create a new publishing project.'''

    # Because the location of where a project is to be created could be
    # different than the cwd, we will count on pc.local to have all the
    # correct information. 
    
    # Check the pmid
    if not pmid :
        pmid = 'book'
    else :
        pmid = pmid.lower()

    # Check the pname, make one up if there isn't any
    if not pname :
        pname = 'The ' + pid + ' project'

    # Run some basic tests to see if this project can be created
    # Look for project in current folder
    if not os.path.isfile(pc.local.projConfFile) :
        # Look for locked project in current folder
        if os.path.isfile(pc.local.projConfFile + pc.local.lockExt) :
            terminal('ERR: Halt! Locked project already defined in target folder')
            return
        # Look for project in parent folder (don't want project in project)
        elif os.path.isfile(os.path.join(os.path.dirname(pc.local.projHome), pc.local.projConfFileName)) :
            terminal('ERR: Halt! Live project already defined in parent folder')
            return
        # Look for locked project in parent folder (prevent project in project)
        elif os.path.isfile(os.path.join(os.path.dirname(pc.local.projHome), pc.local.projConfFileName + pc.local.lockExt)) :
            terminal('ERR: Halt! Locked project already defined in parent folder')
            return
        # Check if path to parent is valid
        elif not os.path.isdir(os.path.dirname(pc.local.projHome)) :
            terminal('ERR: Halt! Not a valid (parent) path: ' + os.path.dirname(pc.local.projHome))
            return
        # Test if this project already exists in the user's config file.
        elif uc.isRegisteredProject(pid) :
            terminal('ERR: Halt! ID [' + pid + '] already defined for another project')
            return
    else :
        terminal('ERR: Halt! A project already exsits in this location. Please remove it before continuing.')
        return

    # If we made it to this point, we need to make a new project folder
    if not os.path.exists(pc.local.projConfFolder) :
        os.makedirs(pc.local.projConfFolder)

    # Create the project depeding on if it is from a template or not
    if tid :
        templateToProject(uc, pc.local.projHome, pid, tid, pname)
    else :
        # If not from a template, just create a new version of the project config file
        pc.makeNewProjConf(pc.local, pid, pmid, pname)

    # Add project to local Rapuma project registry
    uc.registerProject(pid, pname, pmid, pc.local.projHome)

    # Report what we did
    terminal('Created new project [' + pid + ']')
    return True


def templateToProject (uc, path, pid, tid, pname) :
    '''Create a new project based on the provided template ID. This
    function is called from newProject() so all preliminary checks
    have been done. It should be good to go.'''

    projHome            = path
    source              = os.path.join(uc.userConfig['Resources']['templates'], tid + '.zip')

    # Validate template
    if not os.path.isfile(source) :
        terminal('\nError: Template not found: ' + source)
        dieNow()

    # Unzip the template in place to start the new project
    with zipfile.ZipFile(source, 'r') as myzip :
        myzip.extractall(projHome)

    # Peek into the project
    pc = ConfigObj(os.path.join(projHome, 'Config', 'project.conf'))

    pc['ProjectInfo']['projectName']               = pname
    pc['ProjectInfo']['projectCreateDate']         = tStamp()
    pc['ProjectInfo']['projectIDCode']             = pid
    pc.filename                                    = os.path.join(projHome, 'Config', 'project.conf')
    pc.write()

    # Get the media type from the newly placed project for registration
    projectMediaIDCode = pc['ProjectInfo']['projectMediaIDCode']

    # Register the new project
    uc.registerProject(pid, pname, projectMediaIDCode, projHome)



def deleteProject (uc, pid = None) :
    '''Delete a project fromthe Rapuma system registry and from the hard drive.'''

    global local

    # If no pid was given this fails
    if not pid :
        terminal('\nERROR: Project ID code not given or found. delete operation failed.\n')
        return

    # Check if project is registered with Rapuma and get real path and reinit local paths
    if not testForSetting(uc.userConfig, 'Projects', pid) :
        terminal('\nERROR: [' + pid + '] not a valid registered project, cannot continue with delete operation.\n')
        return
    else :
        local = ProjLocal(rapumaHome, userHome, uc.userConfig['Projects'][pid]['projectPath'])

    # Remove references from user rapuma.conf
    if uc.unregisterProject(pid) :
        terminal('Removed [' + pid + '] from user configuration.')
    else :
        terminal('Failed to remove [' + pid + '] from user configuration.')

    # Delete everything in the project path
    if os.path.isdir(local.projHome) :
        shutil.rmtree(local.projHome)
        terminal('Removed project files for [' + pid + '] from hard drive.')
    else :
        terminal('Warning: [' + pid + '] project could not be found, unable to delete project files.')
        return

    # Report the process is done
    terminal('Removal process for [' + pid + '] is completed.')
    return True


def isProject (pid) :
    '''Look up in the user config to see if a project is registered.'''

    if pid in uc.userConfig['Projects'] :
        return True


def isTemplate (tid) :
    '''Check to see if a template exsists in the user's template store area.'''

    try :
        templates = uc.userConfig['Resources']['templates']
        if tid + '.zip' in os.listdir(templates) :
            return True
    except :
        return False


def initProject (pid) :
    '''Initialize an existing project according to the project ID given.'''

    local   = ProjLocal(rapumaHome, userHome, uc.userConfig['Projects'][pid]['projectPath'])
    pc      = ProjConfig(local)
    log     = ProjLog(local, uc)
    if testForSetting(pc.projConfig, 'ProjectInfo', 'projectIDCode') :
        aProject = Project(uc.userConfig, pc.projConfig, local, log)
        return aProject


def accessHtmlHelp () :
    '''Call on the Rapuma basic HTML help system.'''

    # Build the viewer command
    cmds = uc.userConfig['System']['htmlHelpViewerCommand']
    cmds.append(local.rapumaHelpIndexFile)
    # Run the viewer command
    rCode = subprocess.call(cmds)


###############################################################################
############################ Rapuma Demo Functions ############################
###############################################################################


def runExamplePubDemoProject (demoID) :
    '''Run an example demo file to test/demonstrate Rapuma. Any demos have to
    be a part of Rapuma and have been tested for demo purposes.'''

#    import pdb; pdb.set_trace()

    exampleFile     = os.path.join(local.rapumaExamplesFolder, demoID + '.zip')
    demoPath        = os.path.join(local.projHome, demoID)
    demoFile        = os.path.join(demoPath, 'rapumaDemo')
    thisZipFile     = zipfile.ZipFile(exampleFile, 'r')
    if os.path.isfile(exampleFile) :
        thisZipFile.extractall()
        # Set execute permission on scripts
        for r,d,f in os.walk(demoPath):
            for fn in f:
                if not fName(fn)[-1] == '~' :
                    if isExecutable(os.path.join(r, fn)) :
                        makeExecutable(os.path.join(r, fn))

        terminal('Extracted the [' + demoID + '] Rapuma example project.')

    if os.path.isfile(demoFile) :
        os.chdir(demoPath)
        if macroRunner(demoFile) :
            return True
    else :
        terminal('File not found: ' + fName(demoFile))


###############################################################################
########################## Archive Project Functions ##########################
###############################################################################

def backupProject (pid) :
    '''Backup a project. Send the compressed backup file to the user-specified
    backup folder. If none is specified, put the archive in cwd. If a valid
    path is specified, send it to that location. This is a very simplified
    backup so it will only keep one copy in any given location. If another
    copy exists, it will overwrite it.'''

    # Check to see if the pid is valid in the system (it has to be)
    if isProject(pid) :
        projHome = uc.userConfig['Projects'][pid]['projectPath']
    else :
        terminal('\nError: The project ID given is not valid: [' + pid + ']\n')
        dieNow()

    # Set some paths and file names
    backupName = pid + '.zip'
    userBackups = uc.userConfig['Resources']['backups']
    backupTarget = ''
    if os.path.isdir(userBackups) :
        backupTarget = os.path.join(userBackups, backupName)
    else :
        terminal('\nError: User backup storage path not yet configured!\n')
        dieNow()

    zipUpProject(projHome, backupTarget)

    # Finish here
    terminal('Backup for [' + pid + '] created and saved to: ' + backupTarget)


def archiveProject (pid, path = None) :
    '''Archive a project. Send the compressed archive file to the user-specified
    archive folder. If none is specified, put the archive in cwd. If a valid
    path is specified, send it to that location. Like backup, this too will
    overwrite any existing file of the same name. The difference is that this
    will also disable the project so it cannot be accesses by Rapuma. When a
    project is archived, all work should cease on the project.'''

    # Make a private project object just for archiving
    aProject = initProject(pid)
    # Set some paths and file names
    archName = aProject.projectIDCode + '.rapuma'
    userArchives = uc.userConfig['Resources']['archives']
    archTarget = ''
    if path :
        path = resolvePath(path)
        if os.path.isdir(path) :
            archTarget = os.path.join(path, archName)
        else :
            terminal('\nError: The path given is not valid: [' + path + ']\n')
            dieNow()
    elif os.path.isdir(userArchives) :
        archTarget = os.path.join(userArchives, archName)
    elif os.path.isdir(os.path.dirname(aProject.local.projHome)) :
        # Default to the dir just above the project
        archTarget = os.path.dirname(aProject.local.projHome)
    else :
        terminal('\nError: Cannot resolve a path to create the archive file!\n')
        dieNow()

    zipUpProject(aProject.local.projHome, archTarget)

    # Rename the source dir to indicate it was archived
    os.rename(aProject.local.projHome, aProject.local.projHome + '(archived)')

    # Remove references from user rapuma.conf
    if uc.unregisterProject(pid) :
        terminal('Removed [' + pid + '] from user configuration.')
    else :
        terminal('Error: Failed to remove [' + pid + '] from user configuration.')

    # Finish here
    terminal('Archive for [' + pid + '] created and saved to: ' + archTarget)


def zipUpProject (source, target = None) :
    '''Zip up a project and deposit it to target location.'''

    # Do the zip magic here
    # First list some types we don't want to include in our archive
    excludeType = ['.delayed', '.log', '.parlocs', '.pdf']
    # Now list the full file names of any excptions to the above type exclusions
    excludeException = ['rapuma.log']
    root_len = len(source)
    with zipfile.ZipFile(target, 'w', compression=zipfile.ZIP_DEFLATED) as myzip :
        for root, dirs, files in os.walk(source):
            # Chop off the part of the path we do not need to store
            zip_root = os.path.abspath(root)[root_len:]
            for f in files:
                if not f[-1] == '~' :
                    fn, fx = os.path.splitext(f)
                    if not fx in excludeType or f in excludeException :
                        fullpath = os.path.join(root, f)
                        zip_name = os.path.join(zip_root, f)
                        myzip.write(fullpath, zip_name, zipfile.ZIP_DEFLATED)


def restoreArchive (pid, path = None) :
    '''Restore a project from the user specified storage area. If that
    is not set, it will look for the archive (pid.rapuma) in cwd. Use path to
    specify where the project will be restored. Rapuma will register the project
    there. Otherwise, it will restore to cwd and register it there.'''

    # Check to see if the user included the extention
    try :
        pid.split('.')[1] == 'rapuma'
        archName = pid
        pid = pid.split('.')[0]
    except :
        archName = pid + '.rapuma'

    archSource = ''
    archTarget = ''
    userArchives = ''

    # First look for the archive that is to be restored
    # If that can't be found we need to end here
    # We will look in the user archives first, if not
    # found or that isn't set, then cwd. Fail if not in
    # either of those places.
    try :
        if os.path.isdir(uc.userConfig['Resources']['archives']) :
            userArchives = uc.userConfig['Resources']['archives']
            archUser = os.path.join(userArchives, archName)
            archCwd = os.path.join(projHome, archName)
            if os.path.isfile(archUser) :
                archSource = archUser
            elif os.path.isfile(os.path.join(archCwd)) :
                archSource = archCwd
    except :
        terminal('\nError: The path (or name) given is not valid: [' + archSource + ']\n')
        dieNow()

    # Now set the target params
    if path :
        path = resolvePath(path)
        if not os.path.isdir(path) :
            terminal('\nError: The path given is not valid: [' + path + ']\n')
            dieNow()
        else :
            archTarget = os.path.join(path, pid)
    else :
        archTarget = os.path.join(projHome, pid)

    # If we made it this far, extract the archive
    with zipfile.ZipFile(archSource, 'r') as myzip :
        myzip.extractall(archTarget)

    # Permission for executables is lost in the zip, fix it here
    for folder in ['Scripts', os.path.join('Macros', 'User')] :
        fixExecutables(os.path.join(archTarget, folder))

    # Add project to local Rapuma project registry
    # To do this we need to open up the restored project config file
    # and pull out some settings.
    local       = ProjLocal(rapumaHome, userHome, archTarget)
    pc          = ProjConfig(local)
    log         = ProjLog(local, uc)
    aProject    = Project(uc.userConfig, pc.projConfig, local, log)
    uc.registerProject(aProject.projectIDCode, aProject.projectName, aProject.projectMediaIDCode, aProject.local.projHome)

    # Finish here
    terminal('\nRapuma archive [' + pid + '] has been restored to: ' + archTarget + '\n')


def restoreBackup (pid) :
    '''Restore a project from the user specified storage area. If that
    is not set, it will look for the backup (pid.zip) in cwd. Use path to
    specify where the project will be restored. Rapuma will register the project
    there. Otherwise, it will restore to cwd and register it there.'''

    # Check to see if the user included the extention
    try :
        pid.split('.')[1] == 'zip'
        backName = pid
        pid = pid.split('.')[0]
    except :
        backName = pid + '.zip'

    # Check to see if the pid is valid in the system (it has to be)
    if isProject(pid) :
        projHome = uc.userConfig['Projects'][pid]['projectPath']
    else :
        terminal('\nError: The project ID given is not valid: [' + pid + ']\n')
        dieNow()

    # Check to see if the archive exsists
    try :
        if os.path.isdir(uc.userConfig['Resources']['backups']) :
            backup = os.path.join(uc.userConfig['Resources']['backups'], backName)
    except :
        terminal('\nError: The path (or name) given is not valid: [' + backup + ']\n')
        dieNow()

    # Make the exsiting project a temp backup in case something goes wrong
    if os.path.isdir(projHome) :
        # Remove old backup-backup
        if os.path.isdir(projHome + '.bak') :
            shutil.rmtree(projHome + '.bak')
        # Make a fresh copy of the backup-backup
        shutil.copytree(projHome, projHome + '.bak')

    # If we made it this far, extract the archive
    with zipfile.ZipFile(backup, 'r') as myzip :
        myzip.extractall(projHome)

    # Permission for executables is lost in the zip, fix it here
    for folder in ['Scripts', os.path.join('Macros', 'User')] :
        fixExecutables(os.path.join(projHome, folder))

    # Finish here (We will leave the backup-backup in place)
    terminal('\nRapuma backup [' + pid + '] has been restored to: ' + projHome + '\n')


def projectToTemplate (pid, tid) :
    '''Preserve critical project information in a template. The pid is the project
    that the template will be bassed from. The tid will be provided by the user for
    this operation and used to create new projects.'''

    # Set source and target
    projHome            = uc.userConfig['Projects'][pid]['projectPath']
    templateDir         = uc.userConfig['Resources']['templates']
    targetDir           = os.path.join(templateDir, tid)
    target              = os.path.join(templateDir, tid + '.zip')
    source              = projHome

    # Make a temp copy of the project that we can manipulate
    shutil.copytree(source, targetDir)

    # Now make the config files generic for use with any project
    pc = ConfigObj(os.path.join(targetDir, 'Config', 'project.conf'))
    aProject = initProject(pc['ProjectInfo']['projectIDCode'])
    pc['ProjectInfo']['projectName']                = ''
    pc['ProjectInfo']['projectIDCode']              = ''
    pc['ProjectInfo']['projectCreateDate']          = ''
    for s in pc['CompTypes'].keys() :
        pc['CompTypes'][s]['sourcePath']            = ''
    pc['ProjectInfo']['projectCreateDate']          = ''
    for c in pc['Components'].keys() :
        del pc['Components'][c]
    pc.filename                                     = os.path.join(targetDir, 'Config', 'project.conf')
    pc.write()

    # Exclude files
    # Work out from the component type what the settings file names are
    excludeFiles = []
    for cType in pc['CompTypes'].keys() :
        rndr = pc['CompTypes'][cType]['renderer']
        aProject.createManager(cType.lower(), rndr)
        excludeFiles.append(aProject.managers[cType.lower() + '_' + rndr.capitalize()].macLinkFile)
        excludeFiles.append(aProject.managers[cType.lower() + '_' + rndr.capitalize()].setFileName)

    # Include file types
    includeType = ['sty', 'ttf', 'conf', 'xml', 'tec', 'tex']

    # Zip it up using the above params
    root_len = len(targetDir)
    with zipfile.ZipFile(target, 'w', compression=zipfile.ZIP_DEFLATED) as myzip :
        for root, dirs, files in os.walk(targetDir):
            # Chop off the part of the path we do not need to store
            zip_root = os.path.abspath(root)[root_len:]
            for f in files:
                if f[-1] == '~' :
                    continue
                elif f in excludeFiles :
                    continue
                elif f.rfind('.') != -1 and f[f.rfind('.')+1:] in includeType :
                    fullpath = os.path.join(root, f)
                    zip_name = os.path.join(zip_root, f)
                    myzip.write(fullpath, zip_name, zipfile.ZIP_DEFLATED)

    # Remove the temp project dir we made
    shutil.rmtree(targetDir)
    terminal('\nCompleted creating template: ' + fName(target) + '\n')


def makeProjectScripts (uc, pid) :
    '''Create helper scripts for a project to help with repetitive tasks.
    If any scripts are present with the same name they will be overwritten.
    Note: This is only for temporary use due to the lack of an interface at
    this time (20121217). It assumes the cType is usfm which, at some point
    may not be the case.'''

    projHome            = uc.userConfig['Projects'][pid]['projectPath']
    local               = ProjLocal(rapumaHome, userHome, projHome)
    cType = 'usfm'
    if not os.path.isdir(local.projScriptsFolder) :
        os.mkdir(local.projScriptsFolder)
    for script in ['addBible', 'addNT', 'addOT', 'archive', 'backup', 'compare', 'edit', \
                     'export', 'render', 'template', 'update', 'view', 'watermarkOff', 'watermarkOn'] :
        fullFile = os.path.join(local.projScriptsFolder, script)
        with codecs.open(fullFile, "w", encoding='utf_8') as writeObject :
            writeObject.write('#!/bin/sh\n\n')
            writeObject.write('# Rapuma automation script: ' + script + '\n\n')
            if script == 'addBible' :
                writeObject.write('rapuma component ' + pid + ' ' + cType + ' Bible -a -s $1 -i "gen exo lev num deu jos jdg rut 1sa 2sa 1ki 2ki 1ch 2ch ezr neh est job psa pro ecc sng isa jer lam ezk dan hos jol amo oba jon mic nam hab zep hag zec mal mat mrk luk jhn act rom 1co 2co gal eph php col 1th 2th 1ti 2ti tit phm heb jas 1pe 2pe 1jn 2jn 3jn jud rev"\n\n')
            elif script == 'addNT' :
                writeObject.write('rapuma component ' + pid + ' ' + cType + ' NT -a -s $1 -i "mat mrk luk jhn act rom 1co 2co gal eph php col 1th 2th 1ti 2ti tit phm heb jas 1pe 2pe 1jn 2jn 3jn jud rev"\n\n')
            elif script == 'addOT' :
                writeObject.write('rapuma component ' + pid + ' ' + cType + ' OT -a -s $1 -i "gen exo lev num deu jos jdg rut 1sa 2sa 1ki 2ki 1ch 2ch ezr neh est job psa pro ecc sng isa jer lam ezk dan hos jol amo oba jon mic nam hab zep hag zec mal"\n\n')
            elif script == 'archive' :
                writeObject.write('rapuma preserve ' + pid + ' -a \n\n')
            elif script == 'backup' :
                writeObject.write('rapuma preserve ' + pid + ' -b \n\n')
            elif script == 'compare' :
                writeObject.write('rapuma component ' + pid + ' ' + cType + ' $1 -c \n\n')
            elif script == 'edit' :
                writeObject.write('rapuma edit ' + pid + ' -c $1 -g -s\n\n')
            elif script == 'export' :
                writeObject.write('rapuma export ' + pid + ' ' + cType + ' $1 -e -f  \n\n')
            elif script == 'render' :
                writeObject.write('rapuma component ' + pid + ' ' + cType + ' $1 -e -f \n\n')
            elif script == 'template' :
                writeObject.write('rapuma preserve ' + pid + ' -t $1 \n\n')
            elif script == 'update' :
                writeObject.write('rapuma component ' + pid + ' ' + cType + ' $1 -u -f \n\n')
            elif script == 'view' :
                writeObject.write('rapuma component ' + pid + ' ' + cType + ' $1 -e \n\n')
            elif script == 'watermarkOff' :
                writeObject.write('rapuma settings ' + pid + ' project Managers/usfm_Illustration useWatermark False \n\n')
            elif script == 'watermarkOn' :
                writeObject.write('rapuma settings ' + pid + ' project Managers/usfm_Illustration useWatermark True \n\n')

        # Make the script executable
        makeExecutable(fullFile)

    terminal('\nCompleted creating/recreating helper scripts.\n')


###############################################################################
########################### Rapuma Command Center #############################
###############################################################################

# All command options must contain a project ID (-i). That is required. If one
# is not listed then the incoming command is either considered malformed or
# incomplete. If there is a way to figure out what the user might be needing
# the help system will be called. Otherwise, Rapuma will quite.

# The argument handler
def userArguments (args) :
    '''Process incoming command arguments.'''

    # Extra help access
    if sys.argv[1].lower() == 'help' :
        if args['about'] :
            terminal('\n' + systemName + ' version ' + systemVersion + '\n')
            terminal('About: ' + systemAbout + '\n')
            return
        if args['basic'] :
            accessHtmlHelp()
            return

    # Test project ID, intercept if it is an example demo
    if sys.argv[1].lower() != 'project' :
        if sys.argv[1].lower() == 'example' :
            runExamplePubDemoProject(args['demo_id'])
        elif sys.argv[1].lower() == 'preserve' :
            pass
#            restoreArchive(args['project_id'], args['path'])
        elif not isProject(args['project_id']) :
            sys.exit('\nERROR: Project ID given is not valid! Process halted.\n')
        else :
            # Now setup the project and look for and test the component type if needed
            aProject = initProject(args['project_id'])
            exclude = ['settings', 'locking', 'install', 'macro', 'archive', 'edit']
            if not sys.argv[1].lower() in exclude :
                if not aProject.isComponentType(args['component_type']) :
                    if not aProject.addComponentType(args['component_type']) :
                        sys.exit('\nERROR: Not able to add component type: ' + args['component_type'] + ' Process halted!\n')

    # Project level commands
    if sys.argv[1].lower() == 'project' :
        # Remove an exsisting project
        if args['remove'] :
            deleteProject(uc, args['project_id'])
        # Create/recreate helper scripts
        elif args['scripts'] :
            makeProjectScripts(uc, args['project_id'])
        # Creating a new project
        elif args['add'] :
            if args['path'] :
                # If a project folder is given (other than CWD) We need to
                # resolve it and pass it on to proj config settings (internal)
                customLocal = resolvePath(args['path'])
                if not os.path.isdir(customLocal) :
                    sys.exit('\nERROR: Cannot resolve the given path. Process halting.\n')
                else :
                    projFolder = os.path.join(customLocal, args['project_id'])
            else :
                # With no different project location given we will make sure
                # we use the default projHome set when the script started.
                projFolder = os.path.join(projHome, args['project_id'])
            # Create the project
            local   = ProjLocal(rapumaHome, userHome, projFolder)
            pc      = ProjConfig(local)
            newProject(uc, pc, args['project_id'], args['name'], args['template'], args['media'])
            # Create helper scripts if desired
            if str2bool(uc.userConfig['System']['autoHelperScripts']) :
                makeProjectScripts(uc, args['project_id'])

    # Component level commands
    elif sys.argv[1].lower() == 'component' :
        if not args['component_name'] :
            sys.exit('\nERROR: Must provide a component name when adding a new component. Process halted!\n')
        # Add a new component
        if args['add'] :
            if not args['id_list'] :
                sys.exit('\nERROR: Must provide a list (-i) of one or more valid component IDs (sub-components) when adding a component. Process halted!\n')
            else :
                aProject.addComponent(args['component_type'], args['component_name'], args['id_list'], args['source'], args['force'])
        # Delete a component
        elif args['update'] :
            # Update a component, --source is optional but if given it will
            # overwrite the current setting.
            aProject.updateComponent(args['component_name'], args['source'])
        elif args['remove'] :
            # If -f is used, we delete all the files with this cid
            aProject.removeComponent(args['component_name'], args['force'])
        # Render vs. view command is just a matter of forcing the component
        # to be rendered if render is selected by the user. Otherwise, if
        # only view is requested, if force is set to False and the component
        # will not be rerendered if it already exsists.
        elif args['execute'] :
            aProject.renderComponent(args['component_type'], args['component_name'], args['force'])
        elif args['validate'] :
            aProject.createManager(args['component_type'], 'text')
            aProject.managers[args['component_type'] + '_Text'].testCompTextFile(args['path'])
        elif args['compare'] :
            aProject.compareComponent(args['component_name'])

    # Font level commands
    elif sys.argv[1].lower() == 'font' :
        aProject.createManager(args['component_type'], 'font')
        font = aProject.managers[args['component_type'] + '_Font'].checkForSubFont(args['font_id'])
        manager = args['component_type'] + '_Font'
        if args['component_type'] :
            if args['add'] :
                # Physically install the font files
                aProject.managers[manager].installFont(font, args['force'])
            elif args['remove'] :
                aProject.managers[manager].removeFont(args['component_type'], font, args['force'])
            elif args['main'] :
                aProject.managers[manager].setPrimaryFont(args['component_type'].capitalize(), font, args['force'])
        else :
            sys.exit('\nERROR: Component type ID is missing from command argument. Process halted!\n')

    # Style level commands
    elif sys.argv[1].lower() == 'style' :
        aProject.createManager(args['component_type'], 'style')
        manager = args['component_type'] + '_Style'
        if args['style_type'] :
            if args['add'] :
                aProject.managers[manager].addStyleFile(args['style_type'], args['path'], args['force'])
            elif args['remove'] :
                aProject.managers[manager].removeStyleFile(args['Style_type'], args['force'])
            elif args['validate'] :
                # In this context we want to stop if an error is found and report it
                # Passing true to validateStyleFile will do that
                aProject.managers[manager].testStyleFile(args['path'])
        else :
            if args['style_type'].lower() not in ['main', 'custom'] :
                sys.exit('\nERROR: Style file type (-t) is either missing or incorrect.\n')

    # Illustration level commands
    elif sys.argv[1].lower() == 'illustration' :
        aProject.createManager(args['component_type'], 'illustration')
        manager = args['component_type'] + '_Illustration'
        if args['add'] :
            aProject.managers[manager].installIllustrationFile(args['add'], args['path'], args['force'])
        elif args['watermark'] :
            aProject.managers[manager].installWatermarkFile(args['watermark'], args['path'], args['force'])
        elif args['remove'] :
            aProject.managers[manager].removeIllustrationFile(args['remove'])

    # Preprocessing commands
    elif sys.argv[1].lower() == 'preprocess' :
        # Manage preprocess scripts for a component type. This is an automated 
        # function. If desired a script will be installed and the user will manually
        # edit it to their needs. When working text is installed, if there is a
        # preprocess registered for that component type, the process will be run
        # on the incoming text. This set of commands facilitating installing the
        # the default script or removing the installed script, if force is used.

        # Install a custom or a default preprocess script, force to overwrite what is there
        if args['add'] :
            aProject.installPreprocess(args['component_type'], args['force'])
        # Disconnect a preprocessing script from the component type (this does not physically remove it)
        elif args['remove'] :
            aProject.removePreprocess(args['component_type'], args['force'])

    # Post processing commands
    elif sys.argv[1].lower() == 'postprocess' :
        # Run a post process command on a component or component type
        # Because we can lock at all levels, there is no need for (-f --force)
        # to be used here. If a component name is given it will only run on that
        # component which includes all listed sub-components. Otherwise, all 
        # components of the specified type will be acted on by the postprocess.
        if args['execute'] :
            if not args['script'] :
                sys.exit('\nERROR: No script was specified, Please use -s to specify a script to execute.\n')
            elif not args['component_name'] :
                sys.exit('\nERROR: No component ID was specified, Please use -c to specify a valid component (group) ID to run this post process script on.\n')
            else :
                aProject.runProcessScript(args['component_name'], args['script'])
        # Install a custom or a default post process script, force to overwrite what is there
        elif args['add'] :
            filePath = ''
            if args['path'] :
                filePath = resolvePath(args['path'])
                if not os.path.isfile(filePath) :
                    sys.exit('\nERROR: The following path does not appear to be valid: ' + filePath + '\n')
            aProject.installPostProcess(args['component_type'], filePath, args['force'])
        # Disconnect a post process script from the component type (This does not
        # physically remove it unless -f is used.)
        elif args['remove'] :
            aProject.removePostProcess(args['component_type'], force)

    # Setting manipulation commands
    elif sys.argv[1].lower() == 'settings' :
        aProject = initProject(args['project_id'])
        if args['configuration'] :
            if (args['section'] or args['key'] or args['value']) :
                aProject.changeConfigSetting(args['configuration'], args['section'], args['key'], args['value'])
            else :
                sys.exit('\nERROR: Must provide a section, key and value. Process halted!\n')
        else :
            sys.exit('\nERROR: Configuration name is missing from command argument. Process halted!\n')

    # Locking commands
    elif sys.argv[1].lower() == 'locking' :
        aProject = initProject(args['project_id'])
        # Lock component
        if args['lock'] :
            aProject.lockUnlock(args['component_name'], True, args['force'])
        # Unlock component
        elif args['unlock'] :
            aProject.lockUnlock(args['component_name'], False, args['force'])

    # Exporting commands
    elif sys.argv[1].lower() == 'export' :
        # Check further for required args
        if not args['component_name'] :
            sys.exit('\nERROR: Component ID is missing from command argument. Process halted!\n')
        else :
            aProject.createManager(args['component_type'], 'text')
        # Execute an export
        if args['execute'] :
            aProject.export(args['component_type'], args['component_name'], args['path'], args['script'], args['bundle'], args['force'])

    # Install file commands
    elif sys.argv[1].lower() == 'install' :
        # Check further for required args
        if not args['file'] :
            sys.exit('\nERROR: File was not specified in the command argument. Process halted!\n')
        elif not args['path'] :
            sys.exit('\nERROR: Path to the project folder where file is to be installed. Process halted!\n')
        else :
            # Install the file
            aProject.installFile(args['file'], args['path'], args['force'])

    # User Macro commands
    elif sys.argv[1].lower() == 'macro' :
        # Check further for required args
        if not args['name'] :
            sys.exit('\nERROR: Macro was not specified in the command argument. Process halted!\n')
        if args['add'] :
            aProject.addMacro(args['name'], args['command'], args['path'], args['force'])
        elif args['execute'] :
            aProject.runMacro(args['name'])
        else :
            # Bad command
            sys.exit('\nERROR: Command [' + sys.argv[3] + '] not recognized. Process halted!\n')

    # The demo commands were intercepted at the begining

    # Commands to preserve project data. (Check PID and if necessary TID before passing it on)
    elif sys.argv[1].lower() == 'preserve' :
        if args['archive'] and args['restore'] :
            restoreArchive(args['project_id'], args['path'])
        elif args['backup'] and args['restore'] :
            if not isProject(args['project_id']) :
                sys.exit('\nERROR: Project ID given is not valid! Process halted.\n')
            restoreBackup(args['project_id'])
        elif args['archive'] :
            if not isProject(args['project_id']) :
                sys.exit('\nERROR: Project ID given is not valid! Process halted.\n')
            archiveProject(args['project_id'], args['path'])
        elif args['backup'] :
            if not isProject(args['project_id']) :
                sys.exit('\nERROR: Project ID given is not valid! Process halted.\n')
            backupProject(args['project_id'])
        elif args['template'] :
            if not isProject(args['project_id']) :
                sys.exit('\nERROR: Project ID given is not valid! Process halted.\n')
            if isTemplate(args['template']) :
                sys.exit('\nError: This template [' + args['template'] + '] already exsists. Process halted.\n')
            projectToTemplate(args['project_id'], args['template'])
        else :
            # Bad command
            sys.exit('\nERROR: Must provide -a or -b with -c or -r with optional -p. Process halted!\n')

    # Commands for editing project files
    elif sys.argv[1].lower() == 'edit' :
            aProject.edit(args['component'], args['global'], args['system'])

    # Dummy place holder for 'example' which as processed above
    elif sys.argv[1].lower() == 'example' :
        pass

    # Totally lost
    else:
        sys.exit('\nERROR: Command not recognized: [' + sys.argv[1] + ']\n')

    # During a process, a number of log entries will be made and written out.
    # Over time the log file could get very large. To control the size, there
    # is a setting in the user config file that limits the number of lines in
    # the log file. The default is 1000 but it can be adjusted if needed. The
    # following call here will trim the log file to its specified limit. This
    # is done here as there should be no further operations done at this point.
    # Note: This will not work with "project" commands (aProject is not declaired)
    # To get around that we will use a 'try' statement to prevent confusing errors.
    try :
        if not sys.argv[1].lower() == 'project' :
            if os.path.isfile(aProject.local.projLogFile) :
                trimLog(aProject.local.projLogFile, uc.userConfig['System']['projLogLineLimit'])
    except :
        pass

    # Look for an error log file and notify the user if one is found that there
    # were errors in the process. This might have failed because we loose our 
    # project object some times. For now, we'll put a 'try' around it.
    try :
        if not sys.argv[1].lower() == 'project' :
            if os.path.isfile(aProject.local.projErrorLogFile) :
                terminal('\n\t*** ERRORS OCCURRED. PLEASE CHECK ERROR LOG ***\n')
    except :
        pass

###############################################################################
############################### Argparser Setup ###############################
###############################################################################

# We will try to maintain a common syntax in all the subparsers Some common
# argument options are:
#   -a = add something
#   -r = remove something
#   -e = execute something
#   -f = force the execution of something
#   -p = path (and file name) of something

# Setup the arg parser
parser = argparse.ArgumentParser(description=systemName)
subparsers = parser.add_subparsers(help='sub-command help')

# Add help subprocess arguments
helpCommand = subparsers.add_parser('help', help='General system help')

# Add main arguments (first postion options)
parser.add_argument('-a', '--about', action='store_true', help = 'Information about Rapuma')
parser.add_argument('-b', '--basic', action='store_true', help = 'Basic Rapuma help (in HTML)')

# Add project subprocess arguments
projCommand = subparsers.add_parser('project', help='General project management commands help')
projCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
projCommand.add_argument('-a', '--add', action='store_true', help='Add a new publishing project on this system.')
projCommand.add_argument('-r', '--remove', action='store_true', help='Remove a project permanently from the system. This will do just what is says. Be careful!')
projCommand.add_argument('-t', '--template', help='Specify a template to base a new project on. If not specified, you must use -m to specify a media type.')
projCommand.add_argument('-p', '--path', help='Path to the project home folder if the current working directory is not the actual target. This can be used when adding a project.')
projCommand.add_argument('-m', '--media', help='If creating a new project, give a valid project media type code.')
projCommand.add_argument('-n', '--name', help='If creating a new project, give a human readable name to describe this project.')
projCommand.add_argument('-s', '--scripts', action='store_true', help='Create/recreate helper scripts that will help with various repetitive tasks.')

# Add component subprocess arguments
compCommand = subparsers.add_parser('component', help='General project component management commands help')
compCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
compCommand.add_argument('component_type', help='The component type is needed for creating a new component.')
compCommand.add_argument('component_name', help='The component name, required for creating a new component or any actions to be done to it.')
compCommand.add_argument('-a', '--add', action='store_true', help='Add a new component to this project.')
compCommand.add_argument('-r', '--remove', action='store_true', help='remove an existing component from this project.')
compCommand.add_argument('-s', '--source', help='Provide a valid path to where the source file is found. (Used for adding/updating components, one source path per component type allowed.)')
compCommand.add_argument('-i', '--id_list', help='Use this if this is a group component. This is a list of components to be in this group. The list must be enclosed by quotes and have only a space between ID codes, e.g. \"aaa bbb ccc\".')
compCommand.add_argument('-f', '--force', action='store_true', help='Force an action if overriding a default non-action is needed.')
compCommand.add_argument('-e', '--execute', action='store_true', help='Execute the render process for a specific component in this project.')
compCommand.add_argument('-v', '--validate', action='store_true', help='[NOT WORKING!] Validate a component file.')
compCommand.add_argument('-c', '--compare', action='store_true', help='[NOT WORKING!] Compare a component with its source.')
compCommand.add_argument('-p', '--path', help='Provide a valid path and file name if a specific file is to be tested.')
compCommand.add_argument('-u', '--update', action='store_true', help='Update a component. If -s (source) is used a new component source path will be recorded as well.')

# Add font subprocess arguments
fontCommand = subparsers.add_parser('font', help='General font handling commands help')
fontCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
fontCommand.add_argument('component_type', help='Specify the component type. This is required for all font functions.')
fontCommand.add_argument('font_id', help='The font family name ID. The ID given has to be a valid system font.')
fontCommand.add_argument('-a', '--add', action='store_true', help='Add a new font for a specific comonent type.')
fontCommand.add_argument('-r', '--remove', action='store_true', help='Remove the font of a specified ID from this project.')
fontCommand.add_argument('-f', '--force', action='store_true', help='Force the addition or removal of a font from the system even if it is used by other components.')
fontCommand.add_argument('-m', '--main', action='store_true', help='Set, the specified (valid system) font to be the main (primary) font for this component type.')

# Add style subprocess arguments
styleCommand = subparsers.add_parser('style', help='General component style handling commands help')
styleCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
styleCommand.add_argument('component_type', help='The component type is needed when adding a style for this type of component. (This is a required positional argument.)')
styleCommand.add_argument('style_type', help='The type of style file this is. There are two acceptable types, \"main\" and \"custom\". (This is a required positional argument.)')
styleCommand.add_argument('-a', '--add', action='store_true', help='Add a new style for a specific comonent type.')
styleCommand.add_argument('-r', '--remove', action='store_true', help='Remove a style file for this component type.')
styleCommand.add_argument('-p', '--path', help='Provide a valid path and file name if a specific style file is required or to be auto-generated. Otherwise, a default will be used.')
styleCommand.add_argument('-f', '--force', action='store_true', help='Force the addition or removal of a style from this component.')
styleCommand.add_argument('-v', '--validate', action='store_true', help='[NOT IMPLEMENTED] Validate a style file. Must use -p to provide a path and file name.')

# Add illustration subprocess arguments
illustrationCommand = subparsers.add_parser('illustration', help='General project illustration handling commands help')
illustrationCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
illustrationCommand.add_argument('component_type', help='The component type is needed when adding an illustration to a project. (This is a required positional argument.)')
illustrationCommand.add_argument('-a', '--add', help='Provide a file name for the illustration you wish to add to the project.')
illustrationCommand.add_argument('-w', '--watermark', help='Provide a file name for an illustration, normally a PDF file, you wish to add to the project for use as a page watermark.')
illustrationCommand.add_argument('-r', '--remove', help='Provide a file name for an illustration you wish to remove from the project.')
illustrationCommand.add_argument('-p', '--path', help='If the illustration is in a unknown location, provide a valid path to where the illustration that is specified with -a.')
illustrationCommand.add_argument('-f', '--force', action='store_true', help='Force (overwrite) an illustration of the same name in the specified project.')

# Add text preprocessing subprocess arguments
preprocessCommand = subparsers.add_parser('preprocess', help='General settings for handling component preprocessing commands.')
preprocessCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
preprocessCommand.add_argument('component_type', help='Specify the component type. This is required for a preprocess operation.')
preprocessCommand.add_argument('-a', '--add', action='store_true', help='Install the default preprocess script into the project scripts folder. It will fail if one already exsists, unless force (-f) is used to overwrite it.')
preprocessCommand.add_argument('-r', '--remove', action='store_true', help='Disconnect a preprocess from the component type. This does not remove the actual script from the project, unless force (-f) is used. Then the script will be deleted.')
preprocessCommand.add_argument('-f', '--force', action='store_true', help='Force a preprocess script to be reset to default or removed.')

# Add text post processing subprocess arguments
postprocessCommand = subparsers.add_parser('postprocess', help='General settings for handling component post processing commands.')
postprocessCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
postprocessCommand.add_argument('component_type', help='Specify the component type. This is required for all post process operations.')
postprocessCommand.add_argument('-a', '--add', action='store_true', help='Install a post process into the project scripts folder. If you do not specify a process with path (-p) a default process script will be installed.')
postprocessCommand.add_argument('-r', '--remove', action='store_true', help='Disconnect a post process from the component type. This does not remove the actual script from the project unless force (-f) is used.')
postprocessCommand.add_argument('-f', '--force', action='store_true', help='Force a post process script to be updated, replaced or brought back to default condition for this component type.')
postprocessCommand.add_argument('-c', '--component_name', help='Give a (registered) component name to execute a post process script on all valid sub-components associated with that component.')
postprocessCommand.add_argument('-p', '--path', help='A valid path and file name of a specific post process script to be installed.')
postprocessCommand.add_argument('-s', '--script', help='Specify a script for executing. This is required for the -e command.')
postprocessCommand.add_argument('-e', '--execute', action='store_true', help='Execute a post process script. If a valid component ID is not specified, it will run on all components of the type it is a part of.')

# Add settings subprocess arguments
settingsCommand = subparsers.add_parser('settings', help='General settings handling commands help')
settingsCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
settingsCommand.add_argument('configuration', help='The configuration set that the target setting is from.')
settingsCommand.add_argument('section', help='The section path to the key/value pare to be changed. Multiple sections are separated by \'/\'.')
settingsCommand.add_argument('key', help='The key which has the value to be changed.')
settingsCommand.add_argument('value', help='A new value to add or change to the specified key.')

# Add Project Locking subprocess arguments
lockCommand = subparsers.add_parser('locking', help='Commands for locking down projects or parts of a project. This will prevent accidental processing.')
lockCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
lockCommand.add_argument('component_name', help='A specific component name required for locking or unlocking.')
lockCommand.add_argument('-l', '--lock', action='store_true', help='Lock a project or component. If a component or component type are not specified, the entire project will be locked and not available to any processes.')
lockCommand.add_argument('-u', '--unlock', action='store_true', help='Unlock a project or component. This is hierarchical. If the entire project is locked, unlocking component types or components cannot take place until the entire project is unlocked.')
lockCommand.add_argument('-f', '--force', action='store_true', help='Force lock/unlock of any subcomponents that belong to the specified component.')

# Add Project exporting subprocess arguments
exportCommand = subparsers.add_parser('export', help='Commands for exporting data from a project for a variety of purposes.')
exportCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
exportCommand.add_argument('component_type', help='Component ID (a positional argument required for all actions with this subprocess)')
exportCommand.add_argument('component_name', help='Specify a valid component name to be exported. The sub-components associated with that name will be exported.')
exportCommand.add_argument('-p', '--path', help='Optional - This will specify a path/folder where the exported data is output to. Default is to create an export folder in the source folder and output to that.')
exportCommand.add_argument('-s', '--script', help='Optional - The name of an installed post process script to be used in the export process. Default will just blind copy the working text to the export folder.')
exportCommand.add_argument('-e', '--execute', action='store_true', help='Execute an export operation.')
exportCommand.add_argument('-b', '--bundle', action='store_true', help='Bundle the exported file(s) into a single compressed file.')
exportCommand.add_argument('-f', '--force', action='store_true', help='Force overwrite on exsisting file(s) of the same name.')

# Add Project install subprocess arguments
installCommand = subparsers.add_parser('install', help='Commands for manually installing files into a project for a variety of purposes.')
installCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
installCommand.add_argument('file', help='The file to be installed, relitive paths are allowed.')
installCommand.add_argument('path', help='Specify the path to the project folder where the file goes.')
installCommand.add_argument('-f', '--force', action='store_true', help='Force overwrite on exsisting file.')

# Add Macro subprocess arguments
macroCommand = subparsers.add_parser('macro', help='Commands for creating user macros and installing the files into a project for a variety of purposes.')
macroCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
macroCommand.add_argument('name', help='The name of the macro to create or call.')
macroCommand.add_argument('-a', '--add', action='store_true', help='Add/install the specified macro into the Macros/user folder.')
macroCommand.add_argument('-e', '--execute', action='store_true', help='Execute an installed macro.')
macroCommand.add_argument('-c', '--command', help='Add a list (\'[rapuma 1, rapuma 2, etc.]\') of Rapuma commands to a macro file. This would be used along with the -a command.')
macroCommand.add_argument('-p', '--path', help='If the macro you are adding already exsists, specify the path to it and include the name of the file. This would be used with the -a command and instead of -c command.')
macroCommand.add_argument('-f', '--force', action='store_true', help='Force overwrite on exsisting macro file.')

# Add Project example subprocess arguments
exampleCommand = subparsers.add_parser('example', help='Commands for running simple project examples.')
exampleCommand.add_argument('demo_id', help=' A project/demo ID for the example you wish to run. This is for canned demos so they must exsist. You cannot just make something up.')

# Add Project archive subprocess arguments
archiveCommand = subparsers.add_parser('preserve', help='Commands for preserving project data projects and project data.')
archiveCommand.add_argument('project_id', help=' A project ID for the project you wish to archive, backup or make template from. If a project is being made from a template, the project ID must not conflict with any others on the system.')
archiveCommand.add_argument('-a', '--archive', action='store_true', help='Archive the specified project to the archive storage area specified in the user configuration. If nothing is specified, the default is the directory where the project is found.')
archiveCommand.add_argument('-b', '--backup', action='store_true', help='Backup the specified project to the backup storage area specified in the user configuration. If nothing is specified, the default is the directory where the project is found.')
archiveCommand.add_argument('-t', '--template', help='Supply a template ID for creating a template of a specified project. It will save it to the template storage area specified in the user configuration. This must be a unique ID when creating a new template.')
archiveCommand.add_argument('-r', '--restore', action='store_true', help='Restore the specified project from the archive or backup storage area specified in the user configuration to the current working directory, unless a path (-p) is specified.')
archiveCommand.add_argument('-p', '--path', help='Specify the path to where you wish add the archive to, or restore from. If no path is given, the default is the current working directory for both sides of the operation (from -> to).')

# Add Project edit subprocess arguments
editCommand = subparsers.add_parser('edit', help='Commands for editing project files.')
editCommand.add_argument('project_id', help=' A project ID for the project you wish to edit files in.')
editCommand.add_argument('-c', '--component', help='Edit files related to the specified component.')
editCommand.add_argument('-g', '--global', action='store_true', help='Edit global project files, including configuration, macro and style files.')
editCommand.add_argument('-s', '--system', action='store_true', help='Edit system files, like the Rapuma configuration file.')

# Send the collected arguments to the handler
userArguments(vars(parser.parse_args()))


###############################################################################
########################### Close out the session #############################
###############################################################################

# In case there are any Canadians using this, politely say good bye
if not sys.argv[1].lower() == 'example' :
    terminal('\n\t\tThank you, please come again!\n')













#!/usr/bin/python
# -*- coding: utf-8 -*-

# By Dennis Drescher (dennis_drescher at sil.org


###############################################################################
######################### Description/Documentation ###########################
###############################################################################

# One script to rule them all.  This is the main Rapuma engine script.
# This script will drive all processes and keep track of what happens in the
# project log in each respective project.


###############################################################################
################################ Initialize Rapuma ###############################
###############################################################################
# Firstly, import all the standard Python modules we need for this process and
# set the base path

import os, sys, timeit, datetime
from functools          import partial

startTime = timeit.default_timer()

# Set the Rapuma base program paths
rapumaHome = os.environ.get('RAPUMA_BASE')
sysHome = os.environ.get('HOME')
if not rapumaHome :
    for t in (os.path.join(sysHome, '.local'), '/usr/local', '/usr') :
        rapumaHome = os.path.join(t, 'share', 'rapuma')
        if os.path.exists(os.path.join(rapumaHome, 'resources')) :
            os.environ['RAPUMA_BASE'] = rapumaHome
            break

# Set the user environment path
userHome = os.environ.get('RAPUMA_USER')
if not userHome :
    userHome = os.path.join(sysHome, '.config', 'rapuma')
    os.environ['RAPUMA_USER'] = userHome

# Set the (potential) project home
projHome = os.getcwd()

# Load standard Python modules
import codecs, argparse
#from datetime import *
#from configobj import ConfigObj

# Load the local classes
from rapuma.core.proj_local             import ProjLocal
from rapuma.core.proj_log               import ProjLog
from rapuma.core.user_config            import UserConfig
from rapuma.core.proj_backup            import ProjBackup
from rapuma.core.proj_binding           import ProjBinding
from rapuma.core.proj_compare           import ProjCompare
from rapuma.core.proj_process           import ProjProcess
from rapuma.core.tools                  import Tools, ToolsGroup
from rapuma.project.proj_config         import ProjConfig
from rapuma.project.proj_setup          import ProjSetup
from rapuma.project.proj_commander      import ProjCommander
from rapuma.project.proj_font           import ProjFont
from rapuma.project.proj_hyphenation    import ProjHyphenation
from rapuma.project.proj_maps           import ProjMaps
from rapuma.project.proj_toc            import ProjToc
from rapuma.project.proj_background     import ProjBackground
from rapuma.manager.project             import Project

# Instantiate User config class
uc              = UserConfig()
tools           = Tools()

# Set some global vars
systemName      = 'Rapuma (Rapid Publication Manager)'
systemAbout     = 'Rapuma is a publishing management system written by the friendly \
                    developers at Payap University\'s Linguistics Institute (Text Unit). \
                    Rapuma stands for Rapid Publication Manager. It is currently being \
                    deployed in MSEAG and is under heavy development. Anyone wanting to \
                    try this system should be warned that it may not work in their context. \
                    However, the underlying principals of the system should work in any long \
                    document publishing environment. Therefore the package should be evaluated \
                    with that in mind. We welcome input and participation in this project. It \
                    is our hope it will be able to serve more than just MSEAG. For questions \
                    or more information please write: dennis_drescher@sil.org.'
systemVersion   = '0.6.r716'
local           = None

# Give a welcome message
tools.terminal('\n\t\tWelcome to ' + systemName)
tools.terminal('\n\t\t\tVersion ' + systemVersion + '\n')

###########################################################################
########################### Rapuma Functions ##############################
###########################################################################

def checkCreatorVersion (pid, projConfig, systemVersion) :
    '''Keep track of the version of Rapuma used in the current project.'''

    if not projConfig['ProjectInfo'].has_key('projectCreatorVersion') :
        projConfig['ProjectInfo']['projectCreatorVersion'] = systemVersion
        tools.writeConfFile(projConfig)

    if projConfig['ProjectInfo']['projectCreatorVersion'] != systemVersion :
        projConfig['ProjectInfo']['projectCreatorVersion'] = systemVersion
        tools.writeConfFile(projConfig)
        # Now update the scripts if that is needed
        ProjCommander(pid).updateScripts()


def hasValidSourcePath (pid, gid, csid) :
    '''Check if there is one, see if it is valid.'''

#    import pdb; pdb.set_trace()

    try :
        path = uc.userConfig['Projects'][pid][csid + '_sourcePath']
        return os.path.isdir(tools.resolvePath(path))
    except :
        return False


def isTemplate (tid) :
    '''Check to see if a template exsists in the user's template store area.'''

    try :
        templates = uc.userConfig['Resources']['templates']
        if tid + '.zip' in os.listdir(templates) :
            return True
    except :
        return False


def trimLog () :
    '''Trim a log file.  This will take an existing log file and
    trim it to the amount specified in the system file.'''

    # Of course this isn't needed if there isn't even a log file
    if local and os.path.isfile(local.projLogFile) :

        limit = int(uc.userConfig['System']['projLogLineLimit'])

        # Read in the existing log file
        readObject = codecs.open(local.projLogFile, "r", encoding='utf_8')
        lines = readObject.readlines()
        readObject.close()

        # Process only if we have enough lines
        if len(lines) > limit :
            writeObject = codecs.open(local.projLogFile, "w", encoding='utf_8')
            lineCount = 0
            for line in lines :
                if limit > lineCount :
                    writeObject.write(line)
                    lineCount +=1

            writeObject.close()


###############################################################################
########################### Rapuma Command Center #############################
###############################################################################

# All command options must contain a project ID (-i). That is required. If one
# is not listed then the incoming command is either considered malformed or
# incomplete. If there is a way to figure out what the user might be needing
# the help system will be called. Otherwise, Rapuma will quite.

# The argument handler
def userArguments (args) :
    '''Process incoming command arguments.'''

#    import pdb; pdb.set_trace()

    # Common error handlers
    def cmdError (cmd, cmdType) :
        sys.exit('\nERROR: The ' + cmd + ' command is not valid to use with ' + cmdType + '. Process halting.\n')

    def cTypeError (cType) :
        sys.exit('\nERROR: The ' + cType + ' component type is not recognized. Process halting.\n')

    # Pre-command process: Extra help access
    if sys.argv[1].lower() == 'help' :
        if args.about :
            tools.terminal('\n' + systemName + ' version ' + systemVersion + '\n')
            tools.terminal('About: ' + systemAbout + '\n')
            return

    ##### SYSTEM
    # Pre-command process: System level commands
    if sys.argv[1].lower() == 'system' :
        if args.user_name :
            uc.setSystemSettings('userName', args.user_name)
        elif args.resources :
            uc.setSystemSettings('resources', args.resources)
    # Test for valid project ID if this is anything else than a project call
    elif sys.argv[1].lower() != 'project' :
        if not uc.userConfig['Projects'].has_key(args.project_id) :
            sys.exit('\nERROR: Project ID is not valid. Process halting.\n')
        # Update the creator version if necessary
        pid         = args.project_id
        local       = ProjLocal(pid)
        pc          = ProjConfig(pid)
        checkCreatorVersion(pid, pc.projConfig, systemVersion)

    # Command processing
    # Dummy place holder for 'system' which as actually processed above
    if sys.argv[1].lower() == 'system' :
        pass

    ##### PROJECT
    # Project level commands
    elif sys.argv[1].lower() == 'project' :
        pid         = args.project_id
        cmdType     = args.command_type
        cmd         = args.command
        # Source path is optional but if given, resolve it
        if args.source_path :
            sourcePath = tools.resolvePath(args.source_path)
            if not os.path.exists(sourcePath) :
                sys.exit('\nERROR: Path is not valid. Process halting.\n')
        # Target path is optional also but if given, resolve it
        if args.target_path :
            targetPath = tools.resolvePath(args.target_path)
            if not os.path.exists(targetPath) :
                sys.exit('\nERROR: Path is not valid. Process halting.\n')
        # Figure out what manage command this is and do it
        if cmd == 'add' :
            if cmdType == 'project' :
                if not args.media_type in ['book'] :
                    sys.exit('\nERROR: Media type given: [' + args.media_type + '] is not valid. Process halting.\n')
                if not args.name :
                    sys.exit('\nERROR: Must provide a descriptive name (-n) for this new project. Process halting.\n')
                nProjPath = os.path.join(targetPath, pid)
                ProjSetup(pid).newProject(nProjPath, args.media_type, args.name, systemVersion, '')
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'bind' :
            if cmdType == 'project' :
                ProjBinding(pid).bind()
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'remove' :
            if cmdType == 'project' :
                ProjSetup(pid).deleteProject()
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'restore' :
            if cmdType == 'archive' :
                ProjBackup(pid).restoreArchive(targetPath, sourcePath)
            elif cmdType == 'backup' :
                if uc.userConfig['Projects'].has_key(pid) :
                    ProjBackup(pid).restoreBackup()
                else :
                    if args.target_path :
                        ProjBackup(pid).restoreBackup(os.path.join(targetPath))
                    else :
                        sys.exit('\nERROR: To restore this backup, a path must be provided with -t. Process halting.\n')
            elif cmdType == 'cloud' :
                if uc.userConfig['Projects'].has_key(pid) :
                    ProjBackup(pid).pullFromCloud()
                else :
                    if args.target_path :
                        if os.path.exists(tools.resolvePath(args.target_path)) :
                            ProjBackup(pid).pullFromCloud(os.path.join(tools.resolvePath(args.target_path), pid))
                        else :
                            sys.exit('\nERROR: Path is not valid. Process halting.\n')
                    else :
                        sys.exit('\nERROR: To get rain from this cloud, a target path must be provided with -t. Process halting.\n')
            elif cmdType == 'template' :
                ProjBackup(pid).templateToProject(args.name)
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'save' :
            if cmdType == 'archive' :
                ProjBackup(pid).archiveProject()
            elif cmdType == 'backup' :
                ProjBackup(pid).backupProject()
            elif cmdType == 'cloud' :
                ProjBackup(pid).pushToCloud()
            elif cmdType == 'template' :
                if isTemplate(args.template) :
                    sys.exit('\nError: This template [' + args.template + '] already exsists. Process halted.\n')
                ProjBackup(pid).projectToTemplate(args.template)
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'update' :
            if cmdType == 'groups' :
                ProjSetup(pid).updateAllGroups(args.force)
            elif cmdType == 'helper' :
                ProjCommander(pid).updateScripts()
            else :
                 cmdError(cmd, cmdType)

    ##### GROUP
    # Group level commands
    elif sys.argv[1].lower() == 'group' :
        cmdType     = args.command_type
        cmd         = args.command
        pid         = args.project_id
        gid         = args.group_id
        cid_list    = None
        cType       = None
        if args.component_type :
            cType = args.component_type
        else :
            try :
                cType = Project(pid, gid).projConfig['Groups'][gid]['cType']
            except :
                sys.exit('\nERROR: The group [' + gid + '] could not be found in the project. Please check your project setup. Process halted!\n')
        if args.cid_list :
            if type(args.cid_list) != list :
                cid_list = args.cid_list.split()
            else :
                cid_list = args.cid_list
        # Figure out what manage command this is and do it
        if cmd == 'add' :
#            import pdb; pdb.set_trace()
            if cmdType == 'group' :
                # To add a group (other than TOC) we need to do these checks first
                if gid != 'TOC' :
                    if not cid_list :
                        sys.exit('\nERROR: Must provide a list (-i) of one or more valid component IDs when adding a group. Process halted!\n')
                    elif not cType :
                        sys.exit('\nERROR: Must provide a component type (-c) ID when adding a group. Process halted!\n')
                    elif args.source_path :
                        if not tools.resolvePath(args.source_path) :
                            sys.exit('\nERROR: Must provide a valid path to the source (-s) ID when adding a group. Process halted!\n')
                    elif not args.source_id :
                        sys.exit('\nERROR: Must provide a source ID (-d) ID when adding a text group. Process halted!\n')
                # Having sorted through some of the potential problems, try adding the group according to type
                if cType == 'usfm' :
                    ProjSetup(pid).addGroup(cType, gid, cid_list, args.source_id, tools.resolvePath(args.source_path), args.force)
                elif cType == 'map' :
                    ProjMaps(pid, gid).addGroup(cid_list, args.source_id, tools.resolvePath(args.source_path), args.force)
                elif cType == 'toc' :
                    ProjToc(pid, gid).addGroup(args.force)
            elif cmdType == 'hyphenation' :
                ProjHyphenation(pid, gid).manageHyphenation(cmd)
            elif cmdType == 'illustration' :
                sys.exit('\nERROR: Add illustrations on not completed yet')
            elif cmdType == 'preprocess' :
                prc = ProjProcess(pid)
                prc.turnOnOffPreprocess(gid, True)
                prc.checkForPreprocessScript (gid)
            else :
                cmdError(cmd, cmdType)
        elif cmd in ['draft', 'final', 'proof'] :
            if cmdType == 'group' :
                if cType == 'usfm' :
                    Project(pid, gid).renderGroup(cmd, cid_list, args.force)
                elif cType == 'map' :
                    ProjMaps(pid, gid).renderMapGroup(cmd, cid_list, args.force)
                elif cType == 'toc' :
                    ProjToc(pid, gid).renderToc(cmd, args.force)
                else :
                    cTypeError(cType)
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'lock' :
            if cmdType == 'group' :
                ProjSetup(pid).lockUnlock(gid, True)
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'remove' :
            if cmdType == 'group' :
                if cType == 'usfm' :
                    ProjSetup(pid).removeGroup(gid, args.force)
                    if tools.str2bool(uc.userConfig['System']['autoHelperScripts']) :
                        ProjCommander(pid).removeScripts()
                elif cType == 'map' :
                    ProjMaps(pid, gid).removeGroup(args.force)
                elif cType == 'toc' :
                    ProjToc(pid, gid).removeGroup(args.force)
                else :
                    cTypeError(cType)
            elif cmdType == 'hyphenation' :
                ProjHyphenation(pid, gid).manageHyphenation(cmd)
            elif cmdType == 'illustration' :
                sys.exit('\nERROR: Add illustrations off not completed yet')
            elif cmdType == 'preprocess' :
                ProjSetup(pid).turnOnOffPreprocess(gid, False)
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'update' :
            if cmdType == 'group' :
                if cType == 'usfm' :
                    if args.source_id :
                        if not hasValidSourcePath(pid, gid, args.source_id) :
                            sys.exit('\nERROR: Not valid: [' + args.source_path + ']. Must provide a valid path to the source (-s) ID when adding a group. Process halted!\n')
                    ProjSetup(pid).updateGroup(gid, cid_list, args.source_path, args.force)
                elif cType == 'map' :
                    ProjMaps(pid, gid).updateGroup(cid_list, args.source_path, args.force)
                elif cType == 'toc' :
                    ProjToc(pid, gid).updateToc(args.force)
                else :
                    cTypeError(cType)
            elif cmdType == 'hyphenation' :
                ProjHyphenation(pid, gid).manageHyphenation(cmd, args.force)
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'unlock' :
            if cmdType == 'group' :
                ProjSetup(pid).lockUnlock(gid, False)
            else :
                cmdError(cmd, cmdType)

    ##### COMPONENT
    # Component level commands
    elif sys.argv[1].lower() == 'component' :
        cmd         = args.command
        pid         = args.project_id
        gid         = args.group_id
        cid         = args.component_id
        if args.compare_type :
            compareType = args.compare_type
        if cmd == 'add' :
            ProjComponent(pid, gid).addComponent(cid)
        elif cmd == 'compare' :
            ProjCompare(pid).compareComponent(gid, cid.lower(), compareType)
        elif cmd == 'edit' :
            ProjComponent(pid, gid).editComponent(cid)
        elif cmd == 'remove' :
            ProjComponent(pid, gid).removeComponent(cid)
        elif cmd == 'update' :
            ProjComponent(pid, gid).updateComponent(cid)

    ##### PACKAGES
    # Package management commands
    elif sys.argv[1].lower() == 'package' :
        cmdType     = args.package_type
        cmd         = args.command
        pid         = args.project_id
        gid         = args.group_id
        pkid        = args.package_id
        force       = args.force
        if cmd == 'add' :
            if cmdType == 'font' :
                ProjFont(pid, gid).installFont(pkid, force)
            elif cmdType == 'macro' :
                ProjConfig(pid, gid).addMacPack(pkid, force)
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'primary' :
            if cmdType == 'font' :
                ProjFont(pid, gid).setPrimaryFont(pkid, force)
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'remove' :
            if cmdType == 'font' :
                ProjFont(pid, gid).removeFontPack(pkid, force)
            elif cmdType == 'macro' :
                ProjConfig(pid, gid).removeMacPack(pkid, force)
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'update' :
            if cmdType == 'font' :
                ProjFont(pid, gid).updateFontPack(pkid, force)
            elif cmdType == 'macro' :
                ProjConfig(pid, gid).updateMacPack(pkid, True)
            else :
                cmdError(cmd, cmdType)

    ##### PROCESS
    # Processing commands
    elif sys.argv[1].lower() == 'process' :

# FIXME:
        sys.exit('\nERROR: Sorry process handling is quite broken right now. Process halted!\n')

        cmdType     = args.package_type
        cmd         = args.command
        pid         = args.project_id
        gid         = args.group_id
        force       = args.force
        script      = args.script
        path        = ''
        if args.path and tools.resolvePath(args.path) :
            path = tools.resolvePath(args.path)
        if cmd == 'add' :
            if cmdType in ['export', 'preprocess', 'postprocess'] :
                ProjProcess(pid).addProcess(script, path, force)
            else :
                cmdError(cmd, cmdType)
        elif cmd == 'remove' :
            pass
        elif cmd == 'update' :
            pass

    ##### SETTINGS
    # Setting manipulation commands
    elif sys.argv[1].lower() == 'settings' :
        pid         = args.project_id
#        gid         = args.group_id
        config      = args.configuration
        section     = args.section
        key         = args.key
        value       = args.value
        if args.configuration :
            if (section or key or value) :
                ProjSetup(pid).changeConfigSetting(config, section, key, value)
            else :
                sys.exit('\nERROR: Must provide a section, key and value. Process halted!\n')
        else :
            sys.exit('\nERROR: Configuration name is missing from command argument. Process halted!\n')

    ##### BACKGROUND
    # Commands for setting the page background
    elif sys.argv[1].lower() == 'background' :
        cmdType     = args.output_type
        cmd         = args.command
        pid         = args.project_id
        bgrd        = args.background
        if cmd == 'add' :
            ProjBackground(pid).addBackground(cmdType, bgrd)
        elif cmd == 'remove' :
            ProjBackground(pid).removeBackground(cmdType, bgrd)
        elif cmd == 'update' :
            ProjBackground(pid).updateBackground(cmdType, bgrd)

    # Totally lost
    else:
        sys.exit('\nERROR: Command not recognized: [' + sys.argv[1] + ']\n')

    # Look for an error log file and notify the user if one is found that there
    # were errors in the process. This might have failed because we loose our 
    # project object some times. For now, we'll put a 'try' around it.
    if not sys.argv[1].lower() == 'project' :
        if local and os.path.isfile(local.projErrorLogFile) :
            tools.terminal('\n\t*** ERRORS OCCURRED. PLEASE CHECK ERROR LOG ***\n')

    # Do some project log maintenance
    trimLog()

###############################################################################
############################### Argparser Setup ###############################
###############################################################################

# The following is applied to certain inputs to garentee input to be Unicode
# and not ascii or whatever the default file system encoding is.
# (Note: See the settings section for an example.)
fsunicode = partial(unicode, encoding=sys.getfilesystemencoding())

# We will try to maintain a common syntax in all the subparsers Some common
# argument options are:
#   -a = add something
#   -r = remove something
#   -e = execute something
#   -f = force the execution of something
#   -p = path (and file name) of something

# Setup the arg parser
parser = argparse.ArgumentParser(description=systemName)
subparsers = parser.add_subparsers(help='sub-command help')

# Add help subprocess arguments
helpCommand = subparsers.add_parser('help', help='General system help')

# Available choices
# Project
prCommandTypes          = ['archive', 'backup', 'cloud', 'groups', 'helper', 'project', 'template']
prCommands              = ['add', 'bind', 'remove', 'restore', 'save', 'update']
mediaTypes              = ['book']
# Group
grCommandTypes          = ['export', 'group', 'hyphenation', 'illustration', 'postprocess', 'preprocess']
grCommands              = ['add', 'draft', 'final', 'lock', 'proof', 'remove', 'run', 'update', 'unlock']
componentTypes          = ['usfm', 'map', 'toc']
# Component
cpCommands              = ['add', 'compare', 'edit', 'remove', 'update']
compareTests            = ['source', 'source-working', 'working']
# Packages
pkCommandType           = ['font', 'macro']
pkCommands              = ['add', 'primary', 'remove', 'update']
# Processes
pcCommandType           = ['export', 'preprocess', 'postprocess']
pcCommands              = ['add', 'remove', 'update']
# Background
bgCommandType           = ['bind', 'draft', 'final', 'proof']
bgCommands              = ['add', 'remove', 'update']
backgrounds             = ['box', 'cropmarks', 'draft', 'final', 'lines', 'proof']

# Add main arguments (first postion options)
parser.add_argument('-a', '--about', action='store_true', help = 'Information about Rapuma')
parser.add_argument('-b', '--basic', action='store_true', help = 'Basic Rapuma help (in HTML)')

# Add project subprocess arguments
sysCommand = subparsers.add_parser('system', help='General system management commands help')
sysCommand.add_argument('-n', '--user_name', help='Proved a name of the user who will be using this system.')
sysCommand.add_argument('-r', '--resources', help='Proved a valid path to where the user resources, such as backups, archives, etc., will be located.')

# FIXME: Restore from template will not work. The pid is the new project name but we
# currently do not have any means to specify the template. The same will be true for
# backups, we may need to add a "resource_id" arg to be able to ID them.

# Add Project subprocess arguments
projCommand = subparsers.add_parser('project', help='General project management commands help')
projCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
projCommand.add_argument('command_type', choices=prCommandTypes, help='Specify the command type to be executed on the project. This is required for all project processing functions.')
projCommand.add_argument('command', choices=prCommands, help='The general commands that can be used for managing a project.')
projCommand.add_argument('-s', '--source_path', help='An alternate path to a resouce to be used to start a new project such as an archive, template or backup. This is needed if the resource is not found in the normal specified Rapuma user resources.')
projCommand.add_argument('-t', '--target_path', help='Path to the project home folder. This can be used for specifying the location of new projects based on templates, archives or just a standard new project. Do not provide the name of the project folder, just the path to where you want it to be.')
projCommand.add_argument('-e', '--media_type', choices=mediaTypes, help='If creating a new project, give a valid project media type code.')
projCommand.add_argument('-n', '--name', help='If creating a new project, give a human readable name to describe this project.')
projCommand.add_argument('-f', '--force', action='store_true', help='Force an action.')

# Add Group subprocess arguments
groupCommand = subparsers.add_parser('group', help='General project group management commands help')
groupCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
groupCommand.add_argument('group_id', help='A unique ID for this group.')
groupCommand.add_argument('command_type', choices=grCommandTypes, help='Specify the command type to be executed on the group. This is required for all group processing functions.')
groupCommand.add_argument('command', choices=grCommands, help='The general commands that can be used for managing groups.')
groupCommand.add_argument('-c', '--component_type', choices=componentTypes, help='The group component type is needed for creating a new group.')
groupCommand.add_argument('-s', '--source_path', help='Provide a valid path to where the component source files are found for this group. (Used for adding/updating components, one source path per component group allowed.)')
groupCommand.add_argument('-d', '--source_id', help='Specify an ID to associate with the source (required).')
groupCommand.add_argument('-i', '--cid_list', help='Specify components used in this group by their recognized ID. A group can have one or more components. The list must be enclosed by quotes and have only a space between ID codes, e.g. \"aaa bbb ccc\". If the CID is for a map component, use the file name (please do not use any spaces in the file name).')
groupCommand.add_argument('-f', '--force', action='store_true', help='Force an action to override a group lock.')

# Add Component subprocess arguments
compCommand = subparsers.add_parser('component', help='General project component management commands help')
compCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
compCommand.add_argument('group_id', help='The group ID this component is a part of.')
compCommand.add_argument('component_id', help='The component ID, required any actions to be done to it.')
compCommand.add_argument('command', choices=cpCommands, help='The general commands that can be used for managing components.')
compCommand.add_argument('-c', '--compare_type', choices=compareTests, help='Compare a component with another version. This parameter must be followed by the type of test to use. Use either "working" or "source". No other test types will be accepted.')

# Add Package management subprocess arguments
packCommand = subparsers.add_parser('package', help='General package handling commands help')
packCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
packCommand.add_argument('group_id', help='The group ID this package is a part of.')
packCommand.add_argument('package_id', help='The package name ID. The ID given has to be a valid system package.')
packCommand.add_argument('package_type', choices=pkCommandType, help='The package type. The type given has to be a valid system package type.')
packCommand.add_argument('command', choices=pkCommands, help='The general commands that can be used for managing groups.')
packCommand.add_argument('-f', '--force', action='store_true', help='Force the addition, update or removal of a package from the system even if it is used by other components.')

# Add Processing subprocess arguments
processCommand = subparsers.add_parser('process', help='General settings for managing processes. Actual execution of the processes is done through the group commands')
processCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
processCommand.add_argument('group_id', help='A unique ID for this group.')
processCommand.add_argument('process_type', choices=pcCommandType, help='The type of process being managed. The type given has to be a valid system package type.')
processCommand.add_argument('command', choices=pcCommands, help='The general commands that can be used for managing groups.')
processCommand.add_argument('-p', '--path', help='A valid path and file name of a specific post process script to be installed.')
processCommand.add_argument('-s', '--script', help='Specify a script for executing. This is required for postprocesses.')
processCommand.add_argument('-f', '--force', action='store_true', help='Force the addition, update or removal of a package from the system even if it is used by other components.')

# Add Settings subprocess arguments
settingsCommand = subparsers.add_parser('settings', help='General settings handling commands help')
settingsCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
#settingsCommand.add_argument('group_id', help='A unique ID for this group.')
settingsCommand.add_argument('configuration', help='The configuration set that the target setting is from.')
settingsCommand.add_argument('section', help='The section path to the key/value pare to be changed. Multiple sections are separated by \'/\'.')
settingsCommand.add_argument('key', help='The key which has the value to be changed.')
settingsCommand.add_argument('value', type=fsunicode, help='A new value to add or change to the specified key.')

# Add page background subprocess arguments
backgroundCommand = subparsers.add_parser('background', help='Commands for managing page backgrounds such as watermarks, lines, etc.')
backgroundCommand.add_argument('project_id', help='A project ID for the project you wish to archive, backup or make template from. If a project is being made from a template, the project ID must not conflict with any others on the system.')
backgroundCommand.add_argument('output_type', choices=bgCommandType, help='The type of (rendered) output a background will be applied to or removed from.')
backgroundCommand.add_argument('background', choices=backgrounds, default='none', help='The type of background to be applied or removed from the output.')
backgroundCommand.add_argument('command', choices=bgCommands, help='The general commands that can be used for managing backgound.')

# Send the collected arguments to the handler
userArguments(parser.parse_args())


###############################################################################
########################### Close out the session #############################
###############################################################################

# In case there are any Canadians using this, politely say good bye
timeTotal = round(timeit.default_timer() - startTime, 2)
tools.terminal('\n\t\tTotal process time: ' + str(datetime.timedelta(seconds = timeTotal)).split('.')[0] + '\n')
tools.terminal('\t\tThank you, please come again!\n')













#!/usr/bin/python
# -*- coding: utf-8 -*-
# version: 20110823
# By Dennis Drescher (dennis_drescher at sil.org


###############################################################################
######################### Description/Documentation ###########################
###############################################################################

# One script to rule them all.  This is the mother script of the whole system.
# This script will drive all processes and keep track of what happens in the
# project log in each respective project.

# History:
# 20111202 - djd - Start over with manager-centric model


###############################################################################
################################ Initialize RPM ###############################
###############################################################################
# Firstly, import all the standard Python modules we need for this process and
# set the base path

import os, sys

# Set basic system vars
systemName = "Rapid Publication Manager (RPM)"
systemVersion = "0.0.1"
systemAbout = "RPM is a publishing management system written by the friendly developers at Payap University\'s Linguistics Institute (Text Unit). RPM stands for Rapid Publication Manager. It is currently being deployed in MSEAG and is under heavy development. Anyone wanting to try this system should be warned that it may not work in their context. However, the underlying principals of the system should work in any long document publishing environment. Therefore the package should be evaluated with that in mind. We welcome input and participation in this project. It is our hope it will be able to serve more than just MSEAG. For questions or more information please write: dennis_drescher@sil.org."

# Set the RPM base program path
rpmHome = os.environ.get('RPM_BASE')
if not rpmHome :
    rpmHome = os.path.join('usr', 'share', 'rpm')
    os.environ['RPM_BASE'] = rpmHome

# Set the user environment path
userHome = os.environ.get('RPM_USER')
if not userHome :
    sysHome = os.environ.get('HOME')
    userHome = os.path.join(sysHome, '.config', 'rpm')
    os.environ['RPM_USER'] = userHome

# Set the (potential) project home
projHome = os.getcwd()

# Set our paths to application resources
sys.path.insert(0, os.path.join(rpmHome, 'python_lib', 'rpm', 'core'))
sys.path.insert(0, os.path.join(rpmHome, 'python_lib', 'rpm', 'manager'))
sys.path.insert(0, os.path.join(rpmHome, 'python_lib', 'rpm', 'project'))
sys.path.insert(0, os.path.join(rpmHome, 'python_lib', 'rpm', 'component'))

# Load standard Python modules
import codecs, shutil, operator, argparse
from datetime import *
from configobj import ConfigObj
import pprint

# Load the local classes
from proj_local import ProjLocal
from tools import *
from user_config import UserConfig
from proj_config import ProjConfig
from project import Project

# Instantiate User classes
local           = ProjLocal(rpmHome, userHome, projHome)
uc              = UserConfig(local)

# Give a welcome message
terminal('\n\t\tWelcome to ' + systemName + '  ' + systemVersion + '\n')


###########################################################################
############################## RPM Functions ##############################
###########################################################################

def newProject (uc, pc, pid, ptype = None, pname = None, pdir = None) :
    '''Create a new publishing project.'''

    # Because we may need to rewrite local, declare it global here
    global local

    # Check the ptype
    if not ptype :
        ptype = 'book'

    # Check the pname, make one up if there isn't any
    if not pname :
        pname = 'The ' + pid + ' project'

    # Grab the cwd if pdir is empty for the default
    if not pdir or pdir == '.' :
        pdir = os.path.join(os.getcwd(), pid)
    else :
        pdir = os.path.abspath(pdir)

    # Adjust our project paths according to the pdir we got
    local = ProjLocal(rpmHome, userHome, pdir)

    # Run some basic tests to see if this project can be created
    # Look for project in current folder
    if not os.path.isfile(local.projConfFile) :
        # Look for locked project in current folder
        if os.path.isfile(local.projConfFile + local.lockExt) :
            terminal('ERR: Halt! Locked project already defined in target folder')
            return
        # Look for project in parent folder (don't want project in project)
        elif os.path.isfile(os.path.join(os.path.dirname(local.projHome), local.projConfFileName)) :
            terminal('ERR: Halt! Live project already defined in parent folder')
            return
        # Look for locked project in parent folder (prevent project in project)
        elif os.path.isfile(os.path.join(os.path.dirname(local.projHome), local.projConfFileName + local.lockExt)) :
            terminal('ERR: Halt! Locked project already defined in parent folder')
            return
        # Check if path to parent is valid
        elif not os.path.isdir(os.path.dirname(local.projHome)) :
            terminal('ERR: Halt! Not a valid (parent) path: ' + local.projHome)
            return
        # Test if this project already exists in the user's config file.
        elif uc.isRegisteredProject(pid) :
            terminal('ERR: Halt! ID [' + pid + '] already defined for another project')
            return
    else :
        terminal('ERR: Halt! A project already exsits in this location. Please remove it before continuing.')
        return

    # If we made it to this point, we need to make a new project folder
    if not os.path.exists(local.projConfFolder) :
        os.makedirs(local.projConfFolder)

    # Create a new version of the project config file
    pc.makeNewProjConf(local, pid, ptype, pname)

    # Add project to local RPM project registry
    uc.registerProject(pid, pname, ptype, local.projHome)

    # Report what we did
    terminal('Created new project [' + pid + ']')
    return True


def lockProject (uc, pid = None) :
    '''Lock a project out of the RPM system.  This will not remove the
    project data but will 'disable' the project by taking its reference
    out of the user's config file and locking the project.conf file.'''

    global local

    # If no pid was given this fails
    if not pid :
        terminal('Error: Project ID code not given or found. lock operation failed.')
        return

    # Check if project is registered with RPM and get real path and reinit local paths
    if not uc.userConfig['Projects'][pid] :
        terminal('Error: Not a valid registered project, cannot continue with lock operation.')
        return
    else :
        local = ProjLocal(rpmHome, userHome, uc.userConfig['Projects'][pid]['projectPath'])

    # Wanting to be humane, we don't actually remove or delete anything, just lock it down
    if os.path.isfile(local.projConfFile) :
        os.rename(local.projConfFile, local.projConfFile + local.lockExt)
    else :
        terminal('Error: No project configuration file was found, lock operation failed.')
        return

    # If we made it this far, remove references from user rpm.conf
    uc.unregisterProject(pid)

    # Report the process is done
    terminal('Project [' + pid + '] is locked and removed from system configuration.')
    return True


def unlockProject (uc, pid = None) :
    '''Unlock a project by removing the lock extention from the project.conf file.
    Then add a reference back into the user config file. Because there is no real
    fixed path to the project given, this assumes that it is starting at the same
    level as the project folder. If not, it will fail.'''

    global local

    # If no pid was given this fails
    if not pid :
        terminal('Error: Project ID code not given or found. unlock operation failed.')
        return

    # Check if project is registered with RPM and get real path and reinit local paths
    if testForSetting(uc.userConfig, 'Projects', pid) :
        terminal('Error: Project is already registered, cannot continue with unlock operation.')
        return
    else :
        local = ProjLocal(rpmHome, userHome, os.path.join(projHome, pid))

    # Unlock the project conf file
    if os.path.isfile(local.projConfFile + local.lockExt) :
        os.rename(local.projConfFile + local.lockExt, local.projConfFile)
    else :
        terminal('Error: No locked configuration file was found, unlock operation failed.')
        return

    # If we made it this far, add references to the user rpm.conf file
    pc = ConfigObj(local.projConfFile)
    uc.registerProject(pid, pc['ProjectInfo']['projectName'], pc['ProjectInfo']['projectType'], local.projHome)

    # Report the process is done
    terminal('Project [' + pid + '] unlocked and added to the system configuration.')
    return True


def deleteProject (uc, pid = None) :
    '''Delete a project fromthe RPM system registry and from the hard drive.'''

    global local

    # If no pid was given this fails
    if not pid :
        terminal('Error: Project ID code not given or found. delete operation failed.')
        return

    # Check if project is registered with RPM and get real path and reinit local paths
    if not testForSetting(uc.userConfig, 'Projects', pid) :
        terminal('Error: Not a valid registered project, cannot continue with delete operation.')
        return
    else :
        local = ProjLocal(rpmHome, userHome, uc.userConfig['Projects'][pid]['projectPath'])

    # Delete everything in the project path
    if os.path.isdir(local.projHome) :
        shutil.rmtree(local.projHome)
    else :
        terminal('Error: This project could not be found, delete operation failed.')
        return

    # If we made it this far, remove references from user rpm.conf
    uc.unregisterProject(pid)

    # Report the process is done
    terminal('Project [' + pid + '] has been removed from the system configuration and hard drive.')
    return True


###############################################################################
############################# RPM Command Center ##############################
###############################################################################

# All command options must contain a project ID (-i). That is required. If one
# is not listed then the incoming command is either considered malformed or
# incomplete. If there is a way to figure out what the user might be needing
# the help system will be called. Otherwise, RPM will quite.

# The argument handler
def userArguments (args) :
    '''Process incoming command arguments.'''

    if args['about'] :
        terminal('\n' + systemName + ' version ' + systemVersion + '\n')
        terminal('About: ' + systemAbout + '\n')

    if sys.argv[1].lower() == 'project' :
        local   = ProjLocal(rpmHome, userHome, projHome)
        pc      = ProjConfig(local)
        if args['project_new'] :
            newProject(uc, pc, args['project_id'])
        elif args['project_lock'] :
            lockProject(uc, args['project_id'])
        elif args['project_unlock'] :
            unlockProject(uc, args['project_id'])
        elif args['project_delete'] :
            deleteProject(uc, args['project_id'])
    elif sys.argv[1].lower() == 'component' :
        local   = ProjLocal(rpmHome, userHome, os.path.join(projHome, args['project_id'].upper()))
        pc      = ProjConfig(local)
        if testForSetting(pc.projConfig, 'ProjectInfo', 'projectIDCode') :
            aProject = Project(uc.userConfig, pc.projConfig, local)
            if args['component_new'] :
                aProject.addComponent(args['component_id'], args['component_type'])
            if args['component_render'] :
                aProject.renderComponent(args['component_id'])
        else :
            terminal('Cannot find [' + args['project_id'] + '] project.')
    elif sys.argv[1].lower() == 'font' :
        local   = ProjLocal(rpmHome, userHome, os.path.join(projHome, args['project_id'].upper()))
        pc      = ProjConfig(local)
        if testForSetting(pc.projConfig, 'ProjectInfo', 'projectIDCode') :
            aProject = Project(uc.userConfig, pc.projConfig, local)
            if args['font_new'] :
                aProject.addComponentFont(args['font_name'], args['component_type'])
            if args['font_remove'] :
                aProject.removeComponentFont(args['font_name'], args['component_type'])
            if args['font_primary'] :
                aProject.setPrimaryFont(args['font_name'], args['component_type'])
        else :
            terminal('Cannot find [' + args['project_id'] + '] project.')
    else:
        terminal('Error: Command not recognized! ')
        sys.exit()

# Setup the arg parser
parser = argparse.ArgumentParser(description=systemName)
subparsers = parser.add_subparsers(help='sub-command help')

# Add main arguments
parser.add_argument('-a', '--about', action='store_true', help = 'About RPM')

# Add project subprocess arguments
projCommand = subparsers.add_parser('project', help='General project management commands help')
projCommand.add_argument('-i', '--project_id', help='Project ID (required for all actions)')
projCommand.add_argument('-n', '--project_new', action='store_true', help='Create a new project on this computer.')
projCommand.add_argument('-l', '--project_lock', action='store_true', help='Lock a project so it cannot be acted on.')
projCommand.add_argument('-u', '--project_unlock', action='store_true', help='Unlock a project. There must be a locked project configuration file present.')
projCommand.add_argument('-d', '--project_delete', action='store_true', help='Delete a project permanently from the system. This will do just what is says. Be careful!')
# Add component subprocess arguments
compCommand = subparsers.add_parser('component', help='General project component management commands help')
compCommand.add_argument('-i', '--project_id', help='Project ID (required for all actions)')
compCommand.add_argument('-n', '--component_new', action='store_true', help='Create a new component for this project.')
compCommand.add_argument('-r', '--component_render', action='store_true', help='Render a single component in this project.')
compCommand.add_argument('-c', '--component_id', help='The component ID (required for component_new and component_render).')
compCommand.add_argument('-t', '--component_type', help='The component type (required for component_new and component_font).')
# Add font subprocess arguments
compCommand = subparsers.add_parser('font', help='General font handling commands help')
compCommand.add_argument('-i', '--project_id', help='Project ID (required for all actions)')
compCommand.add_argument('-t', '--component_type', help='The component type (required for component_new and component_font).')
compCommand.add_argument('-f', '--font_name', help='The font family name. The name given has to have an RPM font configuration file associated with it.')
compCommand.add_argument('-n', '--font_new', action='store_true', help='Add a new font for this project.')
compCommand.add_argument('-r', '--font_remove', action='store_true', help='Remove a font from this project.')
compCommand.add_argument('-p', '--font_primary', action='store_true', help='Set, and install if necessary, the primary font for this project. The font family name given has to have an RPM font configuration file associated with it.')


# Send the collected arguments to the handler
userArguments(vars(parser.parse_args()))


###############################################################################
########################### Close out the session #############################
###############################################################################


# Now trim the log file if it is needed
if os.path.isfile(local.projLogFile) :
    trimLog(local.projLogFile, uc.userConfig['System']['projLogLineLimit'])

## In case there are any Canadians using this, politely say good bye
terminal('\n\t\tThank you, please come again!\n')



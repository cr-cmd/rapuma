#!/usr/bin/python
# -*- coding: utf-8 -*-
# By Dennis Drescher (dennis_drescher at sil.org


###############################################################################
######################### Description/Documentation ###########################
###############################################################################

# One script to rule them all.  This is the main Rapuma engine script.
# This script will drive all processes and keep track of what happens in the
# project log in each respective project.


###############################################################################
################################ Initialize Rapuma ###############################
###############################################################################
# Firstly, import all the standard Python modules we need for this process and
# set the base path

import os, sys
from functools import partial

# Set the Rapuma base program paths
rapumaHome = os.environ.get('RAPUMA_BASE')
sysHome = os.environ.get('HOME')
if not rapumaHome :
    for t in (os.path.join(sysHome, '.local'), '/usr/local', '/usr') :
        rapumaHome = os.path.join(t, 'share', 'rapuma')
        if os.path.exists(os.path.join(rapumaHome, 'resources')) :
            os.environ['RAPUMA_BASE'] = rapumaHome
            break

# Set the user environment path
userHome = os.environ.get('RAPUMA_USER')
if not userHome :
    userHome = os.path.join(sysHome, '.config', 'rapuma')
    os.environ['RAPUMA_USER'] = userHome

# Set the (potential) project home
projHome = os.getcwd()

# Load standard Python modules
import codecs, shutil, operator, argparse, subprocess, zipfile, tempfile
from datetime import *
from configobj import ConfigObj

# Load the local classes
from rapuma.core.proj_local         import ProjLocal
from rapuma.core.proj_log           import ProjLog
from rapuma.core.user_config        import UserConfig
from rapuma.core.proj_config        import ProjConfig
from rapuma.core.proj_setup         import ProjSetup
from rapuma.core.proj_backup        import ProjBackup
from rapuma.core.proj_binding       import Binding
from rapuma.core.proj_compare       import Compare
from rapuma.core.page_background    import PageBackground
from rapuma.project.project         import Project
from rapuma.project.proj_commander  import Commander
from rapuma.core.tools              import Tools

# Instantiate User config class
uc              = UserConfig()
tools           = Tools()

# Set some global vars
systemName      = 'Rapuma (Rapid Publication Manager)'
systemAbout     = 'Rapuma is a publishing management system written by the friendly developers at Payap University\'s Linguistics Institute (Text Unit). Rapuma stands for Rapid Publication Manager. It is currently being deployed in MSEAG and is under heavy development. Anyone wanting to try this system should be warned that it may not work in their context. However, the underlying principals of the system should work in any long document publishing environment. Therefore the package should be evaluated with that in mind. We welcome input and participation in this project. It is our hope it will be able to serve more than just MSEAG. For questions or more information please write: dennis_drescher@sil.org.'
systemVersion   = '0.1.20130417221909'

# Give a welcome message
tools.terminal('\n\t\tWelcome to ' + systemName)
tools.terminal('\n\t\t\tVersion ' + systemVersion + '\n')

###########################################################################
########################### Rapuma Functions ##############################
###########################################################################

def checkCreatorVersion (projConfig, systemVersion) :
    '''Keep track of the version of Rapuma used in the current project.'''

    if not tools.testForSetting(projConfig, 'ProjectInfo', 'projectCreatorVersion') :
        projConfig['ProjectInfo']['projectCreatorVersion'] = systemVersion
        tools.writeConfFile(projConfig)
    else :
        if projConfig['ProjectInfo']['projectCreatorVersion'] != systemVersion :
            projConfig['ProjectInfo']['projectCreatorVersion'] = systemVersion
            tools.writeConfFile(projConfig)


def hasValidSourcePath (gid, csid) :
    '''Check if there is one, see if it is valid.'''

    try :
        path = uc.userConfig['Projects'][self.projectIDCode][csid + '_sourcePath']
        return os.path.isdir(tools.resolvePath(path))
    except :
        return False


def isProject (pid) :
    '''Look up in the user config to see if a project is registered.
    Return False if it is not.'''

    try :
        if pid in uc.userConfig['Projects'].keys() :
            return True
    except :
        return False


def isTemplate (tid) :
    '''Check to see if a template exsists in the user's template store area.'''

    try :
        templates = uc.userConfig['Resources']['templates']
        if tid + '.zip' in os.listdir(templates) :
            return True
    except :
        return False


def initProject (pid, gid) :
    '''Initialize an existing project according to the project ID given.'''

    local   = ProjLocal(pid)
    pc      = ProjConfig(local)
    log     = ProjLog(pid)
    checkCreatorVersion(pc.projConfig, systemVersion)
    aProject = Project(pid, gid)
    return aProject


def trimLog (self, logFile, limit = 1000) :
    '''Trim a log file.  This will take an existing log file and
    trim it to the amount specified in the system file.'''

    # Of course this isn't needed if there isn't even a log file
    if os.path.isfile(logFile) :

        # Change this to an int()
        limit = int(limit)
        
        # Read in the existing log file
        readObject = codecs.open(logFile, "r", encoding='utf_8')
        lines = readObject.readlines()
        readObject.close()

        # Process only if we have enough lines
        if len(lines) > limit :
            writeObject = codecs.open(logFile, "w", encoding='utf_8')
            lineCount = 0
            for line in lines :
                if limit > lineCount :
                    writeObject.write(line)
                    lineCount +=1

            writeObject.close()

        return True
    else :
        return False


###############################################################################
########################### Rapuma Command Center #############################
###############################################################################

# All command options must contain a project ID (-i). That is required. If one
# is not listed then the incoming command is either considered malformed or
# incomplete. If there is a way to figure out what the user might be needing
# the help system will be called. Otherwise, Rapuma will quite.

# The argument handler
def userArguments (args) :
    '''Process incoming command arguments.'''

    # Pre-command process: Extra help access
    if sys.argv[1].lower() == 'help' :
        if args.about :
            tools.terminal('\n' + systemName + ' version ' + systemVersion + '\n')
            tools.terminal('About: ' + systemAbout + '\n')
            return

    # Pre-command process: System level commands
    if sys.argv[1].lower() == 'system' :
        if args.user_name :
            uc.setSystemSettings('userName', args.user_name)
        elif args.resources :
            uc.setSystemSettings('resources', args.resources)
    # Test for valid project ID
    elif sys.argv[1].lower() != 'project' :
        isProject(args.project_id)

    # Command processing
    # Dummy place holder for 'system' which as actually processed above
    if sys.argv[1].lower() == 'system' :
        pass

    # Project level commands
    elif sys.argv[1].lower() == 'project' :
        pid = args.project_id
        # Source path is optional but if given, resolve it
        if args.sourcePath :
            sourcePath = tools.resolvePath(args.sourcePath)
            if not os.path.exists(sourcePath) :
                sys.exit('\nERROR: Path is not valid. Process halting.\n')
        # Target path is optional also but if given, resolve it
        if args.targetPath :
            targetPath = tools.resolvePath(args.targetPath)
            if not os.path.exists(targetPath) :
                sys.exit('\nERROR: Path is not valid. Process halting.\n')

        # Create/refresh helper scripts
        if args.scripts :
            Commander(pid).updateScripts()
            return True

        # Remove an exsisting project
        if args.delete :
            ProjSetup(pid).deleteProject()
            return True

        # Restore (or revert to) the last backup
        if args.restore == 'backup' :
            if isProject(pid) :
                ProjBackup(pid).restoreBackup(pid)
            else :
                if args.targetPath :
                    ProjBackup(pid).restoreBackup(os.path.join(targetPath, pid))
                else :
                    sys.exit('\nERROR: To restore this backup, a path must be provided with -t. Process halting.\n')
        # Update (get rained on) from the cloud
        elif args.restore == 'cloud' :
            if isProject(pid) :
                ProjBackup(pid).pullFromCloud()
            else :
                if args.targetPath :
                    if os.path.exists(tools.resolvePath(args.targetPath)) :
                        ProjBackup(pid).pullFromCloud(os.path.join(tools.resolvePath(args.targetPath), pid))
                    else :
                        sys.exit('\nERROR: Path is not valid. Process halting.\n')
                else :
                    sys.exit('\nERROR: To get rain from this cloud, a path must be provided with -g. Process halting.\n')

        # Commands to preserve project data. (Check PID and if necessary TID before passing it on)
        # Archive the project
        elif args.preserve == 'archive' :
            ProjBackup(pid).archiveProject()
        # Backup the project (simple)
        elif args.preserve == 'backup' :
            ProjBackup(pid).backupProject()
        # Create a template of the current project
        elif args.preserve == 'template' :
            if isTemplate(args.template) :
                sys.exit('\nError: This template [' + args.template + '] already exsists. Process halted.\n')
            ProjBackup(pid).projectToTemplate(args.template)
        # Backup (evaporate) to cloud
        elif args.preserve == 'cloud' :
            ProjBackup(pid).pushToCloud()

        # Creating a new project from a template, archive, or scratch
        else :
            # First test for some necessary params
            if not args.targetPath :
                # A path must be given
                sys.exit('\nERROR: No path for this project has been given. Process halting.\n')
            else :
                projFolder = os.path.join(targetPath, pid)

            # New (to current system) project from archive
            if args.restore == 'archive' :
                ProjBackup(pid).restoreArchive(targetPath, sourcePath)
            # New project from template
            if args.restore == 'template' :
                templateSource = ''
                if sourcePath :
                    templateSource = os.path.join(sourcePath, pid + '.zip')
                ProjBackup(pid).templateToProject(args.name, templateSource)
            # Just creating from scratch
            else :
                # Create a new project
                if not args.media in ['book'] :
                    sys.exit('\nERROR: Media type given: [' + args.media + '] is not valid. Process halting.\n')
                if not args.name :
                    sys.exit('\nERROR: Must provide a descriptive name (-n) for this new project. Process halting.\n')
                nProjPath = os.path.join(targetPath, pid)
                ProjSetup(pid).newProject(nProjPath, args.media, args.name, systemVersion, '')

    # Group level commands
    elif sys.argv[1].lower() == 'group' :
        aProject = initProject(args.project_id, args.group_id)
        if args.hyphenation :
            aProject.createManager(args.component_type, 'hyphenation')
            manager = args.component_type + '_Hyphenation'
            if args.hyphenation == 'add' :
                aProject.managers[manager].turnOnHyphenation(args.group_id)
            elif args.hyphenation == 'remove' :
                aProject.managers[manager].turnOffHyphenation(args.group_id)
            elif args.hyphenation == 'update' :
                aProject.managers[manager].updateHyphenation(args.force)
        elif args.preprocess :
            if args.preprocess == 'add' :
                ProjSetup(args.project_id).turnOnOffPreprocess(args.group_id, True)
            elif args.preprocess == 'remove' :
                ProjSetup(args.project_id).turnOnOffPreprocess(args.group_id, False)
        elif args.illustrations :
            if args.illustrations == 'on' :
                sys.exit('\nERROR: Add illustrations on not completed yet')
            elif args.illustrations == 'off' :
                sys.exit('\nERROR: Add illustrations off not completed yet')
        elif args.manage :
            if args.manage == 'add' :
                # To add a group we need to do these checks first
                if not args.cid_list :
                    sys.exit('\nERROR: Must provide a list (-i) of one or more valid component IDs when adding a group. Process halted!\n')
                elif not args.component_type :
                    sys.exit('\nERROR: Must provide a component type (-c) ID when adding a group. Process halted!\n')
                elif not args.source_id :
                    sys.exit('\nERROR: Must provide a source ID (-d) ID when adding a group. Process halted!\n')
                elif args.source :
                    if not tools.resolvePath(args.source) :
                        sys.exit('\nERROR: Must provide a valid path to the source (-s) ID when adding a group. Process halted!\n')
                elif args.source_id :
                    if not hasValidSourcePath(args.group_id, args.source_id) :
                        sys.exit('\nERROR: No source path found for this source ID. Must provide a valid path to the source (-s) ID when adding a group. Process halted!\n')
                # Having sorted through any potential problems, try adding the group
                ProjSetup(args.project_id).addGroup(args.component_type, args.group_id, args.cid_list, args.source_id, tools.resolvePath(args.source), args.force)
            elif args.manage == 'remove' :
                ProjSetup(args.project_id).removeGroup(args.group_id, args.force)
                if tools.str2bool(uc.userConfig['System']['autoHelperScripts']) :
                    Commander(args.project_id).removeScripts()
            elif args.manage == 'update' :
                ProjSetup(args.project_id).updateGroup(args.group_id, args.cid_list, args.source, args.force)
            elif args.manage == 'execute' :
                aProject = initProject(args.project_id, args.group_id)
                if args.cid_list :
                    if not aProject.isValidCidList(args.group_id, args.cid_list) :
                        sys.exit('\nERROR: Must provide a valid list (-i) of one or more component IDs in the provided list are not a part of this group. Process halted!\n')
                if aProject.isGroup(args.group_id) :
                    aProject.renderGroup(args.group_id, args.cid_list, args.force)
                else :
                    sys.exit('\nERROR: The group ID given is not found in this project. Must provide a valid group ID. Process halted!\n')
            elif args.manage == 'lock' :
                ProjSetup(args.project_id).lockUnlock(args.group_id, True)
            elif args.manage == 'unlock' :
                ProjSetup(args.project_id).lockUnlock(args.group_id, False)
            elif args.manage == 'list' :
                aProject.listAllComponents(args.component_type)

        elif args.preprocess :
            aProject.turnOnOffPreprocess(args.group_id, args.preprocess)

    # Component level commands
    elif sys.argv[1].lower() == 'component' :
        aProject = initProject(args.project_id, args.group_id)
        # Render vs. view command is just a matter of forcing the component
        # to be rendered if render is selected by the user. Otherwise, if
        # only view is requested, if force is set to False and the component
        # will not be rerendered if it already exsists.
        if args.compare :
            Compare(args.project_id).compareComponent(args.group_id, args.component_id.lower(), args.compare)
        # Commands for editing project files
        elif args.edit :
                aProject.edit(args.component_id)

    # Binding level commands
    elif sys.argv[1].lower() == 'binding' :
        # Add a new binding group
        if args.manage == 'add' :
            Binding(args.project_id).addBindingGroup(args.bind_id, args.id_list, args.force)
        elif args.manage == 'remove' :
            Binding(args.project_id).removeBindingGroup(args.bind_id)
        elif args.manage == 'execute' :
            Binding(args.project_id).bindComponents(args.bind_id)

    # Font level commands
    elif sys.argv[1].lower() == 'font' :
        aProject = initProject(args.project_id, args.group_id)
        aProject.createManager(args.component_type, 'font')
        font = aProject.managers[args.component_type + '_Font'].checkForSubFont(args.font_id)
        manager = args.component_type + '_Font'
        if args.component_type :
            if args.add :
                # Physically install the font files
                aProject.managers[manager].installFont(font, args.force)
            elif args.remove :
                aProject.managers[manager].removeFont(args.component_type, font, args.force)
            elif args.main :
                aProject.managers[manager].setPrimaryFont(args.component_type.capitalize(), font, args.force)
        else :
            sys.exit('\nERROR: Component type ID is missing from command argument. Process halted!\n')

    # Post processing commands
    elif sys.argv[1].lower() == 'postprocess' :
        # Run a post process command on a component or component type
        # Because we can lock at all levels, there is no need for (-f --force)
        # to be used here. If a component name is given it will only run on that
        # component which includes all listed sub-components. Otherwise, all 
        # components of the specified type will be acted on by the postprocess.
        if args.manage == 'execute' :
            if not args.script :
                sys.exit('\nERROR: No script was specified, Please use -s to specify a script to execute.\n')
            elif not args.component_name.lower() :
                sys.exit('\nERROR: No component ID was specified, Please use -c to specify a valid component (group) ID to run this post process script on.\n')
            else :
                ProjSetup(args.project_id).runProcessScript(args.component_name.lower(), args.script)
        # Install a custom or a default post process script, force to overwrite what is there
        elif args.manage == 'add' :
            filePath = ''
            if args.path :
                filePath = tools.resolvePath(args.path)
                if not os.path.isfile(filePath) :
                    sys.exit('\nERROR: The following path does not appear to be valid: ' + filePath + '\n')
            ProjSetup(args.project_id).installPostProcess(args.component_type, filePath, args.force)
        # Disconnect a post process script from the component type (This does not
        # physically remove it unless -f is used.)
        elif args.manage == 'remove' :
            ProjSetup(args.project_id).removePostProcess(args.component_type, force)

    # Setting manipulation commands
    elif sys.argv[1].lower() == 'settings' :
        if args.configuration :
            if (args.section or args.key or args.value) :
                ProjSetup(args.project_id).changeConfigSetting(args.configuration, args.section, args.key, args.value)
            else :
                sys.exit('\nERROR: Must provide a section, key and value. Process halted!\n')
        else :
            sys.exit('\nERROR: Configuration name is missing from command argument. Process halted!\n')

    # Commands for setting the page background
    elif sys.argv[1].lower() == 'background' :
        if args.add :
            PageBackground(args.project_id).addBackground(args.background_type, args.force)
        elif args.remove :
            PageBackground(args.project_id).removeBackground(args.background_type)
        elif args.background_type == 'none' :
            PageBackground(args.project_id).backgroundOff()

    # Totally lost
    else:
        sys.exit('\nERROR: Command not recognized: [' + sys.argv[1] + ']\n')

    # During a process, a number of log entries will be made and written out.
    # Over time the log file could get very large. To control the size, there
    # is a setting in the user config file that limits the number of lines in
    # the log file. The default is 1000 but it can be adjusted if needed. The
    # following call here will trim the log file to its specified limit. This
    # is done here as there should be no further operations done at this point.
    # Note: This will not work with "project" commands (aProject is not declaired)
    # To get around that we will use a 'try' statement to prevent confusing errors.
    try :
        if not sys.argv[1].lower() == 'project' :
            if os.path.isfile(aProject.local.projLogFile) :
                trimLog(aProject.local.projLogFile, uc.userConfig['System']['projLogLineLimit'])
    except :
        pass

    # Look for an error log file and notify the user if one is found that there
    # were errors in the process. This might have failed because we loose our 
    # project object some times. For now, we'll put a 'try' around it.
    try :
        if not sys.argv[1].lower() == 'project' :
            if os.path.isfile(aProject.local.projErrorLogFile) :
                tools.terminal('\n\t*** ERRORS OCCURRED. PLEASE CHECK ERROR LOG ***\n')
    except :
        pass

###############################################################################
############################### Argparser Setup ###############################
###############################################################################

# The following is applied to certain inputs to garentee input to be Unicode
# and not ascii or whatever the default file system encoding is.
# (Note: See the settings section for an example.)
fsunicode = partial(unicode, encoding=sys.getfilesystemencoding())

# We will try to maintain a common syntax in all the subparsers Some common
# argument options are:
#   -a = add something
#   -r = remove something
#   -e = execute something
#   -f = force the execution of something
#   -p = path (and file name) of something

# Setup the arg parser
parser = argparse.ArgumentParser(description=systemName)
subparsers = parser.add_subparsers(help='sub-command help')

# Add help subprocess arguments
helpCommand = subparsers.add_parser('help', help='General system help')

# Available choices
# Project
mediaTypes              = ['book']
componentTypes          = ['usfm']
backupTypes             = ['archive', 'backup', 'cloud', 'template']
# Group
manageCommands          = ['add', 'remove', 'update', 'execute', 'lock', 'unlock', 'list']
hyphenCommands          = ['add', 'remove', 'update']
preprocessCommands      = ['add', 'remove']
illustrationCommands    = ['on', 'off']
# Other
backgrounds             = ['boarder', 'cropmarks', 'lines', 'none', 'watermark']
compareTests            = ['source', 'source-working', 'working']
bindCommands            = ['add', 'remove', 'execute']
postprocessCommands     = ['add', 'remove', 'execute']

# Add main arguments (first postion options)
parser.add_argument('-a', '--about', action='store_true', help = 'Information about Rapuma')
parser.add_argument('-b', '--basic', action='store_true', help = 'Basic Rapuma help (in HTML)')

# Add project subprocess arguments
sysCommand = subparsers.add_parser('system', help='General system management commands help')
sysCommand.add_argument('-n', '--user_name', help='Proved a name of the user who will be using this system.')
sysCommand.add_argument('-r', '--resources', help='Proved a valid path to where the user resources, such as backups, archives, etc., will be located.')

# FIXME: Restore from template will not work. The pid is the new project name but we
# currently do not have any means to specify the template. The same will be true for
# backups, we may need to add a "resource_id" arg to be able to ID them.

# Add Project subprocess arguments
projCommand = subparsers.add_parser('project', help='General project management commands help')
projCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
projCommand.add_argument('-d', '--delete', action='store_true', help='Delete a project permanently from the system. This will do just what is says. Be careful!')
projCommand.add_argument('-p', '--preserve', choices=backupTypes, help='If creating a new project, give a human readable name to describe this project.')
projCommand.add_argument('-r', '--restore', choices=backupTypes, help='This will restore a project from a backup or archive, Pull in data from a cloud backup. Or, create a new project from a template found in the Rapuma resouces folder.')
projCommand.add_argument('-s', '--sourcePath', help='An alternate path to a resouce to be used to start a new project such as an archive, template or backup. This is needed if the resource is not found in the normal specified Rapuma user resources.')
projCommand.add_argument('-t', '--targetPath', help='Path to the project home folder. This can be used for specifying the location of new projects based on templates, archives or just a standard new project. Do not provide the name of the project folder, just the path to where you want it to be.')
projCommand.add_argument('-m', '--media', choices=mediaTypes, help='If creating a new project, give a valid project media type code.')
projCommand.add_argument('-n', '--name', help='If creating a new project, give a human readable name to describe this project.')
projCommand.add_argument('-c', '--scripts', action='store_true', help='Create/recreate helper scripts that will help with various repetitive tasks.')

# Add Group subprocess arguments
groupCommand = subparsers.add_parser('group', help='General project group management commands help')
groupCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
groupCommand.add_argument('group_id', help='A unique ID for this group.')
groupCommand.add_argument('-m', '--manage', choices=manageCommands, help='The general commands that can be used for managing groups.')
groupCommand.add_argument('-f', '--force', action='store_true', help='Force an action to override a group lock.')
groupCommand.add_argument('-c', '--component_type', choices=componentTypes, help='The group component type is needed for creating a new group.')
groupCommand.add_argument('-y', '--hyphenation', choices=hyphenCommands, help='Manage hyphenation for this group.')
groupCommand.add_argument('-p', '--preprocess', choices=preprocessCommands, help='Turn on or off automated preprocessing when importing and updating components into the group.')
groupCommand.add_argument('-l', '--illustrations', choices=illustrationCommands, help='Manage the use of illustrations in this group.')
groupCommand.add_argument('-s', '--source', help='Provide a valid path to where the component source files are found for this group. (Used for adding/updating components, one source path per component group allowed.)')
groupCommand.add_argument('-d', '--source_id', help='Specify an ID to associate with the source (required).')
groupCommand.add_argument('-i', '--cid_list', help='Specify components used in this group by their recognized ID. A group can have one or more components. The list must be enclosed by quotes and have only a space between ID codes, e.g. \"aaa bbb ccc\".')

# Add Component subprocess arguments
compCommand = subparsers.add_parser('component', help='General project component management commands help')
compCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
compCommand.add_argument('group_id', help='The group ID this component is a part of.')
compCommand.add_argument('component_id', help='The component ID, required any actions to be done to it.')
compCommand.add_argument('-c', '--compare', choices=compareTests, help='Compare a component with another version. This parameter must be followed by the type of test to use. Use either "working" or "source". No other test types will be accepted.')
compCommand.add_argument('-d', '--edit', action='store_true', help='Edit a specific component from a specified group.')

# Add Binding subprocess arguments
bindCommand = subparsers.add_parser('binding', help='General project binding management commands help')
bindCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
bindCommand.add_argument('bind_id', help='Binding group ID (a positional argument required for all actions with this subprocess)')
bindCommand.add_argument('-m', '--manage', choices=bindCommands, help='The general commands that can be used for managing project binding.')
bindCommand.add_argument('-i', '--id_list', help='A list of groups that are to be bound together.')
bindCommand.add_argument('-f', '--force', action='store_true', help='Force an action if overriding a default non-action is needed.')

# Add Font subprocess arguments
fontCommand = subparsers.add_parser('font', help='General font handling commands help')
fontCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
fontCommand.add_argument('group_id', help='The group ID this font is a part of.')
fontCommand.add_argument('component_type', help='Specify the component type. This is required for all font functions.')
fontCommand.add_argument('font_id', help='The font family name ID. The ID given has to be a valid system font.')
fontCommand.add_argument('-a', '--add', action='store_true', help='Add a new font for a specific comonent type.')
fontCommand.add_argument('-r', '--remove', action='store_true', help='Remove the font of a specified ID from this project.')
fontCommand.add_argument('-f', '--force', action='store_true', help='Force the addition or removal of a font from the system even if it is used by other components.')
fontCommand.add_argument('-m', '--main', action='store_true', help='Set, the specified (valid system) font to be the main (primary) font for this component type.')

# Add text Postprocessing subprocess arguments
postprocessCommand = subparsers.add_parser('postprocess', help='General settings for handling component post processing commands.')
postprocessCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
postprocessCommand.add_argument('group_id', help='A unique ID for this group.')
postprocessCommand.add_argument('-m', '--manage', choices=postprocessCommands, help='The general commands that can be used for managing postprocesses.')
postprocessCommand.add_argument('-f', '--force', action='store_true', help='Force a post process script to be updated, replaced or brought back to default condition for this component type.')
postprocessCommand.add_argument('-i', '--cid_list', help='If desired, list components to have a post process run on them. The list must be enclosed by quotes and have only a space between ID codes, e.g. \"aaa bbb ccc\".')
postprocessCommand.add_argument('-p', '--path', help='A valid path and file name of a specific post process script to be installed.')
postprocessCommand.add_argument('-s', '--script', help='Specify a script for executing. This is required for the -e command.')

# Add Settings subprocess arguments
settingsCommand = subparsers.add_parser('settings', help='General settings handling commands help')
settingsCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
settingsCommand.add_argument('configuration', help='The configuration set that the target setting is from.')
settingsCommand.add_argument('section', help='The section path to the key/value pare to be changed. Multiple sections are separated by \'/\'.')
settingsCommand.add_argument('key', help='The key which has the value to be changed.')
settingsCommand.add_argument('value', type=fsunicode, help='A new value to add or change to the specified key.')

# FIXME: Need to add Export management

# FIXME: Need to add Macro management

# Add page background subprocess arguments
backgroundCommand = subparsers.add_parser('background', help='Commands for managing page backgrounds such as watermarks, lines, etc.')
backgroundCommand.add_argument('project_id', help='A project ID for the project you wish to archive, backup or make template from. If a project is being made from a template, the project ID must not conflict with any others on the system.')
backgroundCommand.add_argument('background_type', choices=backgrounds, default='none', help='The type of background to be applied or removed from the output.')
backgroundCommand.add_argument('-a', '--add', action='store_true', help='Add a background type.')
backgroundCommand.add_argument('-r', '--remove', action='store_true', help='Remove background type.')
backgroundCommand.add_argument('-f', '--force', action='store_true', help='Force overwrite on exsisting background file.')

# Send the collected arguments to the handler
userArguments(parser.parse_args())


###############################################################################
########################### Close out the session #############################
###############################################################################

# In case there are any Canadians using this, politely say good bye
tools.terminal('\n\t\tThank you, please come again!\n')













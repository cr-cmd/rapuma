#!/usr/bin/python
# -*- coding: utf-8 -*-
# version: 20110823
# By Dennis Drescher (dennis_drescher at sil.org


###############################################################################
######################### Description/Documentation ###########################
###############################################################################

# One script to rule them all.  This is the mother script of the whole system.
# This script will drive all processes and keep track of what happens in the
# project log in each respective project.

# History:
# 20111202 - djd - Start over with manager-centric model


###############################################################################
################################ Initialize RPM ###############################
###############################################################################
# Firstly, import all the standard Python modules we need for this process and
# set the base path

import os, sys

# Set basic system vars
systemName = "Rapid Publication Manager (RPM)"
systemVersion = "0.0.1"
systemAbout = "RPM is a Scripture publishing management system written by the friendly developers at Payap University\'s Linguistics Institute (Text Unit). RPM stands for Rapid Publication Manager. It is currently being deployed in MSEAG and is under heavy development. Anyone wanting to try this system should be warned that it may not work in their context. However, the underlying principals of the system should work in any long document publishing environment. Therefore the package should be evaluated with that in mind. We welcome input and participation in this project. It is our hope it will be able to serve more than just MSEAG. For questions or more information please write: dennis_drescher@sil.org."


# Set the RPM base program path
rpmHome = os.environ.get('RPM_BASE')
if not rpmHome :
    rpmHome = os.path.join('usr', 'share', 'rpm')
    os.environ['RPM_BASE'] = rpmHome

# Set the user environment path
userHome = os.environ.get('RPM_USER')
if not userHome :
    sysHome = os.environ.get('HOME')
    userHome = os.path.join(sysHome, '.config', 'rpm')
    os.environ['RPM_USER'] = userHome

# Set the location for RPM internal configuration
rpmConfig = os.path.join(rpmHome, 'bin', 'config')

# Set the (potential) project home
projHome = os.getcwd()

# Set our paths to application resources
sys.path.insert(0, os.path.join(rpmHome, 'python_lib', 'rpm', 'core'))
sys.path.insert(0, os.path.join(rpmHome, 'python_lib', 'rpm', 'manager'))
sys.path.insert(0, os.path.join(rpmHome, 'python_lib', 'rpm', 'project'))
sys.path.insert(0, os.path.join(rpmHome, 'python_lib', 'rpm', 'component'))

# Load standard Python modules
import codecs, shutil, operator
from datetime import *
from configobj import ConfigObj

# Load the local classes
from tools import *
from user_config import UserConfig
#from sys_command import Command, commands
from project import *

###############################################################################
####################### Create the command to be used #########################
###############################################################################

# A complete command contains three elements, they are:
#
#   1) rpm (this program)
#   2) command (a valid RPM program command)
#   3) options (a valid option for that RPM command)
# 
# All command options must contain a project ID (-i). That is required. If one
# is not listed then the incoming command is either considered malformed or
# incomplete. If there is a way to figure out what the user might be needing
# the help system will be called. Otherwise, RPM will quite.

# FIXME: Command line processing must fixed to reflect the above documentation.
# FIXME: Is it okay to process the -i here and then ignore it in most of the 
# actual command processing? For now I am doing that.

# Catch any incoming commands here
pid = ''
command = ''
opts = []

# Check and collect command line args. If the command is not
# properly formed, exit now.
if len(sys.argv) == 1 :
    command = 'help'
    opts = ['-h']
elif len(sys.argv) == 2 :
    if sys.argv[1].lower() == 'help' :
        command = 'help'
        opts = ['-h']
    else :
        terminalError('RPM command not properly formed. Missing command options.')
        sys.exit()
elif len(sys.argv) >= 3 :
    command = sys.argv[1]
    opts = sys.argv[2:]
else :
    terminalError('RPM command not properly formed.')
    sys.exit()

# We really need to know what the pid here. Let's look now
# There should be a -i (pid) in every command we process.
# If not, we quite here.
c = 0
if opts :
    # If there is a help command we just divert to that
    if not '-h' in opts :
        # Otherwise we need to be sure there is a pid in the line
        if '-i' in opts :
            for cmd in opts :
                c +=1
                if cmd == '-i' :
                    pid = opts[c]
        else :
            terminalError('No project ID found in command line.')
            sys.exit()


###############################################################################
####################### Define functions for startup ##########################
###############################################################################

def welcomeMessage (aProject) :

    # Give a welcome message
    terminal('\n\t\tWelcome to ' + systemName + '  ' + systemVersion)
    terminal('\t\tCurrent User: ' + aProject._userConfig['System']['userName'])
    if os.path.isfile(aProject.projConfFile) :
        terminal('\t\tProject: ' + aProject._projConfig['ProjectInfo']['projectName'] + ' (' + aProject._projConfig['ProjectInfo']['projectIDCode'] + ')')
        terminal('\t\tProject Type: ' + aProject._projConfig['ProjectInfo']['projectType'])
        if command :
            terminal('\t\tCurrent Command: ' + command + ' ' + str(opts))
        else :
            terminal('\n\t\tType \"rpm help\" for a list of current commands')
                
    else :
        # Just put out an almost blank line
        terminal(' ')

def processCommand (aProject) :
    '''Run the command and pass along the aProject object'''

    if command :
        if len(opts) >= 1 :
            try :
                aProject.run(command, opts, uConf._userConfig)
            except SyntaxError, err:
                terminal("\n" + str(err) + "\n")
                opts.insert(0, command)
                aProject.help(command, opts, uConf._userConfig)
        else :
            # If we seem to be short on options then we will just display the help
            # for this command
                terminalError('No options were give. There needs to be at least at project ID (-i) given with this command.')
                terminal('\nHelp for the \"' + command + '\" command:\n')
                aProject.help(command, opts, uConf._userConfig)


def closeSession (aProject) :
    '''Now write out the config files if needed'''

    if aProject.writeOutProjConfFile :
        if not writeConfFile(aProject._projConfig, aProject.projConfFile) :
            terminalError('Could not write to: project config file')
# FIXME: Why is this writing all the time?
    if uConf.writeOutUserConfFile :
        if not writeConfFile(uConf._userConfig, uConf.userConfFile) :
            terminalError('Could not write to: user config file')

    # Now trim the log file if it is needed
    if isConfSection(aProject._projConfig, 'Project') :
        aProject.trimLog(aProject._userConfig['System']['projLogLineLimit'])

    ## In case there are any Canadians using this, politely say good bye
    terminal('\n\t\tThank you, please come again!\n')


###############################################################################
######################## Load User and Project Info ###########################
###############################################################################

# Instantiate User classes
uConf = UserConfig(userHome, rpmHome)

# Every command should be preceeded by a project ID (pid) if that is the case
# find out what the path is and update the projHome setting. If the pid is not
# valid, stop here.
if pid :
    buildConfSection(uConf._userConfig, 'Projects')
    if pid in uConf._userConfig['Projects'].keys() :
        projHome = uConf._userConfig['Projects'][pid]['projectPath']

        # Instantiate the project class using the adjusted projHome path
        aProject = Project(uConf._userConfig, projHome, userHome, rpmHome)

        # Look for the project.conf and init the project if it is there.
        # Otherwise we will just pass through and quite
        if os.path.isfile(aProject.projConfFile) :
            aProject.initProject()

        welcomeMessage(aProject)
        processCommand(aProject)
        closeSession(aProject)

    else :
        if command == 'project_create' :
            # Instantiate the project class using the default projHome path
            aProject = Project(uConf._userConfig, projHome, userHome, rpmHome)
            welcomeMessage(aProject)
            processCommand(aProject)
            closeSession(aProject)
        else :
            terminal('Error: The project ID given [' + pid + '] is not valid. Please try again.')
else :
    aProject = Project(uConf._userConfig, projHome, userHome, rpmHome)
    terminal('\nAvailable RPM commands:\n')
    aProject.help(command, opts, uConf._userConfig)
    terminal('\nFor more help please use the -h option.\n\tFor example: rpm project_create -h\n')


#!/usr/bin/python
# -*- coding: utf-8 -*-
# version: 20110823
# By Dennis Drescher (dennis_drescher at sil.org


###############################################################################
######################### Description/Documentation ###########################
###############################################################################

# One script to rule them all.  This is the mother script of the whole system.
# This script will drive all processes and keep track of what happens in the
# project log in each respective project.

# History:
# 20111202 - djd - Start over with manager-centric model


###############################################################################
################################ Initialize RPM ###############################
###############################################################################
# Firstly, import all the standard Python modules we need for this process and
# set the base path

import os, sys

# Set basic system vars
#systemName = "Rapid Publication Manager (RPM)"
#systemVersion = "0.0.1"
#systemAbout = "RPM is a publishing management system written by the friendly developers at Payap University\'s Linguistics Institute (Text Unit). RPM stands for Rapid Publication Manager. It is currently being deployed in MSEAG and is under heavy development. Anyone wanting to try this system should be warned that it may not work in their context. However, the underlying principals of the system should work in any long document publishing environment. Therefore the package should be evaluated with that in mind. We welcome input and participation in this project. It is our hope it will be able to serve more than just MSEAG. For questions or more information please write: dennis_drescher@sil.org."

# Set the RPM base program path
rpmHome = os.environ.get('RPM_BASE')
if not rpmHome :
    rpmHome = os.path.join('usr', 'share', 'rpm')
    os.environ['RPM_BASE'] = rpmHome

# Set the user environment path
userHome = os.environ.get('RPM_USER')
if not userHome :
    sysHome = os.environ.get('HOME')
    userHome = os.path.join(sysHome, '.config', 'rpm')
    os.environ['RPM_USER'] = userHome

# Set the (potential) project home
projHome = os.getcwd()

# Set our paths to application resources
sys.path.insert(0, os.path.join(rpmHome, 'python_lib', 'rpm', 'core'))
sys.path.insert(0, os.path.join(rpmHome, 'python_lib', 'rpm', 'manager'))
sys.path.insert(0, os.path.join(rpmHome, 'python_lib', 'rpm', 'project'))
sys.path.insert(0, os.path.join(rpmHome, 'python_lib', 'rpm', 'component'))

# Load standard Python modules
import codecs, shutil, operator, argparse, subprocess, tarfile
from datetime import *
from configobj import ConfigObj


# Load the local classes
from proj_local import ProjLocal
from proj_log import ProjLog
from tools import *
from user_config import UserConfig
from proj_config import ProjConfig
from project import Project

# Instantiate User classes
local           = ProjLocal(rpmHome, userHome, projHome)
uc              = UserConfig(local)
log             = ProjLog(local, uc)

# Pull some info from the user config
systemName      = uc.userConfig['System']['systemName']
systemVersion   = uc.userConfig['System']['systemVersion']
systemAbout     = uc.userConfig['System']['systemAbout']

# Give a welcome message
terminal('\n\t\tWelcome to ' + systemName + '  ' + systemVersion + '\n')


###########################################################################
############################## RPM Functions ##############################
###########################################################################

def newProject (uc, pc, pid, ptype = None, pname = None) :
    '''Create a new publishing project.'''

    # Because the location of where a project is to be created could be
    # different than the cwd, we will count on pc.local to have all the
    # correct information. 
    
    # Check the ptype
    if not ptype :
        ptype = 'book'

    # Check the pname, make one up if there isn't any
    if not pname :
        pname = 'The ' + pid + ' project'

    # Run some basic tests to see if this project can be created
    # Look for project in current folder
    if not os.path.isfile(pc.local.projConfFile) :
        # Look for locked project in current folder
        if os.path.isfile(pc.local.projConfFile + pc.local.lockExt) :
            terminal('ERR: Halt! Locked project already defined in target folder')
            return
        # Look for project in parent folder (don't want project in project)
        elif os.path.isfile(os.path.join(os.path.dirname(pc.local.projHome), pc.local.projConfFileName)) :
            terminal('ERR: Halt! Live project already defined in parent folder')
            return
        # Look for locked project in parent folder (prevent project in project)
        elif os.path.isfile(os.path.join(os.path.dirname(pc.local.projHome), pc.local.projConfFileName + pc.local.lockExt)) :
            terminal('ERR: Halt! Locked project already defined in parent folder')
            return
        # Check if path to parent is valid
        elif not os.path.isdir(os.path.dirname(pc.local.projHome)) :
            terminal('ERR: Halt! Not a valid (parent) path: ' + os.path.dirname(pc.local.projHome))
            return
        # Test if this project already exists in the user's config file.
        elif uc.isRegisteredProject(pid) :
            terminal('ERR: Halt! ID [' + pid + '] already defined for another project')
            return
    else :
        terminal('ERR: Halt! A project already exsits in this location. Please remove it before continuing.')
        return

    # If we made it to this point, we need to make a new project folder
    if not os.path.exists(pc.local.projConfFolder) :
        os.makedirs(pc.local.projConfFolder)

    # Create a new version of the project config file
    pc.makeNewProjConf(pc.local, pid, ptype, pname)

    # Add project to local RPM project registry
    uc.registerProject(pid, pname, ptype, pc.local.projHome)

    # Report what we did
    terminal('Created new project [' + pid + ']')
    return True


def deleteProject (uc, pid = None) :
    '''Delete a project fromthe RPM system registry and from the hard drive.'''

    global local

    # If no pid was given this fails
    if not pid :
        terminal('Error: Project ID code not given or found. delete operation failed.')
        return

    # Check if project is registered with RPM and get real path and reinit local paths
    if not testForSetting(uc.userConfig, 'Projects', pid) :
        terminal('Error: [' + pid + '] not a valid registered project, cannot continue with delete operation.')
        return
    else :
        local = ProjLocal(rpmHome, userHome, uc.userConfig['Projects'][pid]['projectPath'])

    # Remove references from user rpm.conf
    if uc.unregisterProject(pid) :
        terminal('Removed [' + pid + '] from user configuration.')
    else :
        terminal('Failed to remove [' + pid + '] from user configuration.')

    # Delete everything in the project path
    if os.path.isdir(local.projHome) :
        shutil.rmtree(local.projHome)
        terminal('Removed project files for [' + pid + '] from hard drive.')
    else :
        terminal('Warning: [' + pid + '] project could not be found, unable to delete project files.')
        return

    # Report the process is done
    terminal('Removal process for [' + pid + '] is completed.')
    return True


def isProject (pid) :
    '''Look up in the user config to see if a project is registered.'''

    if pid in uc.userConfig['Projects'] :
        return True


def initProject (pid) :
    '''Initialize an existing project according to the project ID given.'''

    local   = ProjLocal(rpmHome, userHome, uc.userConfig['Projects'][pid]['projectPath'])
    pc      = ProjConfig(local)
    log     = ProjLog(local, uc)
    if testForSetting(pc.projConfig, 'ProjectInfo', 'projectIDCode') :
        aProject = Project(uc.userConfig, pc.projConfig, local, log)
        return aProject


def accessHtmlHelp () :
    '''Call on the RPM basic HTML help system.'''

    # Build the viewer command
    cmds = uc.userConfig['System']['htmlHelpViewerCommand']
    cmds.append(local.rpmHelpIndexFile)
    # Run the viewer command
    rCode = subprocess.call(cmds)


###############################################################################
############################# RPM Command Center ##############################
###############################################################################

# All command options must contain a project ID (-i). That is required. If one
# is not listed then the incoming command is either considered malformed or
# incomplete. If there is a way to figure out what the user might be needing
# the help system will be called. Otherwise, RPM will quite.

# The argument handler
def userArguments (args) :
    '''Process incoming command arguments.'''

    # Extra help access
    if sys.argv[1].lower() == 'help' :
        if args['about'] :
            terminal('\n' + systemName + ' version ' + systemVersion + '\n')
            terminal('About: ' + systemAbout + '\n')
            return

        if args['basic'] :
            accessHtmlHelp()
            return

    # Test project ID
    if sys.argv[1].lower() != 'project' :
        if not isProject(args['project_id']) :
            sys.exit('Error: Project ID given is not valid! Process halted.\n')
        else :
            # Now setup the project and look for and test the component type if needed
            aProject = initProject(args['project_id'])
            if sys.argv[2].lower() != 'settings' or sys.argv[2].lower() != 'locking' :
                if not aProject.isComponentType(args['component_type']) :
                    if not aProject.addComponentType(args['component_type']) :
                        sys.exit()

    # Project level commands
    if sys.argv[1].lower() == 'project' :
        # Creating a new project
        if args['add'] :
            if args['path'] :
                # If a project folder is given (other than CWD) We need to
                # resolve it and pass it on to proj config settings (internal)
                customLocal = resolvePath(args['path'])
                if not os.path.isdir(customLocal) :
                    sys.exit('Cannot resolve the given path. Process halting.')
                else :
                    projFolder = os.path.join(customLocal, args['project_id'])
            else :
                # With no different project location given we will make sure
                # we use the default projHome set when the script started.
                projFolder = os.path.join(projHome, args['project_id'])

            # Create the project
            local   = ProjLocal(rpmHome, userHome, projFolder)
            pc      = ProjConfig(local)
            newProject(uc, pc, args['project_id'], args['type'].lower(), args['name'])

        # Remove an exsisting project
        elif args['remove'] :
            deleteProject(uc, args['project_id'])

    # Group level commands
    elif sys.argv[1].lower() == 'group' :

        # Add a new component
        if args['add'] :
            aProject.addMetaComponent(args['component_id'], args['component_type'], args['force'])

        # Delete a component
        elif args['remove'] :
            aProject.deleteComponent(args['component_id'])
        # Render vs. view command is just a matter of forcing the component
        # to be rendered if render is selected by the user. Otherwise, if
        # only view is requested, force is set to False and the component
        # will not be rerendered if it already exsists.
        elif args['execute'] :
            aProject.renderGroup(args['component_id'], args['force'])

    # Component level commands
    elif sys.argv[1].lower() == 'component' :

        # Add a new component
        if args['add'] :
            if args['force'] :
                aProject.addComponent(args['component_id'], args['component_type'], args['force'])

        # Delete a component
        if args['remove'] :
            aProject.deleteComponent(args['component_id'])
        # Render vs. view command is just a matter of forcing the component
        # to be rendered if render is selected by the user. Otherwise, if
        # only view is requested, if force is set to False and the component
        # will not be rerendered if it already exsists.
        if args['execute'] :
            aProject.renderComponent(args['component_id'], args['force'])

    # Font level commands
    elif sys.argv[1].lower() == 'font' :
        aProject.createManager(args['component_type'], 'font')
        font = aProject.managers[args['component_type'] + '_Font'].checkForSubFont(args['font_id'])

        if args['add'] :
            # Physically install the font files
            aProject.managers[args['component_type'] + '_Font'].installFont(font, args['force'])
            # Record in the project the font meta data 
            aProject.managers[args['component_type'] + '_Font'].recordFont(args['component_type'], font, args['force'])
        elif args['remove'] :
            aProject.managers[args['component_type'] + '_Font'].removeFont(args['component_type'], font, args['force'])
        elif args['main'] :
            aProject.managers[args['component_type'] + '_Font'].setPrimaryFont(args['component_type'].capitalize(), font, args['force'])



# Move these to the style manager



    # Style level commands
    elif sys.argv[1].lower() == 'style' :

        if args['add'] :
            aProject.createStyleFile(args['component_type'], args['force'])
        elif args['remove'] :
            aProject.removeStyleFile(args['component_type'], args['force'])








    # Post processing commands
    elif sys.argv[1].lower() == 'process' :

        # Run a post process command on a component or component type
        # Because we can lock at all levels, there is no need for (-f --force)
        # to be used here. If a component ID is given it will only run on that
        # component. Otherwise, all components of the specified type.
        if args['execute'] :
            aProject.runPostProcess(args['component_type'], args['component_id'])

        # Install a custom or a default post process script, force to overwrite what is there
        elif args['add'] :
            if args['script'] :
                filePath = resolvePath(args['script'])
                if not os.path.isfile(filePath) :
                    terminal('The following path does not appear to be valid: ' + filePath)
                    sys.exit()
                aProject.installPostProcess(args['component_type'], filePath, args['force'])
        # Disconnect a post processing script from the component type (this does not remove it)
        elif args['remove'] :
            aProject.removePostProcess(args['component_type'])

    # Setting manipulation commands
    elif sys.argv[1].lower() == 'settings' :
        if isProject(args['project_id']) :
            aProject = initProject(args['project_id'])
            if args['configuration'] :
                aProject.changeConfigSetting(args['configuration'], args['section'], args['key'], args['value'])
        else :
            terminal('Cannot find [' + args['project_id'] + '] project.')

    # Locking commands
    elif sys.argv[1].lower() == 'locking' :
        if isProject(args['project_id']) :
            aProject = initProject(args['project_id'])

        # Lock the whole project
        if args['lock'] and not args['component_type'] and not args['component_id'] :
            aProject.lockProject()
        # Unlock the whole project
        elif args['unlock'] and not args['component_type'] and not args['component_id'] :
            aProject.unlockProject()
        # Lock a component type
        elif args['lock'] and args['component_type'] :
            aProject.lockComponentType(args['component_type'])
        # Unlock a component type
        elif args['unlock'] and args['component_type'] :
            aProject.unlockComponentType(args['component_type'])
        # Lock a component
        elif args['lock'] and args['component_id'] :
            aProject.lockComponent(args['component_id'])
        # Unlock a component
        elif args['unlock'] and args['component_id'] :
            aProject.unlockComponent(args['component_id'])

    # Totally lost
    else:
        terminal('Error: Command not recognized! ')
        sys.exit()

    # During a process, a number of log entries will be made and written out.
    # Over time the log file could get very large. To control the size, there
    # is a setting in the user config file that limits the number of lines in
    # the log file. The default is 1000 but it can be adjusted if needed. The
    # following call here will trim the log file to its specified limit. This
    # is done here as there should be no further operations done at this point.
    
    # Note: This will not work with "project" commands (aProject is not declaired)
#    if not sys.argv[1].lower() == 'project' :
#        if os.path.isfile(aProject.local.projLogFile) :
#            trimLog(aProject.local.projLogFile, uc.userConfig['System']['projLogLineLimit'])


###############################################################################
############################### Argparser Setup ###############################
###############################################################################

# We will try to maintain a common syntax in all the subparsers Some common
# argument options are:
#   -a = add something
#   -r = remove something
#   -e = execute something
#   -f = force the execution of something
#   -p = path (and file name) of something

# Setup the arg parser
parser = argparse.ArgumentParser(description=systemName)
subparsers = parser.add_subparsers(help='sub-command help')

# Add help subprocess arguments
helpCommand = subparsers.add_parser('help', help='General system help')

# Add main arguments (first postion options)
parser.add_argument('-a', '--about', action='store_true', help = 'Information about RPM')
parser.add_argument('-b', '--basic', action='store_true', help = 'Basic RPM help (in HTML)')

# Add project subprocess arguments
projCommand = subparsers.add_parser('project', help='General project management commands help')
projCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
projCommand.add_argument('-a', '--add', action='store_true', help='Add a new publishing project on this system.')
projCommand.add_argument('-r', '--remove', action='store_true', help='Remove a project permanently from the system. This will do just what is says. Be careful!')
projCommand.add_argument('-p', '--path', help='Path to the project home folder if the current working directory is not the actual target. This can be used when adding a project.')
projCommand.add_argument('-t', '--type', help='If creating a new project, give a valid project type code.')
projCommand.add_argument('-n', '--name', help='If creating a new project, give a human readable name to describe this project.')

# Add group subprocess arguments
groupCommand = subparsers.add_parser('group', help='General project component group management commands help')
groupCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
groupCommand.add_argument('component_type', help='The component type is needed for creating a new component group.')
groupCommand.add_argument('group_id', help='A specific group ID required for creating a new component group.')
groupCommand.add_argument('-a', '--add', action='store_true', help='Add a new component to this project.')
groupCommand.add_argument('-r', '--remove', action='store_true', help='remove an existing component from this project.')
groupCommand.add_argument('-f', '--force', action='store_true', help='Force an action if overriding a default non-action is needed.')
groupCommand.add_argument('-e', '--execute', action='store_true', help='Execute the render process for a component group in this project.')

# Add component subprocess arguments
compCommand = subparsers.add_parser('component', help='General project component management commands help')
compCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
compCommand.add_argument('component_type', help='The component type is needed for creating a new component.')
compCommand.add_argument('component_id', help='A specific component ID required for creating a new component.')
compCommand.add_argument('-a', '--add', action='store_true', help='Add a new component to this project.')
compCommand.add_argument('-r', '--remove', action='store_true', help='remove an existing component from this project.')
compCommand.add_argument('-f', '--force', action='store_true', help='Force an action if overriding a default non-action is needed.')
compCommand.add_argument('-e', '--execute', action='store_true', help='Execute the render process for a specific component in this project.')

# Add font subprocess arguments
fontCommand = subparsers.add_parser('font', help='General font handling commands help')
fontCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
fontCommand.add_argument('component_type', help='Specify the component type. This is required for all font functions.')
fontCommand.add_argument('font_id', help='The font family name ID. The ID given has to be a valid system font.')
fontCommand.add_argument('-a', '--add', action='store_true', help='Add a new font for a specific comonent type.')
fontCommand.add_argument('-r', '--remove', action='store_true', help='Remove the font of a specified ID from this project.')
fontCommand.add_argument('-f', '--force', action='store_true', help='Force the addition or removal of a font from the system even if it is used by other components.')
fontCommand.add_argument('-m', '--main', action='store_true', help='Set, the specified (valid system) font to be the main (primary) font for this component type.')

# Add style subprocess arguments
styleCommand = subparsers.add_parser('style', help='General style handling commands help')
styleCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
styleCommand.add_argument('component_type', help='The component type is needed when adding a style for this type of component.')
styleCommand.add_argument('-a', '--add', action='store_true', help='Add a new style for a specific comonent type.')
styleCommand.add_argument('-r', '--remove', action='store_true', help='Remove a style file for this component type.')
styleCommand.add_argument('-f', '--force', action='store_true', help='Force the addition or removal of a style from this component.')

# Add post processing subprocess arguments
processCommand = subparsers.add_parser('process', help='General settings for handling component post processing commands.')
processCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
processCommand.add_argument('component_type', help='Specify the component type. This is required for all font functions.')
processCommand.add_argument('-a', '--add', action='store_true', help='Install a post process into the project process folder. If you do not specify a process a default process script.')
processCommand.add_argument('-r', '--remove', action='store_true', help='Disconnect a post process from the component type. This does not remove the actual script from the project. That needs to be done manually.')
processCommand.add_argument('-f', '--force', action='store_true', help='Force a post process script to be updated, replaced or brought back to default condition for this component type.')
processCommand.add_argument('-c', '--component_id', help='When a valid component ID is given, a post process script for a specific component type will be run only on that component.')
processCommand.add_argument('-s', '--script', help='A valid path and file name of a specific post process script to be installed.')
processCommand.add_argument('-e', '--execute', action='store_true', help='Execute a post process script. If a valid component ID is not specified, it will run on all components of the type it is a part of.')

# Add settings subprocess arguments
settingsCommand = subparsers.add_parser('settings', help='General settings handling commands help')
settingsCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
settingsCommand.add_argument('-c', '--configuration', help='The configuration set that the target setting is from.')
settingsCommand.add_argument('-s', '--section', help='The section path to the key/value pare to be changed.')
settingsCommand.add_argument('-k', '--key', help='The key which has the value to be changed.')
settingsCommand.add_argument('-v', '--value', help='A new value to add or change to the specified key.')

# Add Project Locking subprocess arguments
lockCommand = subparsers.add_parser('locking', help='Commands for locking down projects or parts of a project. This will prevent accidental processing.')
lockCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
lockCommand.add_argument('lock_type', help='Specify either a valid component or component type to be locked. If nothing is specified the project will be locked so no processing can take place.')
lockCommand.add_argument('-l', '--lock', action='store_true', help='Lock a project or component. If a component or component type are not specified, the entire project will be locked and not available to any processes.')
lockCommand.add_argument('-u', '--unlock', action='store_true', help='Unlock a project or component. This is hyarchical. If the entire project is locked, unlocking component types or components cannot take place until the entire project is unlocked.')

# The following needs to be taken out

# Add testing subprocess arguments
#testCommand = subparsers.add_parser('test', help='General system testing commands help')
#testCommand.add_argument('-s', '--source_id', help='Example source ID of the test project taken from the example library you want to setup. This should be a valid ZIP file name, without the .zip extention.')
#testCommand.add_argument('-d', '--demo_id', help='Example demo ID of the publishing test project taken from the source example that was (or is to be) setup. The ID is combined with a \'.rpmDemo\' extention which should be a valid file name.')

# Send the collected arguments to the handler
userArguments(vars(parser.parse_args()))


###############################################################################
########################### Close out the session #############################
###############################################################################


# In case there are any Canadians using this, politely say good bye
terminal('\n\t\tThank you, please come again!\n')



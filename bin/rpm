#!/usr/bin/python
# -*- coding: utf-8 -*-
# version: 20110823
# By Dennis Drescher (dennis_drescher at sil.org


###############################################################################
######################### Description/Documentation ###########################
###############################################################################

# One script to rule them all.  This is the mother script of the whole system.
# This script will drive all processes and keep track of what happens in the
# project log in each respective project.

# History:
# 20111202 - djd - Start over with manager-centric model


###############################################################################
################################ Initialize RPM ###############################
###############################################################################
# Firstly, import all the standard Python modules we need for this process and
# set the base path

import os, sys

# Set basic system vars
systemName = "Rapid Publication Manager (RPM)"
systemVersion = "0.0.1"
systemAbout = "RPM is a publishing management system written by the friendly developers at Payap University\'s Linguistics Institute (Text Unit). RPM stands for Rapid Publication Manager. It is currently being deployed in MSEAG and is under heavy development. Anyone wanting to try this system should be warned that it may not work in their context. However, the underlying principals of the system should work in any long document publishing environment. Therefore the package should be evaluated with that in mind. We welcome input and participation in this project. It is our hope it will be able to serve more than just MSEAG. For questions or more information please write: dennis_drescher@sil.org."

# Set the RPM base program path
rpmHome = os.environ.get('RPM_BASE')
if not rpmHome :
    rpmHome = os.path.join('usr', 'share', 'rpm')
    os.environ['RPM_BASE'] = rpmHome

# Set the user environment path
userHome = os.environ.get('RPM_USER')
if not userHome :
    sysHome = os.environ.get('HOME')
    userHome = os.path.join(sysHome, '.config', 'rpm')
    os.environ['RPM_USER'] = userHome

# Set the (potential) project home
projHome = os.getcwd()

# Set our paths to application resources
sys.path.insert(0, os.path.join(rpmHome, 'python_lib', 'rpm', 'core'))
sys.path.insert(0, os.path.join(rpmHome, 'python_lib', 'rpm', 'manager'))
sys.path.insert(0, os.path.join(rpmHome, 'python_lib', 'rpm', 'project'))
sys.path.insert(0, os.path.join(rpmHome, 'python_lib', 'rpm', 'component'))

# Load standard Python modules
import codecs, shutil, operator, argparse, subprocess, tarfile
from datetime import *
from configobj import ConfigObj


# Load the local classes
from proj_local import ProjLocal
from proj_log import ProjLog
from tools import *
from user_config import UserConfig
from proj_config import ProjConfig
from project import Project

# Instantiate User classes
local           = ProjLocal(rpmHome, userHome, projHome)
uc              = UserConfig(local)
log             = ProjLog(local, uc)

# Give a welcome message
terminal('\n\t\tWelcome to ' + systemName + '  ' + systemVersion + '\n')


###########################################################################
############################## RPM Functions ##############################
###########################################################################

#def newProject (uc, pc, pid, pdir = None, ptype = None, pname = None) :
def newProject (uc, pc, pid, ptype = None, pname = None) :
    '''Create a new publishing project.'''

    # Because the location of where a project is to be created could be
    # different than the cwd, we will count on pc.local to have all the
    # correct information. 
    
    # FIXME: Move the ptype and pname vars up to the arg processor which
    # calls this function.

    # Check the ptype
    if not ptype :
        ptype = 'book'

    # Check the pname, make one up if there isn't any
    if not pname :
        pname = 'The ' + pid + ' project'

    # Run some basic tests to see if this project can be created
    # Look for project in current folder
    if not os.path.isfile(pc.local.projConfFile) :
        # Look for locked project in current folder
        if os.path.isfile(pc.local.projConfFile + pc.local.lockExt) :
            terminal('ERR: Halt! Locked project already defined in target folder')
            return
        # Look for project in parent folder (don't want project in project)
        elif os.path.isfile(os.path.join(os.path.dirname(pc.local.projHome), pc.local.projConfFileName)) :
            terminal('ERR: Halt! Live project already defined in parent folder')
            return
        # Look for locked project in parent folder (prevent project in project)
        elif os.path.isfile(os.path.join(os.path.dirname(pc.local.projHome), pc.local.projConfFileName + pc.local.lockExt)) :
            terminal('ERR: Halt! Locked project already defined in parent folder')
            return
        # Check if path to parent is valid
        elif not os.path.isdir(os.path.dirname(pc.local.projHome)) :
            terminal('ERR: Halt! Not a valid (parent) path: ' + os.path.dirname(pc.local.projHome))
            return
        # Test if this project already exists in the user's config file.
        elif uc.isRegisteredProject(pid) :
            terminal('ERR: Halt! ID [' + pid + '] already defined for another project')
            return
    else :
        terminal('ERR: Halt! A project already exsits in this location. Please remove it before continuing.')
        return

    # If we made it to this point, we need to make a new project folder
    if not os.path.exists(pc.local.projConfFolder) :
        os.makedirs(pc.local.projConfFolder)

    # Create a new version of the project config file
    pc.makeNewProjConf(pc.local, pid, ptype, pname)

    # Add project to local RPM project registry
    uc.registerProject(pid, pname, ptype, pc.local.projHome)

    # Report what we did
    terminal('Created new project [' + pid + ']')
    return True


def addComponentType (uc, pid, cType) :
    '''Add a component type to a project.'''

    if isProject(pid) :
        aProject = initProject(pid)
        aProject.addComponentType(cType)


def deleteProject (uc, pid = None) :
    '''Delete a project fromthe RPM system registry and from the hard drive.'''

    global local

    # If no pid was given this fails
    if not pid :
        terminal('Error: Project ID code not given or found. delete operation failed.')
        return

    # Check if project is registered with RPM and get real path and reinit local paths
    if not testForSetting(uc.userConfig, 'Projects', pid) :
        terminal('Error: [' + pid + '] not a valid registered project, cannot continue with delete operation.')
        return
    else :
        local = ProjLocal(rpmHome, userHome, uc.userConfig['Projects'][pid]['projectPath'])

    # Remove references from user rpm.conf
    if uc.unregisterProject(pid) :
        terminal('Removed [' + pid + '] from user configuration.')
    else :
        terminal('Failed to remove [' + pid + '] from user configuration.')

    # Delete everything in the project path
    if os.path.isdir(local.projHome) :
        shutil.rmtree(local.projHome)
        terminal('Removed project files for [' + pid + '] from hard drive.')
    else :
        terminal('Warning: [' + pid + '] project could not be found, unable to delete project files.')
        return

    # Report the process is done
    terminal('Removal process for [' + pid + '] is completed.')
    return True


def isProject (pid) :
    '''Look up in the user config to see if a project is registered.'''

    try :
        if pid in uc.userConfig['Projects'] :
            return True
    except :
        return False


def initProject (pid) :
    '''Initialize an existing project according to the project ID given.'''

    local   = ProjLocal(rpmHome, userHome, uc.userConfig['Projects'][pid]['projectPath'])
    pc      = ProjConfig(local)
    log     = ProjLog(local, uc)
    if testForSetting(pc.projConfig, 'ProjectInfo', 'projectIDCode') :
        aProject = Project(uc.userConfig, pc.projConfig, local, log)
        return aProject


def accessHtmlHelp () :
    '''Call on the RPM basic HTML help system.'''

    # Build the viewer command
    cmds = uc.userConfig['System']['htmlHelpViewerCommand']
    cmds.append(local.rpmHelpIndexFile)
    # Run the viewer command
    rCode = subprocess.call(cmds)


###############################################################################
############################### Testing Functions #############################
###############################################################################


def getExampleSourceProject (exampID) :
    '''Create a test project from example projects located in the 
    example_lib folder in the RPM system. This is for system testing
    and nifty canned demos.'''

    exampleFile = os.path.join(local.rpmExamplesFolder, exampID + '.tar.gz')
    demoFile = os.path.join(local.projHome, exampID, exampID + '.rpmDemo')
    thisTarFile = tarfile.open(exampleFile, 'r')
    if os.path.isfile(exampleFile) :
        thisTarFile.extractall()
        terminal('Extracted the [' + exampID + '] ParaTExt example project.')

def runExamplePubDemoProject (demoID) :
    '''Run an example demo file to test/demonstrate a project.'''

    # FIXME: Everywhere else we use subprocess.call() to do a process.  However,
    # in this case it takes too much fiddling to get a these more complex RPM
    # calls to run from within RPM.  To make it easy, we use os.system() to make
    # the call out.
    demoFile = os.path.join(local.projHome, demoID + '.rpmDemo')
    if os.path.isfile(demoFile) :
        demo = codecs.open(demoFile, "r", encoding='utf_8')
        for line in demo :
            if line[:1] != '#' and line[:1] != '' and line[:1] != '\n' :
                os.system(line)
        return True
    else :
        terminal('File not found: ' + fName(demoFile))


###############################################################################
############################# RPM Command Center ##############################
###############################################################################

# All command options must contain a project ID (-i). That is required. If one
# is not listed then the incoming command is either considered malformed or
# incomplete. If there is a way to figure out what the user might be needing
# the help system will be called. Otherwise, RPM will quite.

# The argument handler
def userArguments (args) :
    '''Process incoming command arguments.'''

    def compTypeNotValid (cType) :
        terminal('The component type given [' + cType + '] is not valid.')


    def noResolve (path) :
        terminal('Cannot resolve path. The path [' + path + '] is not valid! Process halting.')



    def resolvePath (path) :
        '''Resolve the '~' in a path if there is one with the actual home path.'''

        if path[0] == '~' :
            # Look for "~/" shorthand path and replace it with the actual "home"
            return path.replace('~', os.environ.get('HOME'))
        else :
            # Otherwise run abspath on it and send it on
            return os.path.abspath(path)


    # Project level commands
    if sys.argv[1].lower() == 'project' :
        # Creating a new project
        if args['project_new'] :
        # FIXME: Add additional vars to this for project type and name and add them to the options
            if args['project_folder'] :
                # If a project folder is given (other than CWD) We need to
                # resolve it and pass it on to proj config settings (internal)
                customLocal = resolvePath(args['project_folder'])
                if not os.path.isdir(customLocal) :
                    noResolve(customLocal)
                    sys.exit()

                projFolder = os.path.join(customLocal, args['project_id'])
                local   = ProjLocal(rpmHome, userHome, projFolder)
                pc      = ProjConfig(local)
                newProject(uc, pc, args['project_id'])
            else :
                # With no different project location given we will make sure
                # we use the default projHome set when the script started.
                projFolder = os.path.join(projHome, args['project_id'])
                local   = ProjLocal(rpmHome, userHome, projFolder)
                pc      = ProjConfig(local)
                newProject(uc, pc, args['project_id'])

        # Deleting an exsisting project
        elif args['project_delete'] :
            deleteProject(uc, args['project_id'])

        # Add a component type to an exsisting project
        elif args['component_type'] :
            addComponentType(uc, args['project_id'], args['component_type'])

    # Component level commands
    elif sys.argv[1].lower() == 'component' :
        if isProject(args['project_id']) :
            aProject = initProject(args['project_id'])
            if not aProject.isComponentType(args['component_type']) :
                compTypeNotValid(args['component_type'])
                return False
            # Add a new component
            if args['component_new'] :
                force = None
                if args['component_force'] :
                    force = True
                if args['component_type'] :
                    if args['component_meta'] :
                        aProject.addMetaComponent(args['component_id'], args['component_meta'], args['component_type'], force)
                    else :
                        aProject.addComponent(args['component_id'], args['component_type'], force)
                else :
                    terminal('Must supply a component type (-t xxxx) to create a component.')
            # Delete a component
            if args['component_delete'] :
                aProject.deleteComponent(args['component_id'])
            # Render vs. view command is just a matter of forcing the component
            # to be rendered if render is selected by the user. Otherwise, if
            # only view is requested, force is set to False and the component
            # will not be rerendered if it already exsists.
            if args['component_render'] :
                force = True
                aProject.renderComponent(args['component_id'], force)
            # View only
            if args['component_view'] :
                force = False
                aProject.renderComponent(args['component_id'], force)

        else :
            terminal('Cannot find [' + args['project_id'] + '] project.')

    # Font level commands
    elif sys.argv[1].lower() == 'font' :
        if isProject(args['project_id']) :
            aProject = initProject(args['project_id'])
            if not aProject.isComponentType(args['component_type']) :
                compTypeNotValid(args['component_type'])
                return False

            if args['font_new'] :
                aProject.addComponentFont(args['component_type'], args['font_name'])
            elif args['font_remove'] :
                aProject.removeComponentFont(args['component_type'], args['font_name'])
            elif args['font_primary'] :
                aProject.setPrimaryFont(args['component_type'], args['font_name'])
            elif args['font_mapping'] :
                aProject.addFontMapping(args['component_type'], args['font_name'], args['font_mapping'])
        else :
            terminal('Cannot find [' + args['project_id'] + '] project.')

    # Style level commands
    elif sys.argv[1].lower() == 'style' :
        if isProject(args['project_id']) :
            aProject = initProject(args['project_id'])
            if not aProject.isComponentType(args['component_type']) :
                compTypeNotValid(args['component_type'])
                return False

            if args['style_default'] :
                aProject.createDefaultStyleFile(args['component_type'])
            elif args['style_override'] :
                aProject.createCustomStyleFile(args['component_type'])
            elif args['style_component'] :
                aProject.createComponentStyleFile(args['component_id'])
        else :
            terminal('Cannot find [' + args['project_id'] + '] project.')

    # Setting manipulation commands
    elif sys.argv[1].lower() == 'settings' :
        if isProject(args['project_id']) :
            aProject = initProject(args['project_id'])
            if args['configuration'] :
                aProject.changeConfigSetting(args['configuration'], args['section'], args['key'], args['value'])
        else :
            terminal('Cannot find [' + args['project_id'] + '] project.')

    # Post processing commands
    elif sys.argv[1].lower() == 'process' :
        if isProject(args['project_id']) :
            aProject = initProject(args['project_id'])
            if not aProject.isComponentType(args['component_type']) :
                compTypeNotValid(args['component_type'])
                return False

        # Run a post process command on a component or component type
        if args['run_process'] :
            if args['component_id'] :
                aProject.runPostProcess(args['component_type'], args['component_id'])
            else :
                aProject.runPostProcess(args['component_type'])

        # Install a custom or a default post process script
        elif args['install_process'] :
            if args['file_name'] :
                filePath = resolvePath(args['file_name'])
                print filePath
                if not os.path.isfile(filePath) :
                    noResolve(filePath)
                    sys.exit()
                aProject.installPostProcess(args['component_type'], filePath)
            else :
                aProject.installPostProcess(args['component_type'])

    # Locking commands
    elif sys.argv[1].lower() == 'locking' :
        if isProject(args['project_id']) :
            aProject = initProject(args['project_id'])

        # Lock the whole project
        if args['lock'] and not args['component_type'] and not args['component_id'] :
            aProject.lockProject()
        # Unlock the whole project
        elif args['unlock'] and not args['component_type'] and not args['component_id'] :
            aProject.unlockProject()
        # Lock a component type
        elif args['lock'] and args['component_type'] :
            aProject.lockComponentType(args['component_type'])
        # Unlock a component type
        elif args['unlock'] and args['component_type'] :
            aProject.unlockComponentType(args['component_type'])
        # Lock a component
        elif args['lock'] and args['component_id'] :
            aProject.lockComponent(args['component_id'])
        # Unlock a component
        elif args['unlock'] and args['component_id'] :
            aProject.unlockComponent(args['component_id'])

    # Testing commands
    elif sys.argv[1].lower() == 'test' :
        if args['source_id'] :
            getExampleSourceProject(args['source_id'])

        if args['demo_id'] :
            runExamplePubDemoProject(args['demo_id'])

    # Extra help access
    elif sys.argv[2].lower() == 'help' :
        if args['about'] :
            terminal('\n' + systemName + ' version ' + systemVersion + '\n')
            terminal('About: ' + systemAbout + '\n')

        if args['basic'] :
            accessHtmlHelp()

    # Totally lost
    else:
        terminal('Error: Command not recognized! ')
        sys.exit()

    # During a process, a number of log entries will be made and written out.
    # Over time the log file could get very large. To control the size, there
    # is a setting in the user config file that limits the number of lines in
    # the log file. The default is 1000 but it can be adjusted if needed. The
    # following call here will trim the log file to its specified limit. This
    # is done here as there should be no further operations done at this point.
    
    # Note: This will not work with "project" commands (aProject is not declaired)
#    if not sys.argv[1].lower() == 'project' :
#        if os.path.isfile(aProject.local.projLogFile) :
#            trimLog(aProject.local.projLogFile, uc.userConfig['System']['projLogLineLimit'])


# Setup the arg parser
parser = argparse.ArgumentParser(description=systemName)
subparsers = parser.add_subparsers(help='sub-command help')

# Add main arguments (first postion options)
parser.add_argument('-a', '--about', action='store_true', help = 'About RPM')
parser.add_argument('-b', '--basic', action='store_true', help = 'Basic RPM help (in HTML)')

# Add project subprocess arguments
projCommand = subparsers.add_parser('project', help='General project management commands help')
projCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
projCommand.add_argument('-n', '--project_new', action='store_true', help='Create a new project on this computer.')
projCommand.add_argument('-d', '--project_delete', action='store_true', help='Delete a project permanently from the system. This will do just what is says. Be careful!')
projCommand.add_argument('-f', '--project_folder', help='Location of the project home folder if the current working directory is not the actual target. This is used only for project creation (-n).')
projCommand.add_argument('-t', '--component_type', help='Add a component type to the project.')

# Add component subprocess arguments
compCommand = subparsers.add_parser('component', help='General project component management commands help')
compCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
compCommand.add_argument('component_type', help='The component type is needed for creating a new component.')
compCommand.add_argument('component_id', help='A specific component ID required for creating a new component.')
compCommand.add_argument('-n', '--component_new', action='store_true', help='Create a new component for this project.')
compCommand.add_argument('-d', '--component_delete', action='store_true', help='Delete an existing component from this project.')
compCommand.add_argument('-f', '--component_force', action='store_true', help='Force the install (reinstall) of a component. This is used with the -n command.')
compCommand.add_argument('-m', '--component_meta', help='Create a list of components for this new meta component. They must be of the same type.')
compCommand.add_argument('-r', '--component_render', action='store_true', help='Render a single component in this project.')
compCommand.add_argument('-v', '--component_view', action='store_true', help='View the rendered output of a specific component, if it does not exsist it will render the component as well.')

# Add font subprocess arguments
fontCommand = subparsers.add_parser('font', help='General font handling commands help')
fontCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
fontCommand.add_argument('component_type', help='Specify the component type. This is required for all font functions.')
fontCommand.add_argument('-f', '--font_name', help='The font family name. The name given has to have an RPM font configuration file associated with it.')
fontCommand.add_argument('-n', '--font_new', action='store_true', help='Add a new font for this project.')
fontCommand.add_argument('-r', '--font_remove', action='store_true', help='Remove the font named in -f from this project.')
fontCommand.add_argument('-p', '--font_primary', action='store_true', help='Set, and install if necessary, the primary font for this project. The font family name given has to have an RPM font configuration file associated with it.')
fontCommand.add_argument('-m', '--font_mapping', help='Add a font mapping for a specified font and component type.')

# Add style subprocess arguments
styleCommand = subparsers.add_parser('style', help='General font handling commands help')
styleCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
styleCommand.add_argument('component_type', help='The component type is needed when adding a style for this type of component.')
styleCommand.add_argument('-d', '--style_default', action='store_true', help='Create a default style file for this component type.')
styleCommand.add_argument('-o', '--style_override', action='store_true', help='Create a custom style (override) file for this component type.')
styleCommand.add_argument('-c', '--style_component', action='store_true', help='Create a component level style override file.')

# Add settings subprocess arguments
settingsCommand = subparsers.add_parser('settings', help='General settings handling commands help')
settingsCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
settingsCommand.add_argument('-c', '--configuration', help='The configuration set that the target setting is from.')
settingsCommand.add_argument('-s', '--section', help='The section path to the key/value pare to be changed.')
settingsCommand.add_argument('-k', '--key', help='The key which has the value to be changed.')
settingsCommand.add_argument('-v', '--value', help='A new value to add or change to the specified key.')

# Add Post Processing subprocess arguments
processCommand = subparsers.add_parser('process', help='General settings for handling component post processing commands.')
processCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
processCommand.add_argument('component_type', help='Specify the component type. This is required for all font functions.')
processCommand.add_argument('-c', '--component_id', help='If used with the -r command, a post process will run on only the specified component.')
processCommand.add_argument('-r', '--run_process', action='store_true', help='Run the post_process.py script. If not component (-c) is specified, it will run on all components of the specified type.')
processCommand.add_argument('-i', '--install_process', action='store_true', help='Install the default post_process.py script for a component type into the project process folder. If you have a specific system compatable script you wish to install, use the -f argument to point to it.')
processCommand.add_argument('-f', '--file_name', help='The path and file name of a specific post process to be installed.')

# Add Project Locking subprocess arguments
lockCommand = subparsers.add_parser('locking', help='Commands for locking down projects or parts of a project. This will prevent accidental processing.')
lockCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
lockCommand.add_argument('-l', '--lock', action='store_true', help='Lock a project or component. If a component or component type are not specified, the entire project will be locked and not available to any processes.')
lockCommand.add_argument('-u', '--unlock', action='store_true', help='Unlock a project or component. This is hyarchical. If the entire project is locked, unlocking component types or components cannot take place until the entire project is unlocked.')
lockCommand.add_argument('-c', '--component_id', help='If used with the -l or -u commands, and the project or component type is not locked, this will lock an individual component from being processed.')
lockCommand.add_argument('-t', '--component_type', help='If used with the -l or -u commands, and the project is not locked, this will lock an component type to prevent processes from happening to any components of that type.')

# Add testing subprocess arguments
testCommand = subparsers.add_parser('test', help='General system testing commands help')
testCommand.add_argument('-s', '--source_id', help='Example source ID of the test project taken from the example library you want to setup. This should be a valid ZIP file name, without the .zip extention.')
testCommand.add_argument('-d', '--demo_id', help='Example demo ID of the publishing test project taken from the source example that was (or is to be) setup. The ID is combined with a \'.rpmDemo\' extention which should be a valid file name.')

# Add help subprocess arguments
helpCommand = subparsers.add_parser('help', help='General system help')

# Send the collected arguments to the handler
userArguments(vars(parser.parse_args()))


###############################################################################
########################### Close out the session #############################
###############################################################################


# In case there are any Canadians using this, politely say good bye
terminal('\n\t\tThank you, please come again!\n')



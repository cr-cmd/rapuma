#!/usr/bin/python
# -*- coding: utf-8 -*-
# By Dennis Drescher (dennis_drescher at sil.org


###############################################################################
######################### Description/Documentation ###########################
###############################################################################

# One script to rule them all.  This is the main Rapuma engine script.
# This script will drive all processes and keep track of what happens in the
# project log in each respective project.


###############################################################################
################################ Initialize Rapuma ###############################
###############################################################################
# Firstly, import all the standard Python modules we need for this process and
# set the base path

import os, sys
from functools import partial

# Set the Rapuma base program paths
rapumaHome = os.environ.get('RAPUMA_BASE')
sysHome = os.environ.get('HOME')
if not rapumaHome :
    for t in (os.path.join(sysHome, '.local'), '/usr/local', '/usr') :
        rapumaHome = os.path.join(t, 'share', 'rapuma')
        if os.path.exists(os.path.join(rapumaHome, 'resources')) :
            os.environ['RAPUMA_BASE'] = rapumaHome
            break

# Set the user environment path
userHome = os.environ.get('RAPUMA_USER')
if not userHome :
    userHome = os.path.join(sysHome, '.config', 'rapuma')
    os.environ['RAPUMA_USER'] = userHome

# Set the (potential) project home
projHome = os.getcwd()

# Load standard Python modules
import codecs, shutil, operator, argparse, subprocess, zipfile, tempfile
from datetime import *
from configobj import ConfigObj

# Load the local classes
from rapuma.core.proj_local         import ProjLocal
from rapuma.core.proj_log           import ProjLog
from rapuma.core.tools              import *
from rapuma.core.user_config        import UserConfig
from rapuma.core.proj_config        import ProjConfig
from rapuma.core.proj_setup         import ProjSetup
from rapuma.core.proj_backup        import ProjBackup
from rapuma.core.proj_binding       import Binding
from rapuma.core.proj_commander     import Commander
from rapuma.core.proj_compare       import Compare
from rapuma.core.page_background    import PageBackground
from rapuma.project.project         import Project

# Instantiate User classes
local           = ProjLocal(rapumaHome, userHome, projHome)
uc              = UserConfig(rapumaHome, userHome)
log             = ProjLog(local, uc)

# Set some global vars
systemName      = 'Rapuma (Rapid Publication Manager)'
systemAbout     = 'Rapuma is a publishing management system written by the friendly developers at Payap University\'s Linguistics Institute (Text Unit). Rapuma stands for Rapid Publication Manager. It is currently being deployed in MSEAG and is under heavy development. Anyone wanting to try this system should be warned that it may not work in their context. However, the underlying principals of the system should work in any long document publishing environment. Therefore the package should be evaluated with that in mind. We welcome input and participation in this project. It is our hope it will be able to serve more than just MSEAG. For questions or more information please write: dennis_drescher@sil.org.'
systemVersion   = '0.1.20130326200555'

# Give a welcome message
terminal('\n\t\tWelcome to ' + systemName)
terminal('\n\t\t\tVersion ' + systemVersion + '\n')

###########################################################################
########################### Rapuma Functions ##############################
###########################################################################

def hasValidSourcePath (gid, csid) :
    '''Check if there is one, see if it is valid.'''

    try :
        path = uc.userConfig['Projects'][self.projectIDCode][csid + '_sourcePath']
        return os.path.isdir(resolvePath(path))
    except :
        return False


def isProject (pid) :
    '''Look up in the user config to see if a project is registered.
    Return False if it is not.'''

    try :
        if pid in uc.userConfig['Projects'].keys() :
            return True
    except :
        return False


def isTemplate (tid) :
    '''Check to see if a template exsists in the user's template store area.'''

    try :
        templates = uc.userConfig['Resources']['templates']
        if tid + '.zip' in os.listdir(templates) :
            return True
    except :
        return False


def initProject (pid, gid) :
    '''Initialize an existing project according to the project ID given.'''

    local   = ProjLocal(rapumaHome, userHome, uc.userConfig['Projects'][pid]['projectPath'])
    pc      = ProjConfig(local)
    log     = ProjLog(local, uc)
    if testForSetting(pc.projConfig, 'ProjectInfo', 'projectIDCode') :
        aProject = Project(uc.userConfig, pc.projConfig, local, log, systemVersion, gid)
        return aProject


def accessHtmlHelp () :
    '''Call on the Rapuma basic HTML help system.'''

    # Build the viewer command
    cmds = uc.userConfig['System']['htmlHelpViewerCommand']
    cmds.append(local.rapumaHelpIndexFile)
    # Run the viewer command
    rCode = subprocess.call(cmds)


###############################################################################
########################### Rapuma Command Center #############################
###############################################################################

# All command options must contain a project ID (-i). That is required. If one
# is not listed then the incoming command is either considered malformed or
# incomplete. If there is a way to figure out what the user might be needing
# the help system will be called. Otherwise, Rapuma will quite.

# The argument handler
def userArguments (args, local) :
    '''Process incoming command arguments.'''

#    global local

    # Pre-command process: Extra help access
    if sys.argv[1].lower() == 'help' :
        if args.about :
            terminal('\n' + systemName + ' version ' + systemVersion + '\n')
            terminal('About: ' + systemAbout + '\n')
            return
        if args.basic :
            accessHtmlHelp()
            return

    # Pre-command process: System level commands
    if sys.argv[1].lower() == 'system' :
        if args.user_name :
            uc.setSystemSettings('userName', args.user_name)
        elif args.resources :
            uc.setSystemSettings('resources', args.resources)
    # Test for valid project ID
    elif sys.argv[1].lower() != 'project' :
        isProject(args.project_id)

    # Command processing
    # Dummy place holder for 'system' which as actually processed above
    if sys.argv[1].lower() == 'system' :
        pass

    # Project level commands
    elif sys.argv[1].lower() == 'project' :
        pid = args.project_id
        # Source path is optional but if given, resolve it
        if args.sourcePath :
            sourcePath = resolvePath(args.sourcePath)
            if not os.path.exists(sourcePath) :
                sys.exit('\nERROR: Path is not valid. Process halting.\n')
        # Target path is optional also but if given, resolve it
        if args.targetPath :
            targetPath = resolvePath(args.targetPath)
            if not os.path.exists(targetPath) :
                sys.exit('\nERROR: Path is not valid. Process halting.\n')

        # Create/refresh helper scripts
        if args.scripts :
            Commander(pid).updateScripts()
            return True

        # Remove an exsisting project
        if args.delete :
            ProjSetup(pid).deleteProject()
            return True

        # Restore (or revert to) the last backup
        if args.restore == 'backup' :
            if isProject(pid) :
                ProjBackup(pid).restoreBackup(pid)
            else :
                if args.targetPath :
                    ProjBackup(pid).restoreBackup(os.path.join(targetPath, pid))
                else :
                    sys.exit('\nERROR: To restore this backup, a path must be provided with -g. Process halting.\n')
        # Update (get rained on) from the cloud
        elif args.restore == 'cloud' :
            if isProject(pid) :
                ProjBackup(pid).pullFromCloud()
            else :
                if args.targetPath :
                    if os.path.exists(resolvePath(args.targetPath)) :
                        ProjBackup(pid).pullFromCloud(os.path.join(resolvePath(args.targetPath), pid))
                    else :
                        sys.exit('\nERROR: Path is not valid. Process halting.\n')
                else :
                    sys.exit('\nERROR: To get rain from this cloud, a path must be provided with -g. Process halting.\n')

        # Commands to preserve project data. (Check PID and if necessary TID before passing it on)
        # Archive the project
        elif args.preserve == 'archive' :
            ProjBackup(pid).archiveProject()
        # Backup the project (simple)
        elif args.preserve == 'backup' :
            ProjBackup(pid).backupProject()
        # Create a template of the current project
        elif args.preserve == 'template' :
            if isTemplate(args.template) :
                sys.exit('\nError: This template [' + args.template + '] already exsists. Process halted.\n')
            ProjBackup(pid).projectToTemplate(args.template)
        # Backup (evaporate) to cloud
        elif args.preserve == 'cloud' :
            ProjBackup(pid).pushToCloud()

        # Creating a new project from a template, archive, or scratch
        else :
            # First test for some necessary params
            if not args.targetPath :
                # A path must be given
                sys.exit('\nERROR: No path for this project has been given. Process halting.\n')
            else :
                projFolder = os.path.join(targetPath, pid)

            # New (to current system) project from archive
            if args.restore == 'archive' :
                ProjBackup(pid).restoreArchive(targetPath, sourcePath)
            # New project from template
            if args.restore == 'template' :
                templateSource = ''
                if sourcePath :
                    templateSource = os.path.join(sourcePath, pid + '.zip')
                ProjBackup(pid).templateToProject(args.name, templateSource)
            # Just creating from scratch
            else :
                # Create a new project
                if not args.media in ['book'] :
                    sys.exit('\nERROR: Media type given: [' + args.media + '] is not valid. Process halting.\n')
                if not args.name :
                    sys.exit('\nERROR: Must provide a descriptive name (-n) for this new project. Process halting.\n')
                nProjPath = os.path.join(targetPath, pid)
                ProjSetup(pid).newProject(nProjPath, args.media, args.name, systemVersion, '')

    # Group level commands
    elif sys.argv[1].lower() == 'group' :
        aProject = initProject(args.project_id, args.group_id)
        # Add a new group
        if args.add :
            if not args.cid_list :
                sys.exit('\nERROR: Must provide a list (-i) of one or more valid component IDs when adding a group. Process halted!\n')
            elif not args.component_type :
                sys.exit('\nERROR: Must provide a component type (-c) ID when adding a group. Process halted!\n')
            elif not args.source_id :
                sys.exit('\nERROR: Must provide a source ID (-d) ID when adding a group. Process halted!\n')
            elif args.source :
                if not resolvePath(args.source) :
                    sys.exit('\nERROR: Must provide a valid path to the source (-s) ID when adding a group. Process halted!\n')
            elif args.source_id :
                if not hasValidSourcePath(args.group_id, args.source_id) :
                    sys.exit('\nERROR: No source path found for this source ID. Must provide a valid path to the source (-s) ID when adding a group. Process halted!\n')
            # Having sorted through any potential problems, try adding the group
            ProjSetup(args.project_id).addGroup(args.component_type, args.group_id, args.cid_list, args.source_id, resolvePath(args.source), args.force)
        # Remove a group from the project
        elif args.remove :
            ProjSetup(args.project_id).removeGroup(args.group_id, args.force)
            if str2bool(uc.userConfig['System']['autoHelperScripts']) :
                Commander(args.project_id).removeScripts()
        # Update a component, --source is optional but if given it will
        elif args.update :
            # overwrite the current setting. The --force setting will be needed
            # to unlock the component
            ProjSetup(args.project_id).updateGroup(args.group_id, args.cid_list, args.source, args.force)
        # Execute/render a group of components
        elif args.execute :
#            import pdb; pdb.set_trace()
            aProject = initProject(args.project_id, args.group_id)
            if args.cid_list :
                if not aProject.isValidCidList(args.group_id, args.cid_list) :
                    sys.exit('\nERROR: Must provide a valid list (-i) of one or more component IDs in the provided list are not a part of this group. Process halted!\n')
            if aProject.isGroup(args.group_id) :
                aProject.renderGroup(args.group_id, args.cid_list, args.force)
            else :
                sys.exit('\nERROR: The group ID given is not found in this project. Must provide a valid group ID. Process halted!\n')
        # Get a whole list of component IDs and names
        elif args.output_list :
            aProject.listAllComponents(args.component_type)
        # Turn on or off preprocessing on import or updating (specific for cType)
        elif args.preprocess :
            aProject.turnOnOffPreprocess(args.group_id, args.preprocess)
        # Lock group
        if args.lock :
            ProjSetup(args.project_id).lockUnlock(args.group_id)
        # Unlock group
        elif args.unlock :
            ProjSetup(args.project_id).lockUnlock(args.group_id)

    # Component level commands
    elif sys.argv[1].lower() == 'component' :
        # Render vs. view command is just a matter of forcing the component
        # to be rendered if render is selected by the user. Otherwise, if
        # only view is requested, if force is set to False and the component
        # will not be rerendered if it already exsists.
        if args.execute :
            aProject.renderComponent(args.component_id.lower(), args.force)
        # Update a single component
        elif args.update :
            aProject.updateComponent(args.component_id.lower(), args.force)
        # Validate a single component
        elif args.validate :
            sys.exit('\nERROR: Validate not working yet (usfm_Text.testCompTextFile())\n')
        # Compare a component with backups of working or source text
        elif args.compare :
            Compare(args.project_id).compareComponent(args.group_id, args.component_id.lower(), args.compare)
        # Commands for editing project files
        elif args.edit :
                aProject.edit(args.component_id)

    # Binding level commands
    elif sys.argv[1].lower() == 'binding' :
        # Add a new binding group
        if args.add :
            Binding(args.project_id).addBindingGroup(args.bind_id, args.id_list, args.force)
        elif args.remove :
            Binding(args.project_id).removeBindingGroup(args.bind_id)
        elif args.execute :
            Binding(args.project_id).bindComponents(args.bind_id)

    # Font level commands
    elif sys.argv[1].lower() == 'font' :
        aProject = initProject(args.project_id, args.group_id)
        aProject.createManager(args.component_type, 'font')
        font = aProject.managers[args.component_type + '_Font'].checkForSubFont(args.font_id)
        manager = args.component_type + '_Font'
        if args.component_type :
            if args.add :
                # Physically install the font files
                aProject.managers[manager].installFont(font, args.force)
            elif args.remove :
                aProject.managers[manager].removeFont(args.component_type, font, args.force)
            elif args.main :
                aProject.managers[manager].setPrimaryFont(args.component_type.capitalize(), font, args.force)
        else :
            sys.exit('\nERROR: Component type ID is missing from command argument. Process halted!\n')

    # Hyphenation level commands
    elif sys.argv[1].lower() == 'hyphen' :
        aProject.createManager(args.component_type, 'hyphenation')
        manager = args.component_type + '_Hyphenation'
        if args.add :
            aProject.managers[manager].turnOnHyphenation()
        elif args.remove :
            aProject.managers[manager].turnOffHyphenation()
        elif args.update :
            aProject.managers[manager].updateHyphenation(args.force)
        elif args.compare :
            aProject.managers[manager].compareWithSource()

    # Illustration level commands
    elif sys.argv[1].lower() == 'illustration' :
        aProject.createManager(args.component_type, 'illustration')
        manager = args.component_type + '_Illustration'
        if args.add :
            aProject.managers[manager].installIllustrationFile(args.add, args.path, args.force)
        elif args.watermark :
            aProject.managers[manager].installWatermarkFile(args.watermark, args.path, args.force)
        elif args.remove :
            aProject.managers[manager].removeIllustrationFile(args.remove)

    # Post processing commands
    elif sys.argv[1].lower() == 'postprocess' :
        # Run a post process command on a component or component type
        # Because we can lock at all levels, there is no need for (-f --force)
        # to be used here. If a component name is given it will only run on that
        # component which includes all listed sub-components. Otherwise, all 
        # components of the specified type will be acted on by the postprocess.
        if args.execute :
            if not args.script :
                sys.exit('\nERROR: No script was specified, Please use -s to specify a script to execute.\n')
            elif not args.component_name.lower() :
                sys.exit('\nERROR: No component ID was specified, Please use -c to specify a valid component (group) ID to run this post process script on.\n')
            else :
                aProject.runProcessScript(args.component_name.lower(), args.script)
        # Install a custom or a default post process script, force to overwrite what is there
        elif args.add :
            filePath = ''
            if args.path :
                filePath = resolvePath(args.path)
                if not os.path.isfile(filePath) :
                    sys.exit('\nERROR: The following path does not appear to be valid: ' + filePath + '\n')
            aProject.installPostProcess(args.component_type, filePath, args.force)
        # Disconnect a post process script from the component type (This does not
        # physically remove it unless -f is used.)
        elif args.remove :
            aProject.removePostProcess(args.component_type, force)

    # Setting manipulation commands
    elif sys.argv[1].lower() == 'settings' :
        if args.configuration :
            if (args.section or args.key or args.value) :
                ProjSetup(args.project_id).changeConfigSetting(args.configuration, args.section, args.key, args.value)
            else :
                sys.exit('\nERROR: Must provide a section, key and value. Process halted!\n')
        else :
            sys.exit('\nERROR: Configuration name is missing from command argument. Process halted!\n')

    # Exporting commands
    elif sys.argv[1].lower() == 'export' :
        # Check further for required args
        if not args.component_name.lower() :
            sys.exit('\nERROR: Component ID is missing from command argument. Process halted!\n')
        else :
            aProject.createManager(args.component_type, 'text')
        # Execute an export
        if args.execute :
            aProject.export(args.component_type, args.component_name.lower(), args.path, args.script, args.bundle, args.force)

    # Install file commands
    elif sys.argv[1].lower() == 'install' :
        # Check further for required args
        if not args.file :
            sys.exit('\nERROR: File was not specified in the command argument. Process halted!\n')
        elif not args.path :
            sys.exit('\nERROR: Path to the project folder where file is to be installed. Process halted!\n')
        else :
            # Install the file
            aProject.installFile(args.file, args.path, args.force)

    # User Macro commands
    elif sys.argv[1].lower() == 'macro' :
        # Check further for required args
        if not args.name :
            sys.exit('\nERROR: Macro was not specified in the command argument. Process halted!\n')
        if args.add :
            aProject.addMacro(args.name, args.command, args.path, args.force)
        elif args.execute :
            aProject.runMacro(args.name)
        else :
            # Bad command
            sys.exit('\nERROR: Command [' + sys.argv[3] + '] not recognized. Process halted!\n')

    # Commands for setting the page background
    elif sys.argv[1].lower() == 'background' :
        if args.add :
            PageBackground(args.project_id).addBackground(args.background_type)
        elif args.remove :
            PageBackground(args.project_id).removeBackground(args.background_type)
        elif args.background_type == 'none' :
            PageBackground(args.project_id).backgroundOff()

    # Totally lost
    else:
        sys.exit('\nERROR: Command not recognized: [' + sys.argv[1] + ']\n')

    # During a process, a number of log entries will be made and written out.
    # Over time the log file could get very large. To control the size, there
    # is a setting in the user config file that limits the number of lines in
    # the log file. The default is 1000 but it can be adjusted if needed. The
    # following call here will trim the log file to its specified limit. This
    # is done here as there should be no further operations done at this point.
    # Note: This will not work with "project" commands (aProject is not declaired)
    # To get around that we will use a 'try' statement to prevent confusing errors.
    try :
        if not sys.argv[1].lower() == 'project' :
            if os.path.isfile(aProject.local.projLogFile) :
                trimLog(aProject.local.projLogFile, uc.userConfig['System']['projLogLineLimit'])
    except :
        pass

    # Look for an error log file and notify the user if one is found that there
    # were errors in the process. This might have failed because we loose our 
    # project object some times. For now, we'll put a 'try' around it.
    try :
        if not sys.argv[1].lower() == 'project' :
            if os.path.isfile(aProject.local.projErrorLogFile) :
                terminal('\n\t*** ERRORS OCCURRED. PLEASE CHECK ERROR LOG ***\n')
    except :
        pass

###############################################################################
############################### Argparser Setup ###############################
###############################################################################

# The following is applied to certain inputs to garentee input to be Unicode
# and not ascii or whatever the default file system encoding is.
# (Note: See the settings section for an example.)
fsunicode = partial(unicode, encoding=sys.getfilesystemencoding())

# We will try to maintain a common syntax in all the subparsers Some common
# argument options are:
#   -a = add something
#   -r = remove something
#   -e = execute something
#   -f = force the execution of something
#   -p = path (and file name) of something

# Setup the arg parser
parser = argparse.ArgumentParser(description=systemName)
subparsers = parser.add_subparsers(help='sub-command help')

# Add help subprocess arguments
helpCommand = subparsers.add_parser('help', help='General system help')

# Available choices
mediaTypes =        ['book']
componentTypes =    ['usfm']
backupTypes =       ['archive', 'backup', 'cloud', 'template']
backgrounds =       ['boarder', 'cropmarks', 'lines', 'none', 'watermark']

# Add main arguments (first postion options)
parser.add_argument('-a', '--about', action='store_true', help = 'Information about Rapuma')
parser.add_argument('-b', '--basic', action='store_true', help = 'Basic Rapuma help (in HTML)')

# Add project subprocess arguments
sysCommand = subparsers.add_parser('system', help='General system management commands help')
sysCommand.add_argument('-n', '--user_name', help='Proved a name of the user who will be using this system.')
sysCommand.add_argument('-r', '--resources', help='Proved a valid path to where the user resources, such as backups, archives, etc., will be located.')

# Add project subprocess arguments
projCommand = subparsers.add_parser('project', help='General project management commands help')
projCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
projCommand.add_argument('-d', '--delete', action='store_true', help='Delete a project permanently from the system. This will do just what is says. Be careful!')
projCommand.add_argument('-p', '--preserve', choices=backupTypes, help='If creating a new project, give a human readable name to describe this project.')
projCommand.add_argument('-r', '--restore', choices=backupTypes, help='This will restore a project from a backup or archive, Pull in data from a cloud backup. Or, create a new project from a template found in the Rapuma resouces folder.')
projCommand.add_argument('-s', '--sourcePath', help='An alternate path to a resouce to be used to start a new project such as an archive, template or backup. This is needed if the resource is not found in the normal specified Rapuma user resources.')
projCommand.add_argument('-t', '--targetPath', help='Path to the project home folder. This can be used for specifying the location of new projects based on templates, archives or just a standard new project. Do not provide the name of the project folder, just the path to where you want it to be.')
projCommand.add_argument('-m', '--media', choices=mediaTypes, help='If creating a new project, give a valid project media type code.')
projCommand.add_argument('-n', '--name', help='If creating a new project, give a human readable name to describe this project.')
projCommand.add_argument('-c', '--scripts', action='store_true', help='Create/recreate helper scripts that will help with various repetitive tasks.')

# Add group subprocess arguments
groupCommand = subparsers.add_parser('group', help='General project group management commands help')
groupCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
groupCommand.add_argument('group_id', help='The component type is needed for creating a new component.')
groupCommand.add_argument('-c', '--component_type', choices=componentTypes, help='The group component type is needed for creating a new group.')
groupCommand.add_argument('-a', '--add', action='store_true', help='Add a new component group to this project.')
groupCommand.add_argument('-r', '--remove', action='store_true', help='remove an existing component group from this project.')
groupCommand.add_argument('-s', '--source', help='Provide a valid path to where the component source files are found for this group. (Used for adding/updating components, one source path per component group allowed.)')
groupCommand.add_argument('-d', '--source_id', help='Specify an ID to associate with the source (required).')
groupCommand.add_argument('-i', '--cid_list', help='Specify components used in this group by their recognized ID. A group can have one or more components. The list must be enclosed by quotes and have only a space between ID codes, e.g. \"aaa bbb ccc\".')
groupCommand.add_argument('-f', '--force', action='store_true', help='Force an action to override a group lock.')
groupCommand.add_argument('-e', '--execute', action='store_true', help='Execute the render process for a specific group in this project.')
groupCommand.add_argument('-u', '--update', action='store_true', help='Update a component group. If -s (source) is used a new component source path will be recorded as well.')
groupCommand.add_argument('-p', '--preprocess', help='Turn on or off preprocessing when importing and updating components. To turn it on use "True", to turn off, use "False"')
groupCommand.add_argument('-o', '--output_list', action='store_true', help='Generate a list of valid component IDs with their names for the specified component type.')
groupCommand.add_argument('-l', '--lock', action='store_true', help='Lock a component group.')
groupCommand.add_argument('-n', '--unlock', action='store_true', help='Unlock a component group.')

# Add component subprocess arguments
compCommand = subparsers.add_parser('component', help='General project component management commands help')
compCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
compCommand.add_argument('group_id', help='The group ID this component is a part of.')
compCommand.add_argument('component_id', help='The component ID, required any actions to be done to it.')
compCommand.add_argument('-f', '--force', action='store_true', help='Force an action if overriding a lock is needed.')
compCommand.add_argument('-e', '--execute', action='store_true', help='Execute the render process for a specific component in this group.')
compCommand.add_argument('-v', '--validate', action='store_true', help='[NOT WORKING!] Validate a component file.')
compCommand.add_argument('-c', '--compare', help='Compare a component with another version. This parameter must be followed by the type of test to use. Use either "working" or "source". No other test types will be accepted.')
compCommand.add_argument('-u', '--update', action='store_true', help='Update a specific component in a specified group.')
compCommand.add_argument('-d', '--edit', action='store_true', help='Edit a specific component from a specified group.')

# Add binding subprocess arguments
bindCommand = subparsers.add_parser('binding', help='General project binding management commands help')
bindCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
bindCommand.add_argument('bind_id', help='Binding group ID (a positional argument required for all actions with this subprocess)')
bindCommand.add_argument('-a', '--add', action='store_true', help='Add a new binding group to this project.')
bindCommand.add_argument('-r', '--remove', action='store_true', help='Remove an exsisting binding group from this project.')
bindCommand.add_argument('-i', '--id_list', help='A list of groups that are to be bound together.')
bindCommand.add_argument('-e', '--execute', action='store_true', help='Execute the binding process for a specific binding group in this project.')
bindCommand.add_argument('-f', '--force', action='store_true', help='Force an action if overriding a default non-action is needed.')

# Add font subprocess arguments
fontCommand = subparsers.add_parser('font', help='General font handling commands help')
fontCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
fontCommand.add_argument('group_id', help='The group ID this font is a part of.')
fontCommand.add_argument('component_type', help='Specify the component type. This is required for all font functions.')
fontCommand.add_argument('font_id', help='The font family name ID. The ID given has to be a valid system font.')
fontCommand.add_argument('-a', '--add', action='store_true', help='Add a new font for a specific comonent type.')
fontCommand.add_argument('-r', '--remove', action='store_true', help='Remove the font of a specified ID from this project.')
fontCommand.add_argument('-f', '--force', action='store_true', help='Force the addition or removal of a font from the system even if it is used by other components.')
fontCommand.add_argument('-m', '--main', action='store_true', help='Set, the specified (valid system) font to be the main (primary) font for this component type.')

# Add text hyphenation processing subprocess arguments
hyphenCommand = subparsers.add_parser('hyphen', help='General settings for handling component text hyphenation processing commands.')
hyphenCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
hyphenCommand.add_argument('component_type', help='Specify the component group.')
hyphenCommand.add_argument('-a', '--add', action='store_true', help='Add (turn on) hyphenation for a component type. Note: if all the necessary components are not present, this could end badly.')
hyphenCommand.add_argument('-r', '--remove', action='store_true', help='Remove (turn off) hyphenation for a component type.')
hyphenCommand.add_argument('-f', '--force', action='store_true', help='When used with update (-u), this will delete the source hyphenation file that was copied into the project when it was created. Use this only if you are sure you want to replace it. Any edits done to this file will be lost.')
hyphenCommand.add_argument('-u', '--update', action='store_true', help='Update the hyphenation files. This is done normally when adjustments are made to configuration or a word list.')
hyphenCommand.add_argument('-c', '--compare', action='store_true', help='Compare the editable publishing project ParaTExt hyphenation file with its project source.')

# Add illustration subprocess arguments
illustrationCommand = subparsers.add_parser('illustration', help='General project illustration handling commands help')
illustrationCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
illustrationCommand.add_argument('component_type', help='The component type is needed when adding an illustration to a project. (This is a required positional argument.)')
illustrationCommand.add_argument('-a', '--add', help='Provide a file name for the illustration you wish to add to the project.')
illustrationCommand.add_argument('-r', '--remove', help='Provide a file name for an illustration you wish to remove from the project.')
illustrationCommand.add_argument('-p', '--path', help='If the illustration is in a unknown location, provide a valid path to where the illustration that is specified with -a.')
illustrationCommand.add_argument('-f', '--force', action='store_true', help='Force (overwrite) an illustration of the same name in the specified project.')

# Add text post processing subprocess arguments
postprocessCommand = subparsers.add_parser('postprocess', help='General settings for handling component post processing commands.')
postprocessCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
postprocessCommand.add_argument('component_type', help='Specify the component type. This is required for all post process operations.')
postprocessCommand.add_argument('-a', '--add', action='store_true', help='Install a post process into the project scripts folder. If you do not specify a process with path (-p) a default process script will be installed.')
postprocessCommand.add_argument('-r', '--remove', action='store_true', help='Disconnect a post process from the component type. This does not remove the actual script from the project unless force (-f) is used.')
postprocessCommand.add_argument('-f', '--force', action='store_true', help='Force a post process script to be updated, replaced or brought back to default condition for this component type.')
postprocessCommand.add_argument('-c', '--component_name', help='Give a (registered) component name to execute a post process script on all valid sub-components associated with that component.')
postprocessCommand.add_argument('-p', '--path', help='A valid path and file name of a specific post process script to be installed.')
postprocessCommand.add_argument('-s', '--script', help='Specify a script for executing. This is required for the -e command.')
postprocessCommand.add_argument('-e', '--execute', action='store_true', help='Execute a post process script. If a valid component ID is not specified, it will run on all components of the type it is a part of.')

# Add settings subprocess arguments
settingsCommand = subparsers.add_parser('settings', help='General settings handling commands help')
settingsCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
settingsCommand.add_argument('configuration', help='The configuration set that the target setting is from.')
settingsCommand.add_argument('section', help='The section path to the key/value pare to be changed. Multiple sections are separated by \'/\'.')
settingsCommand.add_argument('key', help='The key which has the value to be changed.')
settingsCommand.add_argument('value', type=fsunicode, help='A new value to add or change to the specified key.')

# Add Project exporting subprocess arguments
exportCommand = subparsers.add_parser('export', help='Commands for exporting data from a project for a variety of purposes.')
exportCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
exportCommand.add_argument('component_type', help='Component ID (a positional argument required for all actions with this subprocess)')
exportCommand.add_argument('component_name', help='Specify a valid component name to be exported. The sub-components associated with that name will be exported.')
exportCommand.add_argument('-p', '--path', help='Optional - This will specify a path/folder where the exported data is output to. Default is to create an export folder in the source folder and output to that.')
exportCommand.add_argument('-s', '--script', help='Optional - The name of an installed post process script to be used in the export process. Default will just blind copy the working text to the export folder.')
exportCommand.add_argument('-e', '--execute', action='store_true', help='Execute an export operation.')
exportCommand.add_argument('-b', '--bundle', action='store_true', help='Bundle the exported file(s) into a single compressed file.')
exportCommand.add_argument('-f', '--force', action='store_true', help='Force overwrite on exsisting file(s) of the same name.')

# Add Project install subprocess arguments
installCommand = subparsers.add_parser('install', help='Commands for manually installing files into a project for a variety of purposes.')
installCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
installCommand.add_argument('file', help='The file to be installed, relitive paths are allowed.')
installCommand.add_argument('path', help='Specify the path to the project folder where the file goes.')
installCommand.add_argument('-f', '--force', action='store_true', help='Force overwrite on exsisting file.')

# Add Macro subprocess arguments
macroCommand = subparsers.add_parser('macro', help='Commands for creating user macros and installing the files into a project for a variety of purposes.')
macroCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
macroCommand.add_argument('name', help='The name of the macro to create or call.')
macroCommand.add_argument('-a', '--add', action='store_true', help='Add/install the specified macro into the Macros/user folder.')
macroCommand.add_argument('-e', '--execute', action='store_true', help='Execute an installed macro.')
macroCommand.add_argument('-c', '--command', help='Add a list (\'[rapuma 1, rapuma 2, etc.]\') of Rapuma commands to a macro file. This would be used along with the -a command.')
macroCommand.add_argument('-p', '--path', help='If the macro you are adding already exsists, specify the path to it and include the name of the file. This would be used with the -a command and instead of -c command.')
macroCommand.add_argument('-f', '--force', action='store_true', help='Force overwrite on exsisting macro file.')

# Add Project preserve subprocess arguments
backgroundCommand = subparsers.add_parser('background', help='Commands for managing page backgrounds such as watermarks, lines, etc.')
backgroundCommand.add_argument('project_id', help='A project ID for the project you wish to archive, backup or make template from. If a project is being made from a template, the project ID must not conflict with any others on the system.')
backgroundCommand.add_argument('background_type', choices=backgrounds, default='none', help='The type of background to be applied or removed from the output.')
backgroundCommand.add_argument('-a', '--add', action='store_true', help='Add a background type.')
backgroundCommand.add_argument('-r', '--remove', action='store_true', help='Remove background type.')

# Send the collected arguments to the handler
userArguments(parser.parse_args(), local)


###############################################################################
########################### Close out the session #############################
###############################################################################

# In case there are any Canadians using this, politely say good bye
terminal('\n\t\tThank you, please come again!\n')













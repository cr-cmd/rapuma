#!/usr/bin/python
# -*- coding: utf-8 -*-
# By Dennis Drescher (dennis_drescher at sil.org


###############################################################################
######################### Description/Documentation ###########################
###############################################################################

# One script to rule them all.  This is the main Rapuma engine script.
# This script will drive all processes and keep track of what happens in the
# project log in each respective project.


###############################################################################
################################ Initialize Rapuma ###############################
###############################################################################
# Firstly, import all the standard Python modules we need for this process and
# set the base path

import os, sys

# Set the Rapuma base program paths
rapumaHome = os.environ.get('RAPUMA_BASE')
sysHome = os.environ.get('HOME')
if not rapumaHome :
    for t in (os.path.join(sysHome, '.local'), '/usr/local', '/usr') :
        rapumaHome = os.path.join(t, 'share', 'rapuma')
        if os.path.exists(os.path.join(rapumaHome, 'resources')) :
            os.environ['RAPUMA_BASE'] = rapumaHome
            break

# Set the Rapuma program resources path
#rapumaResources = os.environ.get('RAPUMA_RESOURCES')
#if not rapumaResources :
#    rapumaResources = os.path.join(rapumaHome, 'resources')
#    os.environ['RAPUMA_RESOURCES'] = rapumaResources

# Set the user environment path
userHome = os.environ.get('RAPUMA_USER')
if not userHome :
    userHome = os.path.join(sysHome, '.config', 'rapuma')
    os.environ['RAPUMA_USER'] = userHome

# Set the (potential) project home
projHome = os.getcwd()

# Load standard Python modules
import codecs, shutil, operator, argparse, subprocess, zipfile
from datetime import *
from configobj import ConfigObj

# Load the local classes
from rapuma.core.proj_local import ProjLocal
from rapuma.core.proj_log import ProjLog
from rapuma.core.tools import *
from rapuma.core.user_config import UserConfig
from rapuma.core.proj_config import ProjConfig
from rapuma.project.project import Project

# Instantiate User classes
local           = ProjLocal(rapumaHome, userHome, projHome)
uc              = UserConfig(local)
log             = ProjLog(local, uc)

# Set some global vars
systemName      = 'Rapuma (Rapid Publication Manager)'
systemAbout     = 'Rapuma is a publishing management system written by the friendly developers at Payap University\'s Linguistics Institute (Text Unit). Rapuma stands for Rapid Publication Manager. It is currently being deployed in MSEAG and is under heavy development. Anyone wanting to try this system should be warned that it may not work in their context. However, the underlying principals of the system should work in any long document publishing environment. Therefore the package should be evaluated with that in mind. We welcome input and participation in this project. It is our hope it will be able to serve more than just MSEAG. For questions or more information please write: dennis_drescher@sil.org.'
systemVersion   = '0.1.20130306122042'

# Give a welcome message
terminal('\n\t\tWelcome to ' + systemName)
terminal('\n\t\t\tVersion ' + systemVersion + '\n')

###########################################################################
############################## Rapuma Functions ##############################
###########################################################################


def newProject (uc, pc, pid, pname = None, tid = None, pmid = None) :
    '''Create a new publishing project.'''

    # Because the location of where a project is to be created could be
    # different than the cwd, we will count on pc.local to have all the
    # correct information. 
    
    # Check the pmid
    if not pmid :
        pmid = 'book'
    else :
        pmid = pmid.lower()

    # Check the pname, make one up if there isn't any
    if not pname :
        pname = 'The ' + pid + ' project'

    # Run some basic tests to see if this project can be created
    # Look for project in current folder
    if not os.path.isfile(pc.local.projConfFile) :
        # Look for locked project in current folder
        if os.path.isfile(pc.local.projConfFile + pc.local.lockExt) :
            terminal('ERR: Halt! Locked project already defined in target folder')
            return
        # Look for project in parent folder (don't want project in project)
        elif os.path.isfile(os.path.join(os.path.dirname(pc.local.projHome), pc.local.projConfFileName)) :
            terminal('ERR: Halt! Live project already defined in parent folder')
            return
        # Look for locked project in parent folder (prevent project in project)
        elif os.path.isfile(os.path.join(os.path.dirname(pc.local.projHome), pc.local.projConfFileName + pc.local.lockExt)) :
            terminal('ERR: Halt! Locked project already defined in parent folder')
            return
        # Check if path to parent is valid
        elif not os.path.isdir(os.path.dirname(pc.local.projHome)) :
            terminal('ERR: Halt! Not a valid (parent) path: ' + os.path.dirname(pc.local.projHome))
            return
        # Test if this project already exists in the user's config file.
        elif uc.isRegisteredProject(pid) :
            terminal('ERR: Halt! ID [' + pid + '] already defined for another project')
            return
    else :
        terminal('ERR: Halt! A project already exsits in this location. Please remove it before continuing.')
        return

    # If we made it to this point, we need to make a new project folder
    if not os.path.exists(pc.local.projConfFolder) :
        os.makedirs(pc.local.projConfFolder)

    # Create the project depeding on if it is from a template or not
    if tid :
        templateToProject(uc, pc.local.projHome, pid, tid, pname)
    else :
        # If not from a template, just create a new version of the project config file
        pc.makeNewProjConf(pc.local, pid, pmid, pname, systemVersion)

    # Add project to local Rapuma project registry
    uc.registerProject(pid, pname, pmid, pc.local.projHome)

    # Report what we did
    terminal('Created new project [' + pid + ']')
    return True


def deleteProject (uc, pid = None) :
    '''Delete a project fromthe Rapuma system registry and from the hard drive.'''

    global local

    # If no pid was given this fails
    if not pid :
        terminal('\nERROR: Project ID code not given or found. delete operation failed.\n')
        return

    # Check if project is registered with Rapuma and get real path and reinit local paths
    if not testForSetting(uc.userConfig, 'Projects', pid) :
        terminal('\nERROR: [' + pid + '] not a valid registered project, cannot continue with delete operation.\n')
        return
    else :
        local = ProjLocal(rapumaHome, userHome, uc.userConfig['Projects'][pid]['projectPath'])

    # Remove references from user rapuma.conf
    if uc.unregisterProject(pid) :
        terminal('Removed [' + pid + '] from user configuration.')
    else :
        terminal('Failed to remove [' + pid + '] from user configuration.')

    # Delete everything in the project path
    if os.path.isdir(local.projHome) :
        shutil.rmtree(local.projHome)
        terminal('Removed project files for [' + pid + '] from hard drive.')
    else :
        terminal('Warning: [' + pid + '] project could not be found, unable to delete project files.')
        return

    # Report the process is done
    terminal('Removal process for [' + pid + '] is completed.')
    return True


def isProject (pid) :
    '''Look up in the user config to see if a project is registered.
    If it is not, stop the process.'''

    try :
        if pid in uc.userConfig['Projects'].keys() :
            pass
    except :
        sys.exit('\nERROR: Project ID [' + pid + '] is not valid! Process halted.\n')


def isTemplate (tid) :
    '''Check to see if a template exsists in the user's template store area.'''

    try :
        templates = uc.userConfig['Resources']['templates']
        if tid + '.zip' in os.listdir(templates) :
            return True
    except :
        return False


def initProject (pid) :
    '''Initialize an existing project according to the project ID given.'''

    local   = ProjLocal(rapumaHome, userHome, uc.userConfig['Projects'][pid]['projectPath'])
    pc      = ProjConfig(local)
    log     = ProjLog(local, uc)
    if testForSetting(pc.projConfig, 'ProjectInfo', 'projectIDCode') :
        aProject = Project(uc.userConfig, pc.projConfig, local, log, systemVersion)
        return aProject


def accessHtmlHelp () :
    '''Call on the Rapuma basic HTML help system.'''

    # Build the viewer command
    cmds = uc.userConfig['System']['htmlHelpViewerCommand']
    cmds.append(local.rapumaHelpIndexFile)
    # Run the viewer command
    rCode = subprocess.call(cmds)


###############################################################################
########################## Archive Project Functions ##########################
###############################################################################

def makeExcludeFileList (aProject) :
    '''Return a list of files that are not necessary to be included in a backup
    template or an archive. These will be all auto-generated files that containe system-
    specific paths, etc.'''

    excludeFiles = []
    excludeTypes = ['.delayed', '.log', '.parlocs', '.pdf', '.tex', '.piclist', '.adj']

    # Work out from the component type what the settings file names are
    for cType in aProject.projConfig['CompTypes'].keys() :
        rndr = aProject.projConfig['CompTypes'][cType]['renderer']
        aProject.createManager(cType.lower(), rndr)
        excludeFiles.append(aProject.managers[cType.lower() + '_' + rndr.capitalize()].macLinkFile)
        excludeFiles.append(aProject.managers[cType.lower() + '_' + rndr.capitalize()].setFileName)

    # Now add to the list all the .tex files that are associated with components
    for cName in aProject.projConfig['Components'].keys() :
        # Need to create component obj. (Is there a better way?)
        aProject.createComponent(cName)
        # Sort out cid types
        if aProject.components[cName].getUsfmCid(cName) :
            for t in excludeTypes :
                cidFile = os.path.join(aProject.local.projComponentsFolder, cName, aProject.components[cName].getUsfmCid(cName) + t)
                if os.path.isfile(cidFile) :
                    excludeFiles.append(aProject.components[cName].getUsfmCid(cName) + t)
        # Sort out cName types
        for t in excludeTypes :
            cNameFile = os.path.join(aProject.local.projComponentsFolder, cName, cName + t)
            if os.path.isfile(cNameFile) :
                excludeFiles.append(cName + t)

    return excludeFiles


def backupProject (pid) :
    '''Backup a project. Send the compressed backup file to the user-specified
    backup folder. If none is specified, put the archive in cwd. If a valid
    path is specified, send it to that location. This is a very simplified
    backup so it will only keep one copy in any given location. If another
    copy exists, it will overwrite it.'''

    # Check to see if the pid is valid in the system (it has to be)
    isProject(pid)
    projHome = uc.userConfig['Projects'][pid]['projectPath']
    aProject = initProject(pid)

    # Set some paths and file names
    backupName = pid + '.zip'
    userBackups = uc.userConfig['Resources']['backups']
    backupTarget = ''
    if os.path.isdir(userBackups) :
        backupTarget = os.path.join(userBackups, backupName)
    else :
        terminal('\nError: User backup storage path not yet configured!\n')
        dieNow()

    # Get a list of files we don't want
    excludeFiles = makeExcludeFileList(aProject)

    zipUpProject(projHome, backupTarget, excludeFiles)

    # Finish here
    terminal('Backup for [' + pid + '] created and saved to: ' + backupTarget + '\n')


def archiveProject (pid, path = None) :
    '''Archive a project. Send the compressed archive file to the user-specified
    archive folder. If none is specified, put the archive in cwd. If a valid
    path is specified, send it to that location. Like backup, this too will
    overwrite any existing file of the same name. The difference is that this
    will also disable the project so it cannot be accesses by Rapuma. When a
    project is archived, all work should cease on the project.'''

    # Make a private project object just for archiving
    aProject = initProject(pid)
    # Set some paths and file names
    archName = aProject.projectIDCode + '.rapuma'
    userArchives = uc.userConfig['Resources']['archives']
    archTarget = ''
    if path :
        path = resolvePath(path)
        if os.path.isdir(path) :
            archTarget = os.path.join(path, archName)
        else :
            terminal('\nError: The path given is not valid: [' + path + ']\n')
            dieNow()
    elif os.path.isdir(userArchives) :
        archTarget = os.path.join(userArchives, archName)
    elif os.path.isdir(os.path.dirname(aProject.local.projHome)) :
        # Default to the dir just above the project
        archTarget = os.path.dirname(aProject.local.projHome)
    else :
        terminal('\nError: Cannot resolve a path to create the archive file!\n')
        dieNow()

    # Get a list of files we don't want
    excludeFiles = makeExcludeFileList(aProject)

    zipUpProject(aProject.local.projHome, archTarget, excludeFiles)

    # Rename the source dir to indicate it was archived
    bakArchProjDir = aProject.local.projHome + '(archived)'
    if os.path.isdir(bakArchProjDir) :
        terminal('\nError: Cannot complete archival process!\n')
        terminal('\nAnother archived version of this project exsits with the folder name of: ' + fName(bakArchProjDir) + '\n')
        terminal('\nPlease remove or rename it and then repete the process.\n')
        dieNow()
    else :
        os.rename(aProject.local.projHome, bakArchProjDir)

    # Remove references from user rapuma.conf
    if uc.unregisterProject(pid) :
        terminal('Removed [' + pid + '] from user configuration.\n')
    else :
        terminal('Error: Failed to remove [' + pid + '] from user configuration.\n')

    # Finish here
    terminal('Archive for [' + pid + '] created and saved to: ' + archTarget + '\n')


def zipUpProject (source, target = None, excludeFiles = None) :
    '''Zip up a project and deposit it to target location. Be sure to strip
    out all all auto-created, user-specific files that could mess up a
    transfer to another system. This goes for archives and backups'''

    # Do the zip magic here
    # First list some types we don't want to include in our archive
    if not excludeFiles :
        excludeFiles = []
#    excludeType = ['.delayed', '.log', '.parlocs', '.pdf']
#    # Now list the full file names of any excptions to the above type exclusions
#    excludeException = ['rapuma.log']
    root_len = len(source)
    with zipfile.ZipFile(target, 'w', compression=zipfile.ZIP_DEFLATED) as myzip :
        for root, dirs, files in os.walk(source):
            # Chop off the part of the path we do not need to store
            zip_root = os.path.abspath(root)[root_len:]
            for f in files:
                if f in excludeFiles :
                    continue
                if not f[-1] == '~' :
                    fn, fx = os.path.splitext(f)
#                    if not fx in excludeType or f in excludeException :
                    fullpath = os.path.join(root, f)
                    zip_name = os.path.join(zip_root, f)
                    myzip.write(fullpath, zip_name, zipfile.ZIP_DEFLATED)


def restoreArchive (pid, targetPath, sourcePath = None) :
    '''Restore a project from the user specified storage area or sourcePath if 
    specified. Use targetPath to specify where the project will be restored.
    Rapuma will register the project there.'''

    # Check to see if the user included the extention
    try :
        pid.split('.')[1] == 'rapuma'
        archName = pid
        pid = pid.split('.')[0]
    except :
        archName = pid + '.rapuma'

    archSource = ''
    archTarget = ''
    userArchives = ''

    # First look for the archive that is to be restored
    if sourcePath :
        if os.path.isdir(sourcePath) :
            archSource = os.path.join(sourcePath, archName)
    elif os.path.isdir(uc.userConfig['Resources']['archives']) :
        userArchives = uc.userConfig['Resources']['archives']
        archSource = os.path.join(userArchives, archName)
    else :
        terminal('\nError: The path (or name) given is not valid: [' + archSource + ']\n')
        dieNow()

    # Now set the target params
    if targetPath :
        if not os.path.isdir(targetPath) :
            terminal('\nError: The path given is not valid: [' + targetPath + ']\n')
            dieNow()
        else :
            archTarget = os.path.join(targetPath, pid)

    # If we made it this far, extract the archive
    with zipfile.ZipFile(archSource, 'r') as myzip :
        myzip.extractall(archTarget)

    # Permission for executables is lost in the zip, fix it here
    for folder in ['Scripts', os.path.join('Macros', 'User')] :
        fixExecutables(os.path.join(archTarget, folder))

    # Add project to local Rapuma project registry
    # To do this we need to open up the restored project config file
    # and pull out some settings.
    local       = ProjLocal(rapumaHome, userHome, archTarget)
    pc          = ProjConfig(local)
    log         = ProjLog(local, uc)
    aProject    = Project(uc.userConfig, pc.projConfig, local, log, systemVersion)
#    import pdb; pdb.set_trace()
    uc.registerProject(aProject.projectIDCode, aProject.projectName, aProject.projectMediaIDCode, aProject.local.projHome)

    # Finish here
    terminal('\nRapuma archive [' + pid + '] has been restored to: ' + archTarget + '\n')


def restoreBackup (pid) :
    '''Restore a project from the user specified storage area. If that
    is not set, it will look for the backup (pid.zip) in cwd. Use path to
    specify where the project will be restored. Rapuma will register the project
    there. Otherwise, it will restore to cwd and register it there.'''

    # Check to see if the user included the extention
    try :
        pid.split('.')[1] == 'zip'
        backName = pid
        pid = pid.split('.')[0]
    except :
        backName = pid + '.zip'

    # Check to see if the pid is valid in the system (it has to be)
    isProject(pid)
    projHome = uc.userConfig['Projects'][pid]['projectPath']

    # Check to see if the archive exsists
    try :
        if os.path.isdir(uc.userConfig['Resources']['backups']) :
            backup = os.path.join(uc.userConfig['Resources']['backups'], backName)
    except :
        terminal('\nError: The path (or name) given is not valid: [' + backup + ']\n')
        dieNow()

    # Make the exsiting project a temp backup in case something goes wrong
    if os.path.isdir(projHome) :
        # Remove old backup-backup
        if os.path.isdir(projHome + '.bak') :
            shutil.rmtree(projHome + '.bak')
        # Make a fresh copy of the backup-backup
        shutil.copytree(projHome, projHome + '.bak')

    # If we made it this far, extract the archive
    with zipfile.ZipFile(backup, 'r') as myzip :
        myzip.extractall(projHome)

    # Permission for executables is lost in the zip, fix it here
    for folder in ['Scripts', os.path.join('Macros', 'User')] :
        fixExecutables(os.path.join(projHome, folder))

    # Finish here (We will leave the backup-backup in place)
    terminal('\nRapuma backup [' + pid + '] has been restored to: ' + projHome + '\n')


def projectToTemplate (pid, tid) :
    '''Preserve critical project information in a template. The pid is the project
    that the template will be bassed from. The tid will be provided by the user for
    this operation and used to create new projects.'''

    # Set source and target
    projHome            = uc.userConfig['Projects'][pid]['projectPath']
    templateDir         = uc.userConfig['Resources']['templates']
    targetDir           = os.path.join(templateDir, tid)
    target              = os.path.join(templateDir, tid + '.zip')
    source              = projHome

    # Make a temp copy of the project that we can manipulate
    shutil.copytree(source, targetDir)

    # Now make the config files generic for use with any project
    pc = ConfigObj(os.path.join(targetDir, 'Config', 'project.conf'), encoding='utf-8')
    aProject = initProject(pc['ProjectInfo']['projectIDCode'])
    pc['ProjectInfo']['projectName']                = ''
    pc['ProjectInfo']['projectIDCode']              = ''
    pc['ProjectInfo']['projectCreateDate']          = ''
    pc['ProjectInfo']['projectCreateDate']          = ''
    for c in pc['Components'].keys() :
        compDir = os.path.join(targetDir, 'Components', c)
        if os.path.isdir(compDir) :
            shutil.rmtree(compDir)
        del pc['Components'][c]
    pc.filename                                     = os.path.join(targetDir, 'Config', 'project.conf')
    pc.write()
    # Kill the log file
    os.remove(os.path.join(targetDir, 'rapuma.log'))

    # Exclude files
    excludeFiles = makeExcludeFileList(aProject)

    # Zip it up using the above params
    root_len = len(targetDir)
    with zipfile.ZipFile(target, 'w', compression=zipfile.ZIP_DEFLATED) as myzip :
        for root, dirs, files in os.walk(targetDir):
            # Chop off the part of the path we do not need to store
            zip_root = os.path.abspath(root)[root_len:]
            for f in files:
                if f[-1] == '~' :
                    continue
                elif f in excludeFiles :
                    continue
                elif f.rfind('.') != -1 :
                    fullpath = os.path.join(root, f)
                    zip_name = os.path.join(zip_root, f)
                    myzip.write(fullpath, zip_name, zipfile.ZIP_DEFLATED)

    # Remove the temp project dir we made
    shutil.rmtree(targetDir)
    terminal('\nCompleted creating template: ' + fName(target) + '\n')


def templateToProject (uc, projHome, pid, tid, pname, source = None) :
    '''Create a new project based on the provided template ID. This
    function is called from newProject() so all preliminary checks
    have been done. It should be good to go.'''

    # Test to see if the project is already there
    if os.path.isdir(projHome) :
        terminal('\nError: Project [' + pid + '] already exsits.')
        dieNow()

    if not source :
        source = os.path.join(uc.userConfig['Resources']['templates'], tid + '.zip')

    # Validate template
    if not os.path.isfile(source) :
        terminal('\nError: Template not found: ' + source)
        dieNow()

    # Unzip the template in place to start the new project
    with zipfile.ZipFile(source, 'r') as myzip :
        myzip.extractall(projHome)

    # Peek into the project
    pc = ConfigObj(os.path.join(projHome, 'Config', 'project.conf'), encoding='utf-8')

    pc['ProjectInfo']['projectName']               = pname
    pc['ProjectInfo']['projectCreateDate']         = tStamp()
    pc['ProjectInfo']['projectIDCode']             = pid
    pc.filename                                    = os.path.join(projHome, 'Config', 'project.conf')
    pc.write()

    # Get the media type from the newly placed project for registration
    projectMediaIDCode = pc['ProjectInfo']['projectMediaIDCode']

    # Register the new project
    uc.registerProject(pid, pname, projectMediaIDCode, projHome)
    
    # Report what happened
    terminal('A new project [' + pid + '] has been created based on the [' + tid + '] template.')


def pullFromCloud (pid) :
    '''Pull data from cloud storage and merge/replace local data.
    Do a full backup first before starting the actual pull operation.'''

    # Do not do anything until we have done a backup
    backupProject(pid)

    # Get the paths we need
    cloud               = os.path.join(uc.userConfig['Resources']['cloud'], pid)
    projHome            = uc.userConfig['Projects'][pid]['projectPath']

    # Get a total list of files from the project
    cn = 0
    cr = 0
    for folder, subs, files in os.walk(cloud):
        for fileName in files:
            if not os.path.isdir(folder.replace(cloud, projHome)) :
                os.makedirs(folder.replace(cloud, projHome))
            cFile = os.path.join(folder, fileName)
            pFile = os.path.join(folder, fileName).replace(cloud, projHome)
            if not os.path.isfile(pFile) :
                shutil.copy(cFile, pFile)
                cn +=1
            elif isOlder(cFile, pFile) :
                if os.path.isfile(pFile) :
                    os.remove(pFile)
                shutil.copy(cFile, pFile)
                cr +=1
    # Report what happened
    terminal('\nCompleted pulling data from the cloud.\n')
    if cn == 0 and cr == 0 :
        terminal('\tNo files updated.\n')
    else :
        if cn > 0 :
            terminal('\tAdded: ' + str(cn) + ' file(s).\n')
        if cr > 0 :
            terminal('\tUpdated: ' + str(cr) + ' file(s).\n')


def pushToCloud (pid) :
    '''Push local project data to the cloud. If a file in the cloud is
    older than the project file, it will be sent. Otherwise, it will
    be skipped.'''

    aProject            = initProject(pid)
    projHome            = uc.userConfig['Projects'][pid]['projectPath']
    local               = ProjLocal(rapumaHome, userHome, projHome)
    cloud               = os.path.join(uc.userConfig['Resources']['cloud'], pid)

    # Make a cloud
    if not os.path.isdir(cloud) :
        os.makedirs(cloud)

    # Get a list of files we do not want
    excludeFiles        = makeExcludeFileList(aProject)

    # Get a total list of files from the project
    cn = 0
    cr = 0
    for folder, subs, files in os.walk(projHome):
        for fileName in files:
            if fileName not in excludeFiles :
                if not os.path.isdir(folder.replace(projHome, cloud)) :
                    os.makedirs(folder.replace(projHome, cloud))
                cFile = os.path.join(folder, fileName).replace(projHome, cloud)
                pFile = os.path.join(folder, fileName)
                if not os.path.isfile(cFile) :
                    shutil.copy(pFile, cFile)
                    cn +=1
                elif isOlder(pFile, cFile) :
                    if os.path.isfile(cFile) :
                        os.remove(cFile)
                    shutil.copy(pFile, cFile)
                    cr +=1
    # Report what happened
    terminal('\nCompleted pushing/saving data to the cloud.\n')
    if cn == 0 and cr == 0 :
        terminal('\tNo files updated.\n')
    else :
        if cn > 0 :
            terminal('\tAdded: ' + str(cn) + ' file(s).\n')
        if cr > 0 :
            terminal('\tUpdated: ' + str(cr) + ' file(s).\n')


def getProjectScripInfo (pid) :
    '''Create a dictionary of all the auxillary script information used in
    most projects.'''

    aProject = initProject(pid)
    projHome            = uc.userConfig['Projects'][pid]['projectPath']
    local               = ProjLocal(rapumaHome, userHome, projHome)
    cType = 'usfm'

    return {
            'addBible'      : ['Add all the Scripture components for a Bible.',     'rapuma component ' + pid + ' ' + cType + ' Bible -a -s $1 -i "gen exo lev num deu jos jdg rut 1sa 2sa 1ki 2ki 1ch 2ch ezr neh est job psa pro ecc sng isa jer lam ezk dan hos jol amo oba jon mic nam hab zep hag zec mal mat mrk luk jhn act rom 1co 2co gal eph php col 1th 2th 1ti 2ti tit phm heb jas 1pe 2pe 1jn 2jn 3jn jud rev"'], 
            'addNT'         : ['Add all the Scripture components for an NT.',       'rapuma component ' + pid + ' ' + cType + ' NT -a -s $1 -i "mat mrk luk jhn act rom 1co 2co gal eph php col 1th 2th 1ti 2ti tit phm heb jas 1pe 2pe 1jn 2jn 3jn jud rev"'], 
            'addOT'         : ['Add all the Scripture components for an OT.',       'rapuma component ' + pid + ' ' + cType + ' OT -a -s $1 -i "gen exo lev num deu jos jdg rut 1sa 2sa 1ki 2ki 1ch 2ch ezr neh est job psa pro ecc sng isa jer lam ezk dan hos jol amo oba jon mic nam hab zep hag zec mal"'], 
            'archive'       : ['Archive this project',                              'rapuma preserve ' + pid + ' -a '], 
            'backup'        : ['Backup this project',                               'rapuma preserve ' + pid + ' -b '], 
            'cloudPull'     : ['Pull data for this project from the cloud',         'rapuma project ' + pid + ' -u '], 
            'cloudPush'     : ['Push data from this project to the cloud',          'rapuma project ' + pid + ' -p '], 
            'compare'       : ['Compare component working text with start point.',  'rapuma component ' + pid + ' ' + cType + ' $1 -c working'], 
            'cropmarksOff'  : ['Turn off cropmarks on output page.',                'rapuma settings ' + pid + ' ' + aProject.projectMediaIDCode + '_layout PageLayout useCropmarks False '], 
            'cropmarksOn'   : ['Turn on cropmarks on output page.',                 'rapuma settings ' + pid + ' ' + aProject.projectMediaIDCode + '_layout PageLayout useLines False \n\nrapuma settings ' + pid + ' ' + aProject.projectMediaIDCode + '_layout PageLayout useCropmarks True '], 
            'edit'          : ['Edit specified component file.',                    'rapuma edit ' + pid + ' -c $1 -g -s'], 
            'export'        : ['Export working text from component or group.',      'rapuma export ' + pid + ' ' + cType + ' $1 -e -f  '], 
            'hyphenCompare' : ['Compare working hyphen file with source.',          'rapuma hyphen ' + pid + ' ' + cType + ' -c  '], 
            'hyphenOff'     : ['Turn off hyphenation in project.',                  'rapuma hyphen ' + pid + ' ' + cType + ' -r  '], 
            'hyphenOn'      : ['Turn on hyphenation in project.',                   'rapuma hyphen ' + pid + ' ' + cType + ' -a  '], 
            'hyphenUpdate'  : ['Update hyphenation working files.',                 'rapuma hyphen ' + pid + ' ' + cType + ' -u $1 '], 
            'linesOff'      : ['Turn off line background.',                         'rapuma settings ' + pid + ' ' + aProject.projectMediaIDCode + '_layout PageLayout useLines False '], 
            'linesOn'       : ['Turn on line background.',                          'rapuma settings ' + pid + ' ' + aProject.projectMediaIDCode + '_layout PageLayout useCropmarks False \n\nrapuma settings ' + pid + ' ' + aProject.projectMediaIDCode + '_layout PageLayout useLines True '], 
            'placeholdOff'  : ['Turn off illustration placeholders.',               'rapuma settings ' + pid + ' ' + aProject.projectMediaIDCode + '_layout Illustrations useFigurePlaceHolders False '], 
            'placeholdOn'   : ['Turn on illustration placeholders.',                'rapuma settings ' + pid + ' ' + aProject.projectMediaIDCode + '_layout Illustrations useFigurePlaceHolders True '], 
            'postprocess'   : ['Run a post-process script.',                        'rapuma locking ' + pid + ' $1 -u \n\nrapuma postprocess ' + pid + ' ' + cType + ' -c $1 -e -s $2 '], 
            'render'        : ['Render a component.',                               'rapuma component ' + pid + ' ' + cType + ' $1 -e -f '], 
            'restore'       : ['Restore a backup.',                                 'rapuma preserve ' + pid + ' -b -r '], 
            'template'      : ['Create a template of the project.',                 'rapuma preserve ' + pid + ' -t $1 '], 
            'update'        : ['Update a component from its source.',               'rapuma component ' + pid + ' ' + cType + ' $1 -u -f '], 
            'updateScripts' : ['Update the project scripts.',                       'rapuma project ' + pid + ' -s '], 
            'view'          : ['View a component.',                                 'rapuma component ' + pid + ' ' + cType + ' $1 -e '], 
            'watermarkOff'  : ['Turn off watermark on output page.',                'rapuma settings ' + pid + ' ' + aProject.projectMediaIDCode + '_layout PageLayout useWatermark False '], 
            'watermarkOn'   : ['Turn on watermark on output page.',                 'rapuma settings ' + pid + ' ' + aProject.projectMediaIDCode + '_layout PageLayout useWatermark True \n\n']
        }


def makeProjectScripts (uc, pid) :
    '''Create helper scripts for a project to help with repetitive tasks.
    If any scripts are present with the same name they will be overwritten.
    Note: This is only for temporary use due to the lack of an interface at
    this time (20130306140636). It assumes the cType is usfm which, at some point
    may not be the case.'''

    aProject = initProject(pid)
    projHome            = uc.userConfig['Projects'][pid]['projectPath']
    local               = ProjLocal(rapumaHome, userHome, projHome)
    cType = 'usfm'
    if not os.path.isdir(local.projScriptsFolder) :
        os.mkdir(local.projScriptsFolder)
    # Output the scripts
    allScripts = getProjectScripInfo(pid)
    for key in allScripts.keys() :
        fullFile = os.path.join(local.projScriptsFolder, key)
        with codecs.open(fullFile, "w", encoding='utf_8') as writeObject :
            writeObject.write('#!/bin/sh\n\n')
            writeObject.write('# Description: ' + allScripts[key][0] + '\n\n')
            writeObject.write('echo \n')
            writeObject.write('echo Rapuma script: ' + allScripts[key][0] + '\n\n')
            writeObject.write(allScripts[key][1] + '\n\n')

        # Make the script executable
        makeExecutable(fullFile)

    terminal('\nCompleted creating/recreating helper scripts.\n')


###############################################################################
########################### Rapuma Command Center #############################
###############################################################################

# All command options must contain a project ID (-i). That is required. If one
# is not listed then the incoming command is either considered malformed or
# incomplete. If there is a way to figure out what the user might be needing
# the help system will be called. Otherwise, Rapuma will quite.

# The argument handler
def userArguments (args) :
    '''Process incoming command arguments.'''

    # Pre-command process: Extra help access
    if sys.argv[1].lower() == 'help' :
        if args['about'] :
            terminal('\n' + systemName + ' version ' + systemVersion + '\n')
            terminal('About: ' + systemAbout + '\n')
            return
        if args['basic'] :
            accessHtmlHelp()
            return

    # Pre-command process: System level commands
    if sys.argv[1].lower() == 'system' :
        if args['user_name'] :
            uc.setSystemSettings('userName', args['user_name'])
        elif args['resources'] :
            uc.setSystemSettings('resources', args['resources'])

    # Test project ID, intercept if it is an example demo
    elif sys.argv[1].lower() != 'project' :
        isProject(args['project_id'])
        # Now setup the project and look for and test the component type if needed
        aProject = initProject(args['project_id'])
        # Test component type if used
        if 'component_type' in args :
            exclude = ['settings', 'locking', 'install', 'macro', 'archive', 'edit']
            if not sys.argv[1].lower() in exclude :
                if not testForSetting(aProject.projConfig, 'CompTypes', args['component_type'].capitalize()) :
                    if args['component_type'] in uc.userConfig['System']['recognizedComponentTypes'] :
                        if not aProject.addComponentType(args['component_type']) :
                            sys.exit('\nERROR: Not able to add component type: ' + args['component_type'] + ' Process halted!\n')
                    else :
                        sys.exit('\nERROR: Component type given: ' + args['component_type'] + ' Is not valid in Rapuma. Process halted!\n')

    # Command processing
    # Dummy place holder for 'system' which as actually processed above
    if sys.argv[1].lower() == 'system' :
        pass

    elif sys.argv[1].lower() == 'project' :
        pid = args['project_id']
        # Remove an exsisting project
        if args['remove'] :
            deleteProject(uc, pid)
        # Restore (or revert to) the last backup
        elif args['revert'] :
            restoreBackup(pid)
        # Create/refresh helper scripts
        elif args['scripts'] :
            makeProjectScripts(uc, pid)
        # Backup (evaporate) to cloud
        elif args['push'] :
            pushToCloud(pid)
        # Update (get rained on) from the cloud
        elif args['pull'] :
            pullFromCloud(pid)
        # Creating a new project from a template, archive, or scratch
        else :
            # First test for some necessary params
            if not args['targetPath'] :
                # A path must be given
                sys.exit('\nERROR: No path for this project has been given. Process halting.\n')
            else :
                # If a targetPath is given we need to resolve it
                targetPath = resolvePath(args['targetPath'])
                if not os.path.isdir(targetPath) :
                    sys.exit('\nERROR: Cannot resolve the given path [' + targetPath + ']. Process halting.\n')
                else :
                    projFolder = os.path.join(targetPath, pid)
            # Source path is optional but if given, resolve it
            if 'sourcePath' in args :
                    sourcePath = resolvePath(args['sourcePath'])
            # New project from template
            if args['template'] :
                tid = args['template']
                templateSource = ''
                if sourcePath :
                    templateSource = os.path.join(sourcePath, tid + '.zip')
                templateToProject(uc, projFolder, pid, tid, args['name'], templateSource)
            # New (to current system) project from archive
            elif args['archive'] :
                restoreArchive(pid, targetPath, sourcePath)
            # Just creating from scratch
            else :
                # Create a new project
                local   = ProjLocal(rapumaHome, userHome, projFolder)
                pc      = ProjConfig(local)
                newProject(uc, pc, args['project_id'], args['name'], args['template'], args['media'])
                # Create helper scripts if desired
                if str2bool(uc.userConfig['System']['autoHelperScripts']) :
                    makeProjectScripts(uc, args['project_id'])

    elif sys.argv[1].lower() == 'component' :
        if not args['component_name'] :
            sys.exit('\nERROR: Must provide a component name when adding a new component. Process halted!\n')
        # Add a new component
        if args['add'] :
            if not args['id_list'] :
                sys.exit('\nERROR: Must provide a list (-i) of one or more valid component IDs (sub-components) when adding a component. Process halted!\n')
            else :
                aProject.addComponent(args['component_type'], args['component_name'], args['id_list'], args['source'], args['force'])
        # Delete a component
        elif args['update'] :
            # Update a component, --source is optional but if given it will
            # overwrite the current setting. The --force setting will be needed
            # to unlock the component
            aProject.updateComponent(args['component_name'], args['source'], args['force'])
        elif args['remove'] :
            # If -f is used, we delete all the files with this cid
            aProject.removeComponent(args['component_name'], args['force'])
        # Render vs. view command is just a matter of forcing the component
        # to be rendered if render is selected by the user. Otherwise, if
        # only view is requested, if force is set to False and the component
        # will not be rerendered if it already exsists.
        elif args['execute'] :
            aProject.renderComponent(args['component_type'], args['component_name'], args['force'])
        elif args['validate'] :
            aProject.createManager(args['component_type'], 'text')
            aProject.managers[args['component_type'] + '_Text'].testCompTextFile(args['path'])
        elif args['compare'] :
            aProject.compareComponent(args['component_name'], args['compare'])
        elif args['preprocess'] :
            aProject.turnOnOffPreprocess(args['component_type'], args['preprocess'])
        elif args['list'] :
            aProject.listAllComponents(args['component_type'], args['component_name'])

    # Font level commands
    elif sys.argv[1].lower() == 'font' :
        aProject.createManager(args['component_type'], 'font')
        font = aProject.managers[args['component_type'] + '_Font'].checkForSubFont(args['font_id'])
        manager = args['component_type'] + '_Font'
        if args['component_type'] :
            if args['add'] :
                # Physically install the font files
                aProject.managers[manager].installFont(font, args['force'])
            elif args['remove'] :
                aProject.managers[manager].removeFont(args['component_type'], font, args['force'])
            elif args['main'] :
                aProject.managers[manager].setPrimaryFont(args['component_type'].capitalize(), font, args['force'])
        else :
            sys.exit('\nERROR: Component type ID is missing from command argument. Process halted!\n')

    # Style level commands
    elif sys.argv[1].lower() == 'style' :
        aProject.createManager(args['component_type'], 'style')
        manager = args['component_type'] + '_Style'
        if args['style_type'] :
            if args['add'] :
                aProject.managers[manager].addStyleFile(args['style_type'], args['path'], args['force'])
            elif args['remove'] :
                aProject.managers[manager].removeStyleFile(args['Style_type'], args['force'])
            elif args['validate'] :
                # In this context we want to stop if an error is found and report it
                # Passing true to validateStyleFile will do that
                aProject.managers[manager].testStyleFile(args['path'])
        else :
            if args['style_type'].lower() not in ['main', 'custom'] :
                sys.exit('\nERROR: Style file type (-t) is either missing or incorrect.\n')

    # Hyphenation level commands
    elif sys.argv[1].lower() == 'hyphen' :
        aProject.createManager(args['component_type'], 'hyphenation')
        manager = args['component_type'] + '_Hyphenation'
        if args['add'] :
            aProject.managers[manager].turnOnHyphenation()
        elif args['remove'] :
            aProject.managers[manager].turnOffHyphenation()
        elif args['update'] :
            aProject.managers[manager].updateHyphenation(args['force'])
        elif args['compare'] :
            aProject.managers[manager].compareWithSource()

    # Illustration level commands
    elif sys.argv[1].lower() == 'illustration' :
        aProject.createManager(args['component_type'], 'illustration')
        manager = args['component_type'] + '_Illustration'
        if args['add'] :
            aProject.managers[manager].installIllustrationFile(args['add'], args['path'], args['force'])
        elif args['watermark'] :
            aProject.managers[manager].installWatermarkFile(args['watermark'], args['path'], args['force'])
        elif args['remove'] :
            aProject.managers[manager].removeIllustrationFile(args['remove'])

    # Post processing commands
    elif sys.argv[1].lower() == 'postprocess' :
        # Run a post process command on a component or component type
        # Because we can lock at all levels, there is no need for (-f --force)
        # to be used here. If a component name is given it will only run on that
        # component which includes all listed sub-components. Otherwise, all 
        # components of the specified type will be acted on by the postprocess.
        if args['execute'] :
            if not args['script'] :
                sys.exit('\nERROR: No script was specified, Please use -s to specify a script to execute.\n')
            elif not args['component_name'] :
                sys.exit('\nERROR: No component ID was specified, Please use -c to specify a valid component (group) ID to run this post process script on.\n')
            else :
                aProject.runProcessScript(args['component_name'], args['script'])
        # Install a custom or a default post process script, force to overwrite what is there
        elif args['add'] :
            filePath = ''
            if args['path'] :
                filePath = resolvePath(args['path'])
                if not os.path.isfile(filePath) :
                    sys.exit('\nERROR: The following path does not appear to be valid: ' + filePath + '\n')
            aProject.installPostProcess(args['component_type'], filePath, args['force'])
        # Disconnect a post process script from the component type (This does not
        # physically remove it unless -f is used.)
        elif args['remove'] :
            aProject.removePostProcess(args['component_type'], force)

    # Setting manipulation commands
    elif sys.argv[1].lower() == 'settings' :
        aProject = initProject(args['project_id'])
        if args['configuration'] :
            if (args['section'] or args['key'] or args['value']) :
                aProject.changeConfigSetting(args['configuration'], args['section'], args['key'], args['value'])
            else :
                sys.exit('\nERROR: Must provide a section, key and value. Process halted!\n')
        else :
            sys.exit('\nERROR: Configuration name is missing from command argument. Process halted!\n')

    # Locking commands
    elif sys.argv[1].lower() == 'locking' :
        aProject = initProject(args['project_id'])
        # Lock component
        if args['lock'] :
            aProject.lockUnlock(args['component_name'], True, args['force'])
        # Unlock component
        elif args['unlock'] :
            aProject.lockUnlock(args['component_name'], False, args['force'])

    # Exporting commands
    elif sys.argv[1].lower() == 'export' :
        # Check further for required args
        if not args['component_name'] :
            sys.exit('\nERROR: Component ID is missing from command argument. Process halted!\n')
        else :
            aProject.createManager(args['component_type'], 'text')
        # Execute an export
        if args['execute'] :
            aProject.export(args['component_type'], args['component_name'], args['path'], args['script'], args['bundle'], args['force'])

    # Install file commands
    elif sys.argv[1].lower() == 'install' :
        # Check further for required args
        if not args['file'] :
            sys.exit('\nERROR: File was not specified in the command argument. Process halted!\n')
        elif not args['path'] :
            sys.exit('\nERROR: Path to the project folder where file is to be installed. Process halted!\n')
        else :
            # Install the file
            aProject.installFile(args['file'], args['path'], args['force'])

    # User Macro commands
    elif sys.argv[1].lower() == 'macro' :
        # Check further for required args
        if not args['name'] :
            sys.exit('\nERROR: Macro was not specified in the command argument. Process halted!\n')
        if args['add'] :
            aProject.addMacro(args['name'], args['command'], args['path'], args['force'])
        elif args['execute'] :
            aProject.runMacro(args['name'])
        else :
            # Bad command
            sys.exit('\nERROR: Command [' + sys.argv[3] + '] not recognized. Process halted!\n')

    # The demo commands were intercepted at the begining

    # Commands to preserve project data. (Check PID and if necessary TID before passing it on)
    elif sys.argv[1].lower() == 'preserve' :
        isProject(args['project_id'])
        if args['archive'] :
            archiveProject(args['project_id'])
        elif args['backup'] :
            backupProject(args['project_id'])
        elif args['template'] :
            if isTemplate(args['template']) :
                sys.exit('\nError: This template [' + args['template'] + '] already exsists. Process halted.\n')
            projectToTemplate(args['project_id'], args['template'])
        elif args['synchronize_pull'] :
            synchronize_pull(args['project_id'])
        elif args['synchronize_push'] :
            synchronize_push(args['project_id'])
        else :
            # Bad command
            sys.exit('\nERROR: Must provide -a (--archive), -b (--backup), -t (--template), -p (synchronize_pull), or -u (synchronize_push). Process halted!\n')

    # Commands for editing project files
    elif sys.argv[1].lower() == 'edit' :
            aProject.edit(args['component'], args['global'], args['system'])

    # Totally lost
    else:
        sys.exit('\nERROR: Command not recognized: [' + sys.argv[1] + ']\n')

    # During a process, a number of log entries will be made and written out.
    # Over time the log file could get very large. To control the size, there
    # is a setting in the user config file that limits the number of lines in
    # the log file. The default is 1000 but it can be adjusted if needed. The
    # following call here will trim the log file to its specified limit. This
    # is done here as there should be no further operations done at this point.
    # Note: This will not work with "project" commands (aProject is not declaired)
    # To get around that we will use a 'try' statement to prevent confusing errors.
    try :
        if not sys.argv[1].lower() == 'project' :
            if os.path.isfile(aProject.local.projLogFile) :
                trimLog(aProject.local.projLogFile, uc.userConfig['System']['projLogLineLimit'])
    except :
        pass

    # Look for an error log file and notify the user if one is found that there
    # were errors in the process. This might have failed because we loose our 
    # project object some times. For now, we'll put a 'try' around it.
    try :
        if not sys.argv[1].lower() == 'project' :
            if os.path.isfile(aProject.local.projErrorLogFile) :
                terminal('\n\t*** ERRORS OCCURRED. PLEASE CHECK ERROR LOG ***\n')
    except :
        pass

###############################################################################
############################### Argparser Setup ###############################
###############################################################################

# We will try to maintain a common syntax in all the subparsers Some common
# argument options are:
#   -a = add something
#   -r = remove something
#   -e = execute something
#   -f = force the execution of something
#   -p = path (and file name) of something

# Setup the arg parser
parser = argparse.ArgumentParser(description=systemName)
subparsers = parser.add_subparsers(help='sub-command help')

# Add help subprocess arguments
helpCommand = subparsers.add_parser('help', help='General system help')

# Add main arguments (first postion options)
parser.add_argument('-a', '--about', action='store_true', help = 'Information about Rapuma')
parser.add_argument('-b', '--basic', action='store_true', help = 'Basic Rapuma help (in HTML)')

# Add project subprocess arguments
sysCommand = subparsers.add_parser('system', help='General system management commands help')
sysCommand.add_argument('-u', '--user_name', help='Proved a name of the user who will be using this system.')
sysCommand.add_argument('-r', '--resources', help='Proved a valid path to where the user resources, such as backups, archives, etc., will be located.')

# Add project subprocess arguments
projCommand = subparsers.add_parser('project', help='General project management commands help')
projCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
projCommand.add_argument('-r', '--remove', action='store_true', help='Remove a project permanently from the system. This will do just what is says. Be careful!')
projCommand.add_argument('-o', '--sourcePath', help='An alternate path to a resouce to be used to start a new project such as an archive, template or backup. This is needed if the resource is not found in the normal specified Rapuma user resources.')
projCommand.add_argument('-g', '--targetPath', help='Path to the project home folder. This can be used for specifying the location of new projects based on templates, archives or just a standard new project. Do not provide the name of the project folder, just the path to where you want it to be.')
projCommand.add_argument('-m', '--media', help='If creating a new project, give a valid project media type code.')
projCommand.add_argument('-n', '--name', help='If creating a new project, give a human readable name to describe this project.')
projCommand.add_argument('-s', '--scripts', action='store_true', help='Create/recreate helper scripts that will help with various repetitive tasks.')
projCommand.add_argument('-t', '--template', help='Specify a template to base a new project on. If not specified, you must use -m to specify a media type.')
projCommand.add_argument('-v', '--revert', help='This will revert the project to the last backup, if one exists. Project backups are found in the users Rapuma resouces folder.')
projCommand.add_argument('-c', '--archive', action='store_true', help='Restore the given project ID from an archive. Archives are normally stored in the users Rapuma resouces folder. If the archive is not there, use -o (--sourcePath) to specify where the project archive file can be found.')
projCommand.add_argument('-p', '--push', action='store_true', help='Push your local working project data to cloud storage.')
projCommand.add_argument('-u', '--pull', action='store_true', help='Pull from cloud storage to your local data. Any data in the cloud that is newer than your project data will overwrite files in your project. A backup will be made just before the actual pull operation begins. :-)')

# Add component subprocess arguments
compCommand = subparsers.add_parser('component', help='General project component management commands help')
compCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
compCommand.add_argument('component_type', help='The component type is needed for creating a new component.')
compCommand.add_argument('component_name', help='The component name, required for creating a new component or any actions to be done to it.')
compCommand.add_argument('-a', '--add', action='store_true', help='Add a new component to this project.')
compCommand.add_argument('-r', '--remove', action='store_true', help='remove an existing component from this project.')
compCommand.add_argument('-s', '--source', help='Provide a valid path to where the source file is found. (Used for adding/updating components, one source path per component type allowed.)')
compCommand.add_argument('-i', '--id_list', help='Use this if this is a group component. This is a list of components to be in this group. The list must be enclosed by quotes and have only a space between ID codes, e.g. \"aaa bbb ccc\".')
compCommand.add_argument('-f', '--force', action='store_true', help='Force an action if overriding a default non-action is needed.')
compCommand.add_argument('-e', '--execute', action='store_true', help='Execute the render process for a specific component in this project.')
compCommand.add_argument('-v', '--validate', action='store_true', help='[NOT WORKING!] Validate a component file.')
compCommand.add_argument('-c', '--compare', help='Compare a component with another version. This parameter must be followed by the type of test to use. Use either "working" or "source". No other test types will be accepted.')
compCommand.add_argument('-p', '--path', help='Provide a valid path and file name if a specific file is to be tested.')
compCommand.add_argument('-u', '--update', action='store_true', help='Update a component. If -s (source) is used a new component source path will be recorded as well.')
compCommand.add_argument('-o', '--preprocess', help='Turn on or off preprocessing when importing and updating components. To turn it on use "True", to turn off, use "False"')
compCommand.add_argument('-l', '--list', action='store_true', help='Generate a list of valid component IDs with their names for this component type.')

# Add font subprocess arguments
fontCommand = subparsers.add_parser('font', help='General font handling commands help')
fontCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
fontCommand.add_argument('component_type', help='Specify the component type. This is required for all font functions.')
fontCommand.add_argument('font_id', help='The font family name ID. The ID given has to be a valid system font.')
fontCommand.add_argument('-a', '--add', action='store_true', help='Add a new font for a specific comonent type.')
fontCommand.add_argument('-r', '--remove', action='store_true', help='Remove the font of a specified ID from this project.')
fontCommand.add_argument('-f', '--force', action='store_true', help='Force the addition or removal of a font from the system even if it is used by other components.')
fontCommand.add_argument('-m', '--main', action='store_true', help='Set, the specified (valid system) font to be the main (primary) font for this component type.')

# Add style subprocess arguments
styleCommand = subparsers.add_parser('style', help='General component style handling commands help')
styleCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
styleCommand.add_argument('component_type', help='The component type is needed when adding a style for this type of component. (This is a required positional argument.)')
styleCommand.add_argument('style_type', help='The type of style file this is. There are two acceptable types, \"main\" and \"custom\". (This is a required positional argument.)')
styleCommand.add_argument('-a', '--add', action='store_true', help='Add a new style for a specific comonent type.')
styleCommand.add_argument('-r', '--remove', action='store_true', help='Remove a style file for this component type.')
styleCommand.add_argument('-p', '--path', help='Provide a valid path and file name if a specific style file is required or to be auto-generated. Otherwise, a default will be used.')
styleCommand.add_argument('-f', '--force', action='store_true', help='Force the addition or removal of a style from this component.')
styleCommand.add_argument('-v', '--validate', action='store_true', help='[NOT IMPLEMENTED] Validate a style file. Must use -p to provide a path and file name.')

# Add text hyphenation processing subprocess arguments
hyphenCommand = subparsers.add_parser('hyphen', help='General settings for handling component text hyphenation processing commands.')
hyphenCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
hyphenCommand.add_argument('component_type', help='Specify the component type. This is required for all post process operations.')
hyphenCommand.add_argument('-a', '--add', action='store_true', help='Add (turn on) hyphenation for a component type. Note: if all the necessary components are not present, this could end badly.')
hyphenCommand.add_argument('-r', '--remove', action='store_true', help='Remove (turn off) hyphenation for a component type.')
hyphenCommand.add_argument('-f', '--force', action='store_true', help='When used with update (-u), this will delete the source hyphenation file that was copied into the project when it was created. Use this only if you are sure you want to replace it. Any edits done to this file will be lost.')
hyphenCommand.add_argument('-u', '--update', action='store_true', help='Update the hyphenation files. This is done normally when adjustments are made to configuration or a word list.')
hyphenCommand.add_argument('-c', '--compare', action='store_true', help='Compare the editable publishing project ParaTExt hyphenation file with its project source.')

# Add illustration subprocess arguments
illustrationCommand = subparsers.add_parser('illustration', help='General project illustration handling commands help')
illustrationCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
illustrationCommand.add_argument('component_type', help='The component type is needed when adding an illustration to a project. (This is a required positional argument.)')
illustrationCommand.add_argument('-a', '--add', help='Provide a file name for the illustration you wish to add to the project.')
illustrationCommand.add_argument('-w', '--watermark', help='Provide a file name for an illustration, normally a PDF file, you wish to add to the project for use as a page watermark.')
illustrationCommand.add_argument('-r', '--remove', help='Provide a file name for an illustration you wish to remove from the project.')
illustrationCommand.add_argument('-p', '--path', help='If the illustration is in a unknown location, provide a valid path to where the illustration that is specified with -a.')
illustrationCommand.add_argument('-f', '--force', action='store_true', help='Force (overwrite) an illustration of the same name in the specified project.')

# Add text post processing subprocess arguments
postprocessCommand = subparsers.add_parser('postprocess', help='General settings for handling component post processing commands.')
postprocessCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
postprocessCommand.add_argument('component_type', help='Specify the component type. This is required for all post process operations.')
postprocessCommand.add_argument('-a', '--add', action='store_true', help='Install a post process into the project scripts folder. If you do not specify a process with path (-p) a default process script will be installed.')
postprocessCommand.add_argument('-r', '--remove', action='store_true', help='Disconnect a post process from the component type. This does not remove the actual script from the project unless force (-f) is used.')
postprocessCommand.add_argument('-f', '--force', action='store_true', help='Force a post process script to be updated, replaced or brought back to default condition for this component type.')
postprocessCommand.add_argument('-c', '--component_name', help='Give a (registered) component name to execute a post process script on all valid sub-components associated with that component.')
postprocessCommand.add_argument('-p', '--path', help='A valid path and file name of a specific post process script to be installed.')
postprocessCommand.add_argument('-s', '--script', help='Specify a script for executing. This is required for the -e command.')
postprocessCommand.add_argument('-e', '--execute', action='store_true', help='Execute a post process script. If a valid component ID is not specified, it will run on all components of the type it is a part of.')

# Add settings subprocess arguments
settingsCommand = subparsers.add_parser('settings', help='General settings handling commands help')
settingsCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
settingsCommand.add_argument('configuration', help='The configuration set that the target setting is from.')
settingsCommand.add_argument('section', help='The section path to the key/value pare to be changed. Multiple sections are separated by \'/\'.')
settingsCommand.add_argument('key', help='The key which has the value to be changed.')
settingsCommand.add_argument('value', help='A new value to add or change to the specified key.')

# Add Project Locking subprocess arguments
lockCommand = subparsers.add_parser('locking', help='Commands for locking down projects or parts of a project. This will prevent accidental processing.')
lockCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
lockCommand.add_argument('component_name', help='A specific component name required for locking or unlocking.')
lockCommand.add_argument('-l', '--lock', action='store_true', help='Lock a project or component. If a component or component type are not specified, the entire project will be locked and not available to any processes.')
lockCommand.add_argument('-u', '--unlock', action='store_true', help='Unlock a project or component. This is hierarchical. If the entire project is locked, unlocking component types or components cannot take place until the entire project is unlocked.')
lockCommand.add_argument('-f', '--force', action='store_true', help='Force lock/unlock of any subcomponents that belong to the specified component.')

# Add Project exporting subprocess arguments
exportCommand = subparsers.add_parser('export', help='Commands for exporting data from a project for a variety of purposes.')
exportCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
exportCommand.add_argument('component_type', help='Component ID (a positional argument required for all actions with this subprocess)')
exportCommand.add_argument('component_name', help='Specify a valid component name to be exported. The sub-components associated with that name will be exported.')
exportCommand.add_argument('-p', '--path', help='Optional - This will specify a path/folder where the exported data is output to. Default is to create an export folder in the source folder and output to that.')
exportCommand.add_argument('-s', '--script', help='Optional - The name of an installed post process script to be used in the export process. Default will just blind copy the working text to the export folder.')
exportCommand.add_argument('-e', '--execute', action='store_true', help='Execute an export operation.')
exportCommand.add_argument('-b', '--bundle', action='store_true', help='Bundle the exported file(s) into a single compressed file.')
exportCommand.add_argument('-f', '--force', action='store_true', help='Force overwrite on exsisting file(s) of the same name.')

# Add Project install subprocess arguments
installCommand = subparsers.add_parser('install', help='Commands for manually installing files into a project for a variety of purposes.')
installCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
installCommand.add_argument('file', help='The file to be installed, relitive paths are allowed.')
installCommand.add_argument('path', help='Specify the path to the project folder where the file goes.')
installCommand.add_argument('-f', '--force', action='store_true', help='Force overwrite on exsisting file.')

# Add Macro subprocess arguments
macroCommand = subparsers.add_parser('macro', help='Commands for creating user macros and installing the files into a project for a variety of purposes.')
macroCommand.add_argument('project_id', help='Project ID (a positional argument required for all actions with this subprocess)')
macroCommand.add_argument('name', help='The name of the macro to create or call.')
macroCommand.add_argument('-a', '--add', action='store_true', help='Add/install the specified macro into the Macros/user folder.')
macroCommand.add_argument('-e', '--execute', action='store_true', help='Execute an installed macro.')
macroCommand.add_argument('-c', '--command', help='Add a list (\'[rapuma 1, rapuma 2, etc.]\') of Rapuma commands to a macro file. This would be used along with the -a command.')
macroCommand.add_argument('-p', '--path', help='If the macro you are adding already exsists, specify the path to it and include the name of the file. This would be used with the -a command and instead of -c command.')
macroCommand.add_argument('-f', '--force', action='store_true', help='Force overwrite on exsisting macro file.')

# Add Project archive subprocess arguments
preserveCommand = subparsers.add_parser('preserve', help='Commands for preserving project data projects and project data.')
preserveCommand.add_argument('project_id', help=' A project ID for the project you wish to archive, backup or make template from. If a project is being made from a template, the project ID must not conflict with any others on the system.')
preserveCommand.add_argument('-a', '--archive', action='store_true', help='Archive the specified project to the archive storage area specified in the user configuration.')
preserveCommand.add_argument('-b', '--backup', action='store_true', help='Backup the specified project to the backup storage area specified in the user configuration.')
preserveCommand.add_argument('-t', '--template', help='Supply a template ID for creating a template of a specified project. It will save it to the template storage area specified in the user configuration. This must be a unique ID when creating a new template.')

# Add Project edit subprocess arguments
editCommand = subparsers.add_parser('edit', help='Commands for editing project files.')
editCommand.add_argument('project_id', help=' A project ID for the project you wish to edit files in.')
editCommand.add_argument('-c', '--component', help='Edit files related to the specified component.')
editCommand.add_argument('-g', '--global', action='store_true', help='Edit global project files, including configuration, macro and style files.')
editCommand.add_argument('-s', '--system', action='store_true', help='Edit system files, like the Rapuma configuration file.')

# Send the collected arguments to the handler
userArguments(vars(parser.parse_args()))


###############################################################################
########################### Close out the session #############################
###############################################################################

# In case there are any Canadians using this, politely say good bye
if not sys.argv[1].lower() == 'example' :
    terminal('\n\t\tThank you, please come again!\n')












